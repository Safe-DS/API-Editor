{
  "sklearn/sklearn/setup_module": {},
  "sklearn/sklearn.impute/__getattr__": {},
  "sklearn/sklearn.utils/_in_unstable_openblas_configuration": {},
  "sklearn/sklearn.utils/safe_mask": {},
  "sklearn/sklearn.utils/axis0_safe_slice": {},
  "sklearn/sklearn.utils/_array_indexing": {},
  "sklearn/sklearn.utils/_pandas_indexing": {},
  "sklearn/sklearn.utils/_list_indexing": {},
  "sklearn/sklearn.utils/_determine_key_type": {
    "accept_slice": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.utils/_determine_key_type/accept_slice",
          "name": "accept_slice",
          "qname": "sklearn.utils._determine_key_type.accept_slice",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Whether or not to raise an error if the key is a slice."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.utils/_determine_key_type/key",
          "name": "key",
          "qname": "sklearn.utils._determine_key_type.key",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "scalar, slice or array-like",
            "default_value": "",
            "description": "The key from which we want to infer the data type."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "scalar"
              },
              {
                "kind": "NamedType",
                "name": "slice"
              },
              {
                "kind": "NamedType",
                "name": "array-like"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "if the key is a slice"
        },
        "hasAction": {
          "action": "Whether or not to raise an error"
        }
      }
    ]
  },
  "sklearn/sklearn.utils/_safe_indexing": {
    "X": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.utils/_safe_indexing/X",
          "name": "X",
          "qname": "sklearn.utils._safe_indexing.X",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "array-like, sparse-matrix, list, pandas.DataFrame, pandas.Series",
            "default_value": "",
            "description": "Data from which to sample rows, items or columns. `list` are only\nsupported when `axis=0`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like"
              },
              {
                "kind": "NamedType",
                "name": "sparse-matrix"
              },
              {
                "kind": "NamedType",
                "name": "list"
              },
              {
                "kind": "NamedType",
                "name": "pandas.DataFrame"
              },
              {
                "kind": "NamedType",
                "name": "pandas.Series"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.utils/_safe_indexing/axis",
          "name": "axis",
          "qname": "sklearn.utils._safe_indexing.axis",
          "default_value": "0",
          "assigned_by": "NAME_ONLY",
          "is_public": false,
          "docstring": {
            "type": "int",
            "default_value": "0",
            "description": "The axis along which `X` will be subsampled. `axis=0` will select\nrows while `axis=1` will select columns."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "hasCondition": {
          "condition": "when axis equals 0"
        },
        "hasAction": {
          "action": "list are only supported"
        }
      }
    ],
    "indices": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.utils/_safe_indexing/indices",
          "name": "indices",
          "qname": "sklearn.utils._safe_indexing.indices",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "bool, int, str, slice, array-like",
            "default_value": "",
            "description": "- If `axis=0`, boolean and integer array-like, integer slice,\n  and scalar integer are supported.\n- If `axis=1`:\n    - to select a single column, `indices` can be of `int` type for\n      all `X` types and `str` only for dataframe. The selected subset\n      will be 1D, unless `X` is a sparse matrix in which case it will\n      be 2D.\n    - to select multiples columns, `indices` can be one of the\n      following: `list`, `array`, `slice`. The type used in\n      these containers can be one of the following: `int`, 'bool' and\n      `str`. However, `str` is only supported when `X` is a dataframe.\n      The selected subset will be 2D."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "bool"
              },
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "slice"
              },
              {
                "kind": "NamedType",
                "name": "array-like"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.utils/_safe_indexing/axis",
          "name": "axis",
          "qname": "sklearn.utils._safe_indexing.axis",
          "default_value": "0",
          "assigned_by": "NAME_ONLY",
          "is_public": false,
          "docstring": {
            "type": "int",
            "default_value": "0",
            "description": "The axis along which `X` will be subsampled. `axis=0` will select\nrows while `axis=1` will select columns."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "hasCondition": {
          "condition": "If axis equals 0 , boolean and integer array - like , integer slice , and scalar integer"
        },
        "hasAction": {
          "action": "- are supported"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.utils/_safe_indexing/indices",
          "name": "indices",
          "qname": "sklearn.utils._safe_indexing.indices",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "bool, int, str, slice, array-like",
            "default_value": "",
            "description": "- If `axis=0`, boolean and integer array-like, integer slice,\n  and scalar integer are supported.\n- If `axis=1`:\n    - to select a single column, `indices` can be of `int` type for\n      all `X` types and `str` only for dataframe. The selected subset\n      will be 1D, unless `X` is a sparse matrix in which case it will\n      be 2D.\n    - to select multiples columns, `indices` can be one of the\n      following: `list`, `array`, `slice`. The type used in\n      these containers can be one of the following: `int`, 'bool' and\n      `str`. However, `str` is only supported when `X` is a dataframe.\n      The selected subset will be 2D."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "bool"
              },
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "slice"
              },
              {
                "kind": "NamedType",
                "name": "array-like"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.utils/_safe_indexing/X",
          "name": "X",
          "qname": "sklearn.utils._safe_indexing.X",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "array-like, sparse-matrix, list, pandas.DataFrame, pandas.Series",
            "default_value": "",
            "description": "Data from which to sample rows, items or columns. `list` are only\nsupported when `axis=0`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like"
              },
              {
                "kind": "NamedType",
                "name": "sparse-matrix"
              },
              {
                "kind": "NamedType",
                "name": "list"
              },
              {
                "kind": "NamedType",
                "name": "pandas.DataFrame"
              },
              {
                "kind": "NamedType",
                "name": "pandas.Series"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "when X is a dataframe"
        },
        "hasAction": {
          "action": "However , str is only supported"
        }
      }
    ],
    "axis": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.utils/_safe_indexing/axis",
          "name": "axis",
          "qname": "sklearn.utils._safe_indexing.axis",
          "default_value": "0",
          "assigned_by": "NAME_ONLY",
          "is_public": false,
          "docstring": {
            "type": "int",
            "default_value": "0",
            "description": "The axis along which `X` will be subsampled. `axis=0` will select\nrows while `axis=1` will select columns."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.utils/_safe_indexing/axis",
          "name": "axis",
          "qname": "sklearn.utils._safe_indexing.axis",
          "default_value": "0",
          "assigned_by": "NAME_ONLY",
          "is_public": false,
          "docstring": {
            "type": "int",
            "default_value": "0",
            "description": "The axis along which `X` will be subsampled. `axis=0` will select\nrows while `axis=1` will select columns."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "hasCondition": {
          "condition": "while axis equals 1"
        },
        "hasAction": {
          "action": "will select rows"
        }
      }
    ]
  },
  "sklearn/sklearn.utils/_safe_assign": {},
  "sklearn/sklearn.utils/_get_column_indices": {},
  "sklearn/sklearn.utils/resample": {},
  "sklearn/sklearn.utils/shuffle": {},
  "sklearn/sklearn.utils/safe_sqr": {},
  "sklearn/sklearn.utils/_chunk_generator": {},
  "sklearn/sklearn.utils/gen_batches": {},
  "sklearn/sklearn.utils/gen_even_slices": {},
  "sklearn/sklearn.utils/tosequence": {},
  "sklearn/sklearn.utils/_to_object_array": {},
  "sklearn/sklearn.utils/indices_to_mask": {},
  "sklearn/sklearn.utils/_message_with_time": {},
  "sklearn/sklearn.utils/_print_elapsed_time": {},
  "sklearn/sklearn.utils/get_chunk_n_rows": {},
  "sklearn/sklearn.utils/_is_pandas_na": {},
  "sklearn/sklearn.utils/is_scalar_nan": {},
  "sklearn/sklearn.utils/_approximate_mode": {},
  "sklearn/sklearn.utils/check_matplotlib_support": {},
  "sklearn/sklearn.utils/check_pandas_support": {},
  "sklearn/sklearn.base/clone": {
    "safe": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.base/clone/safe",
          "name": "safe",
          "qname": "sklearn.base.clone.safe",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "If safe is False, clone will fall back to a deep copy on objects\nthat are not estimators."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.base/clone/safe",
          "name": "safe",
          "qname": "sklearn.base.clone.safe",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "If safe is False, clone will fall back to a deep copy on objects\nthat are not estimators."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "If safe is False"
        },
        "hasAction": {
          "action": ", clone will fall back to a deep copy on objects that are not estimators"
        }
      }
    ]
  },
  "sklearn/sklearn.base/BaseEstimator/_get_param_names": {},
  "sklearn/sklearn.base/BaseEstimator/get_params": {},
  "sklearn/sklearn.base/BaseEstimator/set_params": {},
  "sklearn/sklearn.base/BaseEstimator/__repr__": {},
  "sklearn/sklearn.base/BaseEstimator/__getstate__": {},
  "sklearn/sklearn.base/BaseEstimator/__setstate__": {},
  "sklearn/sklearn.base/BaseEstimator/_more_tags": {},
  "sklearn/sklearn.base/BaseEstimator/_get_tags": {},
  "sklearn/sklearn.base/BaseEstimator/_check_n_features": {},
  "sklearn/sklearn.base/BaseEstimator/_check_feature_names": {
    "reset": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.base/BaseEstimator/_check_feature_names/reset",
          "name": "reset",
          "qname": "sklearn.base.BaseEstimator._check_feature_names.reset",
          "default_value": null,
          "assigned_by": "NAME_ONLY",
          "is_public": false,
          "docstring": {
            "type": "bool",
            "default_value": "",
            "description": "Whether to reset the `feature_names_in_` attribute.\nIf False, the input will be checked for consistency with\nfeature names of data provided when reset was last True.\n.. note::\n   It is recommended to call `reset=True` in `fit` and in the first\n   call to `partial_fit`. All other methods that validate `X`\n   should set `reset=False`."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.base/BaseEstimator/_check_feature_names/reset",
          "name": "reset",
          "qname": "sklearn.base.BaseEstimator._check_feature_names.reset",
          "default_value": null,
          "assigned_by": "NAME_ONLY",
          "is_public": false,
          "docstring": {
            "type": "bool",
            "default_value": "",
            "description": "Whether to reset the `feature_names_in_` attribute.\nIf False, the input will be checked for consistency with\nfeature names of data provided when reset was last True.\n.. note::\n   It is recommended to call `reset=True` in `fit` and in the first\n   call to `partial_fit`. All other methods that validate `X`\n   should set `reset=False`."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "when reset was last True"
        },
        "hasAction": {
          "action": "provided"
        }
      }
    ]
  },
  "sklearn/sklearn.base/BaseEstimator/_validate_data": {
    "reset": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.base/BaseEstimator/_validate_data/reset",
          "name": "reset",
          "qname": "sklearn.base.BaseEstimator._validate_data.reset",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Whether to reset the `n_features_in_` attribute.\nIf False, the input will be checked for consistency with data\nprovided when reset was last True.\n.. note::\n   It is recommended to call reset=True in `fit` and in the first\n   call to `partial_fit`. All other methods that validate `X`\n   should set `reset=False`."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.base/BaseEstimator/_validate_data/reset",
          "name": "reset",
          "qname": "sklearn.base.BaseEstimator._validate_data.reset",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Whether to reset the `n_features_in_` attribute.\nIf False, the input will be checked for consistency with data\nprovided when reset was last True.\n.. note::\n   It is recommended to call reset=True in `fit` and in the first\n   call to `partial_fit`. All other methods that validate `X`\n   should set `reset=False`."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "when reset was last True"
        },
        "hasAction": {
          "action": "provided"
        }
      }
    ],
    "validate_separately": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.base/BaseEstimator/_validate_data/validate_separately",
          "name": "validate_separately",
          "qname": "sklearn.base.BaseEstimator._validate_data.validate_separately",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "False or tuple of dicts",
            "default_value": "False",
            "description": "Only used if y is not None.\nIf False, call validate_X_y(). Else, it must be a tuple of kwargs\nto be used for calling check_array() on X and y respectively.\n\n`estimator=self` is automatically added to these dicts to generate\nmore informative error message in case of invalid input data."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "False"
              },
              {
                "kind": "NamedType",
                "name": "tuple of dicts"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.base/BaseEstimator/_validate_data/y",
          "name": "y",
          "qname": "sklearn.base.BaseEstimator._validate_data.y",
          "default_value": "'no_validation'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "array-like of shape (n_samples,)",
            "default_value": "'no_validation'",
            "description": "The targets.\n\n- If `None`, `check_array` is called on `X`. If the estimator's\n  requires_y tag is True, then an error will be raised.\n- If `'no_validation'`, `check_array` is called on `X` and the\n  estimator's requires_y tag is ignored. This is a default\n  placeholder and is never meant to be explicitly set. In that case\n  `X` must be passed.\n- Otherwise, only `y` with `_check_y` or both `X` and `y` are\n  checked with either `check_array` or `check_X_y` depending on\n  `validate_separately`."
          },
          "type": {
            "kind": "NamedType",
            "name": "array-like of shape (n_samples,)"
          }
        },
        "hasCondition": {
          "condition": "if y is not None"
        },
        "hasAction": {
          "action": "Only used"
        }
      }
    ]
  },
  "sklearn/sklearn.base/BaseEstimator/_validate_params": {},
  "sklearn/sklearn.base/BaseEstimator/_repr_html_@getter": {},
  "sklearn/sklearn.base/BaseEstimator/_repr_html_inner": {},
  "sklearn/sklearn.base/BaseEstimator/_repr_mimebundle_": {},
  "sklearn/sklearn.base/ClassifierMixin/score": {},
  "sklearn/sklearn.base/ClassifierMixin/_more_tags": {},
  "sklearn/sklearn.base/RegressorMixin/score": {},
  "sklearn/sklearn.base/RegressorMixin/_more_tags": {},
  "sklearn/sklearn.base/ClusterMixin/fit_predict": {},
  "sklearn/sklearn.base/ClusterMixin/_more_tags": {},
  "sklearn/sklearn.base/BiclusterMixin/biclusters_@getter": {},
  "sklearn/sklearn.base/BiclusterMixin/get_indices": {},
  "sklearn/sklearn.base/BiclusterMixin/get_shape": {},
  "sklearn/sklearn.base/BiclusterMixin/get_submatrix": {},
  "sklearn/sklearn.base/TransformerMixin/fit_transform": {},
  "sklearn/sklearn.base/OneToOneFeatureMixin/get_feature_names_out": {
    "input_features": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.base/OneToOneFeatureMixin/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.base.OneToOneFeatureMixin.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features.\n\n- If `input_features` is `None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then the following input feature names are generated:\n  `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.base/OneToOneFeatureMixin/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.base.OneToOneFeatureMixin.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features.\n\n- If `input_features` is `None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then the following input feature names are generated:\n  `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If input_features is None , then feature_names_in _"
        },
        "hasAction": {
          "action": "is used as feature names in"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.base/OneToOneFeatureMixin/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.base.OneToOneFeatureMixin.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features.\n\n- If `input_features` is `None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then the following input feature names are generated:\n  `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.base/OneToOneFeatureMixin/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.base.OneToOneFeatureMixin.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features.\n\n- If `input_features` is `None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then the following input feature names are generated:\n  `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If input_features is"
        },
        "hasAction": {
          "action": "an array - like , then input_features must match feature_names_in _"
        }
      }
    ]
  },
  "sklearn/sklearn.base/ClassNamePrefixFeaturesOutMixin/get_feature_names_out": {},
  "sklearn/sklearn.base/DensityMixin/score": {},
  "sklearn/sklearn.base/OutlierMixin/fit_predict": {},
  "sklearn/sklearn.base/MultiOutputMixin/_more_tags": {},
  "sklearn/sklearn.base/_UnstableArchMixin/_more_tags": {},
  "sklearn/sklearn.base/is_classifier": {},
  "sklearn/sklearn.base/is_regressor": {},
  "sklearn/sklearn.base/is_outlier_detector": {},
  "sklearn/sklearn.calibration/CalibratedClassifierCV/__init__": {
    "n_jobs": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.calibration/CalibratedClassifierCV/__init__/n_jobs",
          "name": "n_jobs",
          "qname": "sklearn.calibration.CalibratedClassifierCV.__init__.n_jobs",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "None",
            "description": "Number of jobs to run in parallel.\n``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n``-1`` means using all processors.\n\nBase estimator clones are fitted in parallel across cross-validation\niterations. Therefore parallelism happens only when `cv != \"prefit\"`.\n\nSee :term:`Glossary <n_jobs>` for more details.\n\n.. versionadded:: 0.24"
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.calibration/CalibratedClassifierCV/__init__/cv",
          "name": "cv",
          "qname": "sklearn.calibration.CalibratedClassifierCV.__init__.cv",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, cross-validation generator, iterable or \"prefit\"",
            "default_value": "None",
            "description": "Determines the cross-validation splitting strategy.\nPossible inputs for cv are:\n\n- None, to use the default 5-fold cross-validation,\n- integer, to specify the number of folds.\n- :term:`CV splitter`,\n- An iterable yielding (train, test) splits as arrays of indices.\n\nFor integer/None inputs, if ``y`` is binary or multiclass,\n:class:`~sklearn.model_selection.StratifiedKFold` is used. If ``y`` is\nneither binary nor multiclass, :class:`~sklearn.model_selection.KFold`\nis used.\n\nRefer to the :ref:`User Guide <cross_validation>` for the various\ncross-validation strategies that can be used here.\n\nIf \"prefit\" is passed, it is assumed that `estimator` has been\nfitted already and all data is used for calibration.\n\n.. versionchanged:: 0.22\n    ``cv`` default value if None changed from 3-fold to 5-fold."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "cross-validation generator"
              },
              {
                "kind": "NamedType",
                "name": "iterable"
              },
              {
                "kind": "NamedType",
                "name": "\"prefit\""
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "only when cv does not equal prefit"
        },
        "hasAction": {
          "action": "Therefore parallelism happens"
        }
      }
    ],
    "ensemble": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.calibration/CalibratedClassifierCV/__init__/ensemble",
          "name": "ensemble",
          "qname": "sklearn.calibration.CalibratedClassifierCV.__init__.ensemble",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Determines how the calibrator is fitted when `cv` is not `'prefit'`.\nIgnored if `cv='prefit'`.\n\nIf `True`, the `estimator` is fitted using training data, and\ncalibrated using testing data, for each `cv` fold. The final estimator\nis an ensemble of `n_cv` fitted classifier and calibrator pairs, where\n`n_cv` is the number of cross-validation folds. The output is the\naverage predicted probabilities of all pairs.\n\nIf `False`, `cv` is used to compute unbiased predictions, via\n:func:`~sklearn.model_selection.cross_val_predict`, which are then\nused for calibration. At prediction time, the classifier used is the\n`estimator` trained on all the data.\nNote that this method is also internally implemented  in\n:mod:`sklearn.svm` estimators with the `probabilities=True` parameter.\n\n.. versionadded:: 0.24"
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.calibration/CalibratedClassifierCV/__init__/cv",
          "name": "cv",
          "qname": "sklearn.calibration.CalibratedClassifierCV.__init__.cv",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, cross-validation generator, iterable or \"prefit\"",
            "default_value": "None",
            "description": "Determines the cross-validation splitting strategy.\nPossible inputs for cv are:\n\n- None, to use the default 5-fold cross-validation,\n- integer, to specify the number of folds.\n- :term:`CV splitter`,\n- An iterable yielding (train, test) splits as arrays of indices.\n\nFor integer/None inputs, if ``y`` is binary or multiclass,\n:class:`~sklearn.model_selection.StratifiedKFold` is used. If ``y`` is\nneither binary nor multiclass, :class:`~sklearn.model_selection.KFold`\nis used.\n\nRefer to the :ref:`User Guide <cross_validation>` for the various\ncross-validation strategies that can be used here.\n\nIf \"prefit\" is passed, it is assumed that `estimator` has been\nfitted already and all data is used for calibration.\n\n.. versionchanged:: 0.22\n    ``cv`` default value if None changed from 3-fold to 5-fold."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "cross-validation generator"
              },
              {
                "kind": "NamedType",
                "name": "iterable"
              },
              {
                "kind": "NamedType",
                "name": "\"prefit\""
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "when cv is not prefit"
        },
        "hasAction": {
          "action": "how the calibrator is fitted"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.calibration/CalibratedClassifierCV/__init__/ensemble",
          "name": "ensemble",
          "qname": "sklearn.calibration.CalibratedClassifierCV.__init__.ensemble",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Determines how the calibrator is fitted when `cv` is not `'prefit'`.\nIgnored if `cv='prefit'`.\n\nIf `True`, the `estimator` is fitted using training data, and\ncalibrated using testing data, for each `cv` fold. The final estimator\nis an ensemble of `n_cv` fitted classifier and calibrator pairs, where\n`n_cv` is the number of cross-validation folds. The output is the\naverage predicted probabilities of all pairs.\n\nIf `False`, `cv` is used to compute unbiased predictions, via\n:func:`~sklearn.model_selection.cross_val_predict`, which are then\nused for calibration. At prediction time, the classifier used is the\n`estimator` trained on all the data.\nNote that this method is also internally implemented  in\n:mod:`sklearn.svm` estimators with the `probabilities=True` parameter.\n\n.. versionadded:: 0.24"
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.calibration/CalibratedClassifierCV/__init__/cv",
          "name": "cv",
          "qname": "sklearn.calibration.CalibratedClassifierCV.__init__.cv",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, cross-validation generator, iterable or \"prefit\"",
            "default_value": "None",
            "description": "Determines the cross-validation splitting strategy.\nPossible inputs for cv are:\n\n- None, to use the default 5-fold cross-validation,\n- integer, to specify the number of folds.\n- :term:`CV splitter`,\n- An iterable yielding (train, test) splits as arrays of indices.\n\nFor integer/None inputs, if ``y`` is binary or multiclass,\n:class:`~sklearn.model_selection.StratifiedKFold` is used. If ``y`` is\nneither binary nor multiclass, :class:`~sklearn.model_selection.KFold`\nis used.\n\nRefer to the :ref:`User Guide <cross_validation>` for the various\ncross-validation strategies that can be used here.\n\nIf \"prefit\" is passed, it is assumed that `estimator` has been\nfitted already and all data is used for calibration.\n\n.. versionchanged:: 0.22\n    ``cv`` default value if None changed from 3-fold to 5-fold."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "cross-validation generator"
              },
              {
                "kind": "NamedType",
                "name": "iterable"
              },
              {
                "kind": "NamedType",
                "name": "\"prefit\""
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "if cv equals prefit"
        },
        "hasAction": {
          "action": "Ignored"
        }
      }
    ]
  },
  "sklearn/sklearn.calibration/CalibratedClassifierCV/fit": {},
  "sklearn/sklearn.calibration/CalibratedClassifierCV/predict_proba": {},
  "sklearn/sklearn.calibration/CalibratedClassifierCV/predict": {},
  "sklearn/sklearn.calibration/CalibratedClassifierCV/_more_tags": {},
  "sklearn/sklearn.calibration/_fit_classifier_calibrator_pair": {},
  "sklearn/sklearn.calibration/_get_prediction_method": {},
  "sklearn/sklearn.calibration/_compute_predictions": {},
  "sklearn/sklearn.calibration/_fit_calibrator": {},
  "sklearn/sklearn.calibration/_CalibratedClassifier/__init__": {},
  "sklearn/sklearn.calibration/_CalibratedClassifier/predict_proba": {},
  "sklearn/sklearn.calibration/_sigmoid_calibration": {},
  "sklearn/sklearn.calibration/_SigmoidCalibration/fit": {},
  "sklearn/sklearn.calibration/_SigmoidCalibration/predict": {},
  "sklearn/sklearn.calibration/calibration_curve": {},
  "sklearn/sklearn.calibration/CalibrationDisplay/__init__": {},
  "sklearn/sklearn.calibration/CalibrationDisplay/plot": {},
  "sklearn/sklearn.calibration/CalibrationDisplay/from_estimator": {},
  "sklearn/sklearn.calibration/CalibrationDisplay/from_predictions": {},
  "sklearn/sklearn.conftest/global_dtype": {},
  "sklearn/sklearn.conftest/_fetch_fixture": {},
  "sklearn/sklearn.conftest/pytest_collection_modifyitems": {},
  "sklearn/sklearn.conftest/pyplot": {},
  "sklearn/sklearn.conftest/pytest_runtest_setup": {},
  "sklearn/sklearn.conftest/pytest_configure": {},
  "sklearn/sklearn.discriminant_analysis/_cov": {},
  "sklearn/sklearn.discriminant_analysis/_class_means": {},
  "sklearn/sklearn.discriminant_analysis/_class_cov": {
    "shrinkage": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.discriminant_analysis/_class_cov/shrinkage",
          "name": "shrinkage",
          "qname": "sklearn.discriminant_analysis._class_cov.shrinkage",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "'auto' or float",
            "default_value": "None",
            "description": "Shrinkage parameter, possible values:\n  - None: no shrinkage (default).\n  - 'auto': automatic shrinkage using the Ledoit-Wolf lemma.\n  - float between 0 and 1: fixed shrinkage parameter.\n\nShrinkage parameter is ignored if `covariance_estimator` is not None."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "'auto'"
              },
              {
                "kind": "NamedType",
                "name": "float"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.discriminant_analysis/_class_cov/covariance_estimator",
          "name": "covariance_estimator",
          "qname": "sklearn.discriminant_analysis._class_cov.covariance_estimator",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "estimator",
            "default_value": "None",
            "description": "If not None, `covariance_estimator` is used to estimate\nthe covariance matrices instead of relying the empirical\ncovariance estimator (with potential shrinkage).\nThe object should have a fit method and a ``covariance_`` attribute\nlike the estimators in sklearn.covariance.\nIf None, the shrinkage parameter drives the estimate.\n\n.. versionadded:: 0.24"
          },
          "type": {
            "kind": "NamedType",
            "name": "estimator"
          }
        },
        "hasCondition": {
          "condition": "if covariance_estimator is not None"
        },
        "hasAction": {
          "action": "Shrinkage parameter is ignored"
        }
      }
    ]
  },
  "sklearn/sklearn.discriminant_analysis/LinearDiscriminantAnalysis/__init__": {
    "shrinkage": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.discriminant_analysis/LinearDiscriminantAnalysis/__init__/shrinkage",
          "name": "shrinkage",
          "qname": "sklearn.discriminant_analysis.LinearDiscriminantAnalysis.__init__.shrinkage",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "'auto' or float",
            "default_value": "None",
            "description": "Shrinkage parameter, possible values:\n  - None: no shrinkage (default).\n  - 'auto': automatic shrinkage using the Ledoit-Wolf lemma.\n  - float between 0 and 1: fixed shrinkage parameter.\n\nThis should be left to None if `covariance_estimator` is used.\nNote that shrinkage works only with 'lsqr' and 'eigen' solvers."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "'auto'"
              },
              {
                "kind": "NamedType",
                "name": "float"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.discriminant_analysis/LinearDiscriminantAnalysis/__init__/covariance_estimator",
          "name": "covariance_estimator",
          "qname": "sklearn.discriminant_analysis.LinearDiscriminantAnalysis.__init__.covariance_estimator",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "covariance estimator",
            "default_value": "None",
            "description": "If not None, `covariance_estimator` is used to estimate\nthe covariance matrices instead of relying on the empirical\ncovariance estimator (with potential shrinkage).\nThe object should have a fit method and a ``covariance_`` attribute\nlike the estimators in :mod:`sklearn.covariance`.\nif None the shrinkage parameter drives the estimate.\n\nThis should be left to None if `shrinkage` is used.\nNote that `covariance_estimator` works only with 'lsqr' and 'eigen'\nsolvers.\n\n.. versionadded:: 0.24"
          },
          "type": {
            "kind": "NamedType",
            "name": "covariance estimator"
          }
        },
        "hasCondition": {
          "condition": "if covariance_estimator is used"
        },
        "hasAction": {
          "action": "This should be left to None"
        }
      }
    ],
    "covariance_estimator": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.discriminant_analysis/LinearDiscriminantAnalysis/__init__/covariance_estimator",
          "name": "covariance_estimator",
          "qname": "sklearn.discriminant_analysis.LinearDiscriminantAnalysis.__init__.covariance_estimator",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "covariance estimator",
            "default_value": "None",
            "description": "If not None, `covariance_estimator` is used to estimate\nthe covariance matrices instead of relying on the empirical\ncovariance estimator (with potential shrinkage).\nThe object should have a fit method and a ``covariance_`` attribute\nlike the estimators in :mod:`sklearn.covariance`.\nif None the shrinkage parameter drives the estimate.\n\nThis should be left to None if `shrinkage` is used.\nNote that `covariance_estimator` works only with 'lsqr' and 'eigen'\nsolvers.\n\n.. versionadded:: 0.24"
          },
          "type": {
            "kind": "NamedType",
            "name": "covariance estimator"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.discriminant_analysis/LinearDiscriminantAnalysis/__init__/shrinkage",
          "name": "shrinkage",
          "qname": "sklearn.discriminant_analysis.LinearDiscriminantAnalysis.__init__.shrinkage",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "'auto' or float",
            "default_value": "None",
            "description": "Shrinkage parameter, possible values:\n  - None: no shrinkage (default).\n  - 'auto': automatic shrinkage using the Ledoit-Wolf lemma.\n  - float between 0 and 1: fixed shrinkage parameter.\n\nThis should be left to None if `covariance_estimator` is used.\nNote that shrinkage works only with 'lsqr' and 'eigen' solvers."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "'auto'"
              },
              {
                "kind": "NamedType",
                "name": "float"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "if shrinkage is used"
        },
        "hasAction": {
          "action": "This should be left to None"
        }
      }
    ]
  },
  "sklearn/sklearn.discriminant_analysis/LinearDiscriminantAnalysis/_solve_lstsq": {},
  "sklearn/sklearn.discriminant_analysis/LinearDiscriminantAnalysis/_solve_eigen": {},
  "sklearn/sklearn.discriminant_analysis/LinearDiscriminantAnalysis/_solve_svd": {},
  "sklearn/sklearn.discriminant_analysis/LinearDiscriminantAnalysis/fit": {},
  "sklearn/sklearn.discriminant_analysis/LinearDiscriminantAnalysis/transform": {},
  "sklearn/sklearn.discriminant_analysis/LinearDiscriminantAnalysis/predict_proba": {},
  "sklearn/sklearn.discriminant_analysis/LinearDiscriminantAnalysis/predict_log_proba": {},
  "sklearn/sklearn.discriminant_analysis/LinearDiscriminantAnalysis/decision_function": {},
  "sklearn/sklearn.discriminant_analysis/QuadraticDiscriminantAnalysis/__init__": {},
  "sklearn/sklearn.discriminant_analysis/QuadraticDiscriminantAnalysis/fit": {},
  "sklearn/sklearn.discriminant_analysis/QuadraticDiscriminantAnalysis/_decision_function": {},
  "sklearn/sklearn.discriminant_analysis/QuadraticDiscriminantAnalysis/decision_function": {},
  "sklearn/sklearn.discriminant_analysis/QuadraticDiscriminantAnalysis/predict": {},
  "sklearn/sklearn.discriminant_analysis/QuadraticDiscriminantAnalysis/predict_proba": {},
  "sklearn/sklearn.discriminant_analysis/QuadraticDiscriminantAnalysis/predict_log_proba": {},
  "sklearn/sklearn.dummy/DummyClassifier/__init__": {
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.dummy/DummyClassifier/__init__/random_state",
          "name": "random_state",
          "qname": "sklearn.dummy.DummyClassifier.__init__.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance or None",
            "default_value": "None",
            "description": "Controls the randomness to generate the predictions when\n``strategy='stratified'`` or ``strategy='uniform'``.\nPass an int for reproducible output across multiple function calls.\nSee :term:`Glossary <random_state>`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.dummy/DummyClassifier/__init__/strategy",
          "name": "strategy",
          "qname": "sklearn.dummy.DummyClassifier.__init__.strategy",
          "default_value": "'prior'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{\"most_frequent\", \"prior\", \"stratified\", \"uniform\",             \"constant\"}",
            "default_value": "\"prior\"",
            "description": "Strategy to use to generate predictions.\n\n* \"most_frequent\": the `predict` method always returns the most\n  frequent class label in the observed `y` argument passed to `fit`.\n  The `predict_proba` method returns the matching one-hot encoded\n  vector.\n* \"prior\": the `predict` method always returns the most frequent\n  class label in the observed `y` argument passed to `fit` (like\n  \"most_frequent\"). ``predict_proba`` always returns the empirical\n  class distribution of `y` also known as the empirical class prior\n  distribution.\n* \"stratified\": the `predict_proba` method randomly samples one-hot\n  vectors from a multinomial distribution parametrized by the empirical\n  class prior probabilities.\n  The `predict` method returns the class label which got probability\n  one in the one-hot vector of `predict_proba`.\n  Each sampled row of both methods is therefore independent and\n  identically distributed.\n* \"uniform\": generates predictions uniformly at random from the list\n  of unique classes observed in `y`, i.e. each class has equal\n  probability.\n* \"constant\": always predicts a constant label that is provided by\n  the user. This is useful for metrics that evaluate a non-majority\n  class.\n\n  .. versionchanged:: 0.24\n     The default value of `strategy` has changed to \"prior\" in version\n     0.24."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "uniform",
              "prior",
              "stratified",
              "constant",
              "most_frequent"
            ]
          }
        },
        "hasCondition": {
          "condition": "when strategy equals stratified or strategy equals uniform"
        },
        "hasAction": {
          "action": "Controls the randomness to generate the predictions"
        }
      }
    ]
  },
  "sklearn/sklearn.dummy/DummyClassifier/fit": {},
  "sklearn/sklearn.dummy/DummyClassifier/predict": {},
  "sklearn/sklearn.dummy/DummyClassifier/predict_proba": {},
  "sklearn/sklearn.dummy/DummyClassifier/predict_log_proba": {},
  "sklearn/sklearn.dummy/DummyClassifier/_more_tags": {},
  "sklearn/sklearn.dummy/DummyClassifier/score": {},
  "sklearn/sklearn.dummy/DummyRegressor/__init__": {},
  "sklearn/sklearn.dummy/DummyRegressor/fit": {},
  "sklearn/sklearn.dummy/DummyRegressor/predict": {},
  "sklearn/sklearn.dummy/DummyRegressor/_more_tags": {},
  "sklearn/sklearn.dummy/DummyRegressor/score": {},
  "sklearn/sklearn.isotonic/check_increasing": {},
  "sklearn/sklearn.isotonic/isotonic_regression": {},
  "sklearn/sklearn.isotonic/IsotonicRegression/__init__": {},
  "sklearn/sklearn.isotonic/IsotonicRegression/_check_input_data_shape": {},
  "sklearn/sklearn.isotonic/IsotonicRegression/_build_f": {},
  "sklearn/sklearn.isotonic/IsotonicRegression/_build_y": {},
  "sklearn/sklearn.isotonic/IsotonicRegression/fit": {},
  "sklearn/sklearn.isotonic/IsotonicRegression/transform": {},
  "sklearn/sklearn.isotonic/IsotonicRegression/predict": {},
  "sklearn/sklearn.isotonic/IsotonicRegression/get_feature_names_out": {},
  "sklearn/sklearn.isotonic/IsotonicRegression/__getstate__": {},
  "sklearn/sklearn.isotonic/IsotonicRegression/__setstate__": {},
  "sklearn/sklearn.isotonic/IsotonicRegression/_more_tags": {},
  "sklearn/sklearn.kernel_approximation/PolynomialCountSketch/__init__": {},
  "sklearn/sklearn.kernel_approximation/PolynomialCountSketch/fit": {},
  "sklearn/sklearn.kernel_approximation/PolynomialCountSketch/transform": {},
  "sklearn/sklearn.kernel_approximation/RBFSampler/__init__": {
    "gamma": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.kernel_approximation/RBFSampler/__init__/gamma",
          "name": "gamma",
          "qname": "sklearn.kernel_approximation.RBFSampler.__init__.gamma",
          "default_value": "1.0",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "'scale' or float",
            "default_value": "1.0",
            "description": "Parameter of RBF kernel: exp(-gamma * x^2).\nIf ``gamma='scale'`` is passed then it uses\n1 / (n_features * X.var()) as value of gamma.\n\n.. versionadded:: 1.2\n   The option `\"scale\"` was added in 1.2."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "'scale'"
              },
              {
                "kind": "NamedType",
                "name": "float"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.kernel_approximation/RBFSampler/__init__/gamma",
          "name": "gamma",
          "qname": "sklearn.kernel_approximation.RBFSampler.__init__.gamma",
          "default_value": "1.0",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "'scale' or float",
            "default_value": "1.0",
            "description": "Parameter of RBF kernel: exp(-gamma * x^2).\nIf ``gamma='scale'`` is passed then it uses\n1 / (n_features * X.var()) as value of gamma.\n\n.. versionadded:: 1.2\n   The option `\"scale\"` was added in 1.2."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "'scale'"
              },
              {
                "kind": "NamedType",
                "name": "float"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If gamma equals scale"
        },
        "hasAction": {
          "action": "is passed then"
        }
      }
    ]
  },
  "sklearn/sklearn.kernel_approximation/RBFSampler/fit": {},
  "sklearn/sklearn.kernel_approximation/RBFSampler/transform": {},
  "sklearn/sklearn.kernel_approximation/RBFSampler/_more_tags": {},
  "sklearn/sklearn.kernel_approximation/SkewedChi2Sampler/__init__": {},
  "sklearn/sklearn.kernel_approximation/SkewedChi2Sampler/fit": {},
  "sklearn/sklearn.kernel_approximation/SkewedChi2Sampler/transform": {},
  "sklearn/sklearn.kernel_approximation/SkewedChi2Sampler/_more_tags": {},
  "sklearn/sklearn.kernel_approximation/AdditiveChi2Sampler/__init__": {
    "sample_interval": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.kernel_approximation/AdditiveChi2Sampler/__init__/sample_interval",
          "name": "sample_interval",
          "qname": "sklearn.kernel_approximation.AdditiveChi2Sampler.__init__.sample_interval",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "None",
            "description": "Sampling interval. Must be specified when sample_steps not in {1,2,3}."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.kernel_approximation/AdditiveChi2Sampler/__init__/sample_steps",
          "name": "sample_steps",
          "qname": "sklearn.kernel_approximation.AdditiveChi2Sampler.__init__.sample_steps",
          "default_value": "2",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "2",
            "description": "Gives the number of (complex) sampling points."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "hasCondition": {
          "condition": "when sample_steps not in { 1,2,3 }"
        },
        "hasAction": {
          "action": "Must be specified"
        }
      }
    ]
  },
  "sklearn/sklearn.kernel_approximation/AdditiveChi2Sampler/fit": {},
  "sklearn/sklearn.kernel_approximation/AdditiveChi2Sampler/transform": {},
  "sklearn/sklearn.kernel_approximation/AdditiveChi2Sampler/get_feature_names_out": {},
  "sklearn/sklearn.kernel_approximation/AdditiveChi2Sampler/_transform_dense": {},
  "sklearn/sklearn.kernel_approximation/AdditiveChi2Sampler/_transform_sparse": {},
  "sklearn/sklearn.kernel_approximation/AdditiveChi2Sampler/_more_tags": {},
  "sklearn/sklearn.kernel_approximation/Nystroem/__init__": {},
  "sklearn/sklearn.kernel_approximation/Nystroem/fit": {},
  "sklearn/sklearn.kernel_approximation/Nystroem/transform": {},
  "sklearn/sklearn.kernel_approximation/Nystroem/_get_kernel_params": {},
  "sklearn/sklearn.kernel_approximation/Nystroem/_more_tags": {},
  "sklearn/sklearn.kernel_ridge/KernelRidge/__init__": {
    "kernel": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.kernel_ridge/KernelRidge/__init__/kernel",
          "name": "kernel",
          "qname": "sklearn.kernel_ridge.KernelRidge.__init__.kernel",
          "default_value": "'linear'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "\"linear\"",
            "description": "Kernel mapping used internally. This parameter is directly passed to\n:class:`~sklearn.metrics.pairwise.pairwise_kernel`.\nIf `kernel` is a string, it must be one of the metrics\nin `pairwise.PAIRWISE_KERNEL_FUNCTIONS` or \"precomputed\".\nIf `kernel` is \"precomputed\", X is assumed to be a kernel matrix.\nAlternatively, if `kernel` is a callable function, it is called on\neach pair of instances (rows) and the resulting value recorded. The\ncallable should take two rows from X as input and return the\ncorresponding kernel value as a single number. This means that\ncallables from :mod:`sklearn.metrics.pairwise` are not allowed, as\nthey operate on matrices, not single samples. Use the string\nidentifying the kernel instead."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.kernel_ridge/KernelRidge/__init__/kernel",
          "name": "kernel",
          "qname": "sklearn.kernel_ridge.KernelRidge.__init__.kernel",
          "default_value": "'linear'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "\"linear\"",
            "description": "Kernel mapping used internally. This parameter is directly passed to\n:class:`~sklearn.metrics.pairwise.pairwise_kernel`.\nIf `kernel` is a string, it must be one of the metrics\nin `pairwise.PAIRWISE_KERNEL_FUNCTIONS` or \"precomputed\".\nIf `kernel` is \"precomputed\", X is assumed to be a kernel matrix.\nAlternatively, if `kernel` is a callable function, it is called on\neach pair of instances (rows) and the resulting value recorded. The\ncallable should take two rows from X as input and return the\ncorresponding kernel value as a single number. This means that\ncallables from :mod:`sklearn.metrics.pairwise` are not allowed, as\nthey operate on matrices, not single samples. Use the string\nidentifying the kernel instead."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If kernel is precomputed"
        },
        "hasAction": {
          "action": ", X is assumed to be a kernel matrix"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.kernel_ridge/KernelRidge/__init__/kernel",
          "name": "kernel",
          "qname": "sklearn.kernel_ridge.KernelRidge.__init__.kernel",
          "default_value": "'linear'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "\"linear\"",
            "description": "Kernel mapping used internally. This parameter is directly passed to\n:class:`~sklearn.metrics.pairwise.pairwise_kernel`.\nIf `kernel` is a string, it must be one of the metrics\nin `pairwise.PAIRWISE_KERNEL_FUNCTIONS` or \"precomputed\".\nIf `kernel` is \"precomputed\", X is assumed to be a kernel matrix.\nAlternatively, if `kernel` is a callable function, it is called on\neach pair of instances (rows) and the resulting value recorded. The\ncallable should take two rows from X as input and return the\ncorresponding kernel value as a single number. This means that\ncallables from :mod:`sklearn.metrics.pairwise` are not allowed, as\nthey operate on matrices, not single samples. Use the string\nidentifying the kernel instead."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.kernel_ridge/KernelRidge/__init__/kernel",
          "name": "kernel",
          "qname": "sklearn.kernel_ridge.KernelRidge.__init__.kernel",
          "default_value": "'linear'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "\"linear\"",
            "description": "Kernel mapping used internally. This parameter is directly passed to\n:class:`~sklearn.metrics.pairwise.pairwise_kernel`.\nIf `kernel` is a string, it must be one of the metrics\nin `pairwise.PAIRWISE_KERNEL_FUNCTIONS` or \"precomputed\".\nIf `kernel` is \"precomputed\", X is assumed to be a kernel matrix.\nAlternatively, if `kernel` is a callable function, it is called on\neach pair of instances (rows) and the resulting value recorded. The\ncallable should take two rows from X as input and return the\ncorresponding kernel value as a single number. This means that\ncallables from :mod:`sklearn.metrics.pairwise` are not allowed, as\nthey operate on matrices, not single samples. Use the string\nidentifying the kernel instead."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "if kernel is a callable function"
        },
        "hasAction": {
          "action": "Alternatively , , it is called on each pair of instances ( rows ) and the resulting value recorded"
        }
      }
    ]
  },
  "sklearn/sklearn.kernel_ridge/KernelRidge/_get_kernel": {},
  "sklearn/sklearn.kernel_ridge/KernelRidge/_more_tags": {},
  "sklearn/sklearn.kernel_ridge/KernelRidge/fit": {},
  "sklearn/sklearn.kernel_ridge/KernelRidge/predict": {},
  "sklearn/sklearn.multiclass/_fit_binary": {},
  "sklearn/sklearn.multiclass/_partial_fit_binary": {},
  "sklearn/sklearn.multiclass/_predict_binary": {},
  "sklearn/sklearn.multiclass/_threshold_for_binary_predict": {},
  "sklearn/sklearn.multiclass/_ConstantPredictor/fit": {},
  "sklearn/sklearn.multiclass/_ConstantPredictor/predict": {},
  "sklearn/sklearn.multiclass/_ConstantPredictor/decision_function": {},
  "sklearn/sklearn.multiclass/_ConstantPredictor/predict_proba": {},
  "sklearn/sklearn.multiclass/_estimators_has": {},
  "sklearn/sklearn.multiclass/OneVsRestClassifier/__init__": {},
  "sklearn/sklearn.multiclass/OneVsRestClassifier/fit": {},
  "sklearn/sklearn.multiclass/OneVsRestClassifier/partial_fit": {},
  "sklearn/sklearn.multiclass/OneVsRestClassifier/predict": {},
  "sklearn/sklearn.multiclass/OneVsRestClassifier/predict_proba": {},
  "sklearn/sklearn.multiclass/OneVsRestClassifier/decision_function": {},
  "sklearn/sklearn.multiclass/OneVsRestClassifier/multilabel_@getter": {},
  "sklearn/sklearn.multiclass/OneVsRestClassifier/n_classes_@getter": {},
  "sklearn/sklearn.multiclass/OneVsRestClassifier/_more_tags": {},
  "sklearn/sklearn.multiclass/_fit_ovo_binary": {},
  "sklearn/sklearn.multiclass/_partial_fit_ovo_binary": {},
  "sklearn/sklearn.multiclass/OneVsOneClassifier/__init__": {},
  "sklearn/sklearn.multiclass/OneVsOneClassifier/fit": {},
  "sklearn/sklearn.multiclass/OneVsOneClassifier/partial_fit": {},
  "sklearn/sklearn.multiclass/OneVsOneClassifier/predict": {},
  "sklearn/sklearn.multiclass/OneVsOneClassifier/decision_function": {},
  "sklearn/sklearn.multiclass/OneVsOneClassifier/n_classes_@getter": {},
  "sklearn/sklearn.multiclass/OneVsOneClassifier/_more_tags": {},
  "sklearn/sklearn.multiclass/OutputCodeClassifier/__init__": {},
  "sklearn/sklearn.multiclass/OutputCodeClassifier/fit": {},
  "sklearn/sklearn.multiclass/OutputCodeClassifier/predict": {},
  "sklearn/sklearn.multioutput/_fit_estimator": {},
  "sklearn/sklearn.multioutput/_partial_fit_estimator": {},
  "sklearn/sklearn.multioutput/_available_if_estimator_has": {},
  "sklearn/sklearn.multioutput/_MultiOutputEstimator/__init__": {},
  "sklearn/sklearn.multioutput/_MultiOutputEstimator/partial_fit": {
    "classes": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.multioutput/_MultiOutputEstimator/partial_fit/classes",
          "name": "classes",
          "qname": "sklearn.multioutput._MultiOutputEstimator.partial_fit.classes",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "list of ndarray of shape (n_outputs,)",
            "default_value": "None",
            "description": "Each array is unique classes for one output in str/int.\nCan be obtained via\n``[np.unique(y[:, i]) for i in range(y.shape[1])]``, where `y`\nis the target matrix of the entire dataset.\nThis argument is required for the first call to partial_fit\nand can be omitted in the subsequent calls.\nNote that `y` doesn't need to contain all labels in `classes`."
          },
          "type": {
            "kind": "NamedType",
            "name": "list of ndarray of shape (n_outputs,)"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.multioutput/_MultiOutputEstimator/partial_fit/y",
          "name": "y",
          "qname": "sklearn.multioutput._MultiOutputEstimator.partial_fit.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "{array-like, sparse matrix} of shape (n_samples, n_outputs)",
            "default_value": "",
            "description": "Multi-output targets."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "EnumType",
                "values": []
              },
              {
                "kind": "NamedType",
                "name": "of shape (n_samples, n_outputs)"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "where y is the target matrix of the entire dataset"
        },
        "hasAction": {
          "action": "Can be obtained via [ np.unique(y [: , i ] ) for i in range(y.shape[1 ] ) ] ,"
        }
      }
    ]
  },
  "sklearn/sklearn.multioutput/_MultiOutputEstimator/fit": {},
  "sklearn/sklearn.multioutput/_MultiOutputEstimator/predict": {},
  "sklearn/sklearn.multioutput/_MultiOutputEstimator/_more_tags": {},
  "sklearn/sklearn.multioutput/MultiOutputRegressor/__init__": {},
  "sklearn/sklearn.multioutput/MultiOutputRegressor/partial_fit": {},
  "sklearn/sklearn.multioutput/MultiOutputClassifier/__init__": {
    "estimator": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.multioutput/MultiOutputClassifier/__init__/estimator",
          "name": "estimator",
          "qname": "sklearn.multioutput.MultiOutputClassifier.__init__.estimator",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "estimator object",
            "default_value": "",
            "description": "An estimator object implementing :term:`fit` and :term:`predict`.\nA :term:`predict_proba` method will be exposed only if `estimator` implements\nit."
          },
          "type": {
            "kind": "NamedType",
            "name": "estimator object"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.multioutput/MultiOutputClassifier/__init__/estimator",
          "name": "estimator",
          "qname": "sklearn.multioutput.MultiOutputClassifier.__init__.estimator",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "estimator object",
            "default_value": "",
            "description": "An estimator object implementing :term:`fit` and :term:`predict`.\nA :term:`predict_proba` method will be exposed only if `estimator` implements\nit."
          },
          "type": {
            "kind": "NamedType",
            "name": "estimator object"
          }
        },
        "hasCondition": {
          "condition": "only if estimator implements it"
        },
        "hasAction": {
          "action": "A : term : predict_proba method will be exposed"
        }
      }
    ]
  },
  "sklearn/sklearn.multioutput/MultiOutputClassifier/fit": {},
  "sklearn/sklearn.multioutput/MultiOutputClassifier/_check_predict_proba": {},
  "sklearn/sklearn.multioutput/MultiOutputClassifier/predict_proba": {},
  "sklearn/sklearn.multioutput/MultiOutputClassifier/score": {},
  "sklearn/sklearn.multioutput/MultiOutputClassifier/_more_tags": {},
  "sklearn/sklearn.multioutput/_available_if_base_estimator_has": {},
  "sklearn/sklearn.multioutput/_BaseChain/__init__": {},
  "sklearn/sklearn.multioutput/_BaseChain/_log_message": {},
  "sklearn/sklearn.multioutput/_BaseChain/fit": {},
  "sklearn/sklearn.multioutput/_BaseChain/predict": {},
  "sklearn/sklearn.multioutput/ClassifierChain/fit": {},
  "sklearn/sklearn.multioutput/ClassifierChain/predict_proba": {},
  "sklearn/sklearn.multioutput/ClassifierChain/decision_function": {},
  "sklearn/sklearn.multioutput/ClassifierChain/_more_tags": {},
  "sklearn/sklearn.multioutput/RegressorChain/fit": {},
  "sklearn/sklearn.multioutput/RegressorChain/_more_tags": {},
  "sklearn/sklearn.naive_bayes/_BaseNB/_joint_log_likelihood": {},
  "sklearn/sklearn.naive_bayes/_BaseNB/_check_X": {},
  "sklearn/sklearn.naive_bayes/_BaseNB/predict_joint_log_proba": {},
  "sklearn/sklearn.naive_bayes/_BaseNB/predict": {},
  "sklearn/sklearn.naive_bayes/_BaseNB/predict_log_proba": {},
  "sklearn/sklearn.naive_bayes/_BaseNB/predict_proba": {},
  "sklearn/sklearn.naive_bayes/GaussianNB/__init__": {},
  "sklearn/sklearn.naive_bayes/GaussianNB/fit": {},
  "sklearn/sklearn.naive_bayes/GaussianNB/_check_X": {},
  "sklearn/sklearn.naive_bayes/GaussianNB/_update_mean_variance": {},
  "sklearn/sklearn.naive_bayes/GaussianNB/partial_fit": {},
  "sklearn/sklearn.naive_bayes/GaussianNB/_partial_fit": {},
  "sklearn/sklearn.naive_bayes/GaussianNB/_joint_log_likelihood": {},
  "sklearn/sklearn.naive_bayes/_BaseDiscreteNB/__init__": {},
  "sklearn/sklearn.naive_bayes/_BaseDiscreteNB/_count": {},
  "sklearn/sklearn.naive_bayes/_BaseDiscreteNB/_update_feature_log_prob": {},
  "sklearn/sklearn.naive_bayes/_BaseDiscreteNB/_check_X": {},
  "sklearn/sklearn.naive_bayes/_BaseDiscreteNB/_check_X_y": {},
  "sklearn/sklearn.naive_bayes/_BaseDiscreteNB/_update_class_log_prior": {},
  "sklearn/sklearn.naive_bayes/_BaseDiscreteNB/_check_alpha": {},
  "sklearn/sklearn.naive_bayes/_BaseDiscreteNB/partial_fit": {},
  "sklearn/sklearn.naive_bayes/_BaseDiscreteNB/fit": {},
  "sklearn/sklearn.naive_bayes/_BaseDiscreteNB/_init_counters": {},
  "sklearn/sklearn.naive_bayes/_BaseDiscreteNB/_more_tags": {},
  "sklearn/sklearn.naive_bayes/MultinomialNB/__init__": {
    "force_alpha": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.naive_bayes/MultinomialNB/__init__/force_alpha",
          "name": "force_alpha",
          "qname": "sklearn.naive_bayes.MultinomialNB.__init__.force_alpha",
          "default_value": "'warn'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "If False and alpha is less than 1e-10, it will set alpha to\n1e-10. If True, alpha will remain unchanged. This may cause\nnumerical errors if alpha is too close to 0.\n\n.. versionadded:: 1.2\n.. deprecated:: 1.2\n   The default value of `force_alpha` will change to `True` in v1.4."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.naive_bayes/MultinomialNB/__init__/alpha",
          "name": "alpha",
          "qname": "sklearn.naive_bayes.MultinomialNB.__init__.alpha",
          "default_value": "1.0",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float or array-like of shape (n_features,)",
            "default_value": "1.0",
            "description": "Additive (Laplace/Lidstone) smoothing parameter\n(set alpha=0 and force_alpha=True, for no smoothing)."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "float"
              },
              {
                "kind": "NamedType",
                "name": "array-like of shape (n_features,)"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "if alpha is too close to 0"
        },
        "hasAction": {
          "action": "This may cause numerical errors . .."
        }
      }
    ]
  },
  "sklearn/sklearn.naive_bayes/MultinomialNB/_more_tags": {},
  "sklearn/sklearn.naive_bayes/MultinomialNB/_count": {},
  "sklearn/sklearn.naive_bayes/MultinomialNB/_update_feature_log_prob": {},
  "sklearn/sklearn.naive_bayes/MultinomialNB/_joint_log_likelihood": {},
  "sklearn/sklearn.naive_bayes/ComplementNB/__init__": {
    "force_alpha": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.naive_bayes/ComplementNB/__init__/force_alpha",
          "name": "force_alpha",
          "qname": "sklearn.naive_bayes.ComplementNB.__init__.force_alpha",
          "default_value": "'warn'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "If False and alpha is less than 1e-10, it will set alpha to\n1e-10. If True, alpha will remain unchanged. This may cause\nnumerical errors if alpha is too close to 0.\n\n.. versionadded:: 1.2\n.. deprecated:: 1.2\n   The default value of `force_alpha` will change to `True` in v1.4."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.naive_bayes/ComplementNB/__init__/alpha",
          "name": "alpha",
          "qname": "sklearn.naive_bayes.ComplementNB.__init__.alpha",
          "default_value": "1.0",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float or array-like of shape (n_features,)",
            "default_value": "1.0",
            "description": "Additive (Laplace/Lidstone) smoothing parameter\n(set alpha=0 and force_alpha=True, for no smoothing)."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "float"
              },
              {
                "kind": "NamedType",
                "name": "array-like of shape (n_features,)"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "if alpha is too close to 0"
        },
        "hasAction": {
          "action": "This may cause numerical errors . .."
        }
      }
    ]
  },
  "sklearn/sklearn.naive_bayes/ComplementNB/_more_tags": {},
  "sklearn/sklearn.naive_bayes/ComplementNB/_count": {},
  "sklearn/sklearn.naive_bayes/ComplementNB/_update_feature_log_prob": {},
  "sklearn/sklearn.naive_bayes/ComplementNB/_joint_log_likelihood": {},
  "sklearn/sklearn.naive_bayes/BernoulliNB/__init__": {
    "force_alpha": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.naive_bayes/BernoulliNB/__init__/force_alpha",
          "name": "force_alpha",
          "qname": "sklearn.naive_bayes.BernoulliNB.__init__.force_alpha",
          "default_value": "'warn'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "If False and alpha is less than 1e-10, it will set alpha to\n1e-10. If True, alpha will remain unchanged. This may cause\nnumerical errors if alpha is too close to 0.\n\n.. versionadded:: 1.2\n.. deprecated:: 1.2\n   The default value of `force_alpha` will change to `True` in v1.4."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.naive_bayes/BernoulliNB/__init__/alpha",
          "name": "alpha",
          "qname": "sklearn.naive_bayes.BernoulliNB.__init__.alpha",
          "default_value": "1.0",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float or array-like of shape (n_features,)",
            "default_value": "1.0",
            "description": "Additive (Laplace/Lidstone) smoothing parameter\n(set alpha=0 and force_alpha=True, for no smoothing)."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "float"
              },
              {
                "kind": "NamedType",
                "name": "array-like of shape (n_features,)"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "if alpha is too close to 0"
        },
        "hasAction": {
          "action": "This may cause numerical errors . .."
        }
      }
    ]
  },
  "sklearn/sklearn.naive_bayes/BernoulliNB/_check_X": {},
  "sklearn/sklearn.naive_bayes/BernoulliNB/_check_X_y": {},
  "sklearn/sklearn.naive_bayes/BernoulliNB/_count": {},
  "sklearn/sklearn.naive_bayes/BernoulliNB/_update_feature_log_prob": {},
  "sklearn/sklearn.naive_bayes/BernoulliNB/_joint_log_likelihood": {},
  "sklearn/sklearn.naive_bayes/CategoricalNB/__init__": {
    "force_alpha": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.naive_bayes/CategoricalNB/__init__/force_alpha",
          "name": "force_alpha",
          "qname": "sklearn.naive_bayes.CategoricalNB.__init__.force_alpha",
          "default_value": "'warn'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "If False and alpha is less than 1e-10, it will set alpha to\n1e-10. If True, alpha will remain unchanged. This may cause\nnumerical errors if alpha is too close to 0.\n\n.. versionadded:: 1.2\n.. deprecated:: 1.2\n   The default value of `force_alpha` will change to `True` in v1.4."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.naive_bayes/CategoricalNB/__init__/alpha",
          "name": "alpha",
          "qname": "sklearn.naive_bayes.CategoricalNB.__init__.alpha",
          "default_value": "1.0",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "1.0",
            "description": "Additive (Laplace/Lidstone) smoothing parameter\n(set alpha=0 and force_alpha=True, for no smoothing)."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "hasCondition": {
          "condition": "if alpha is too close to 0"
        },
        "hasAction": {
          "action": "This may cause numerical errors . .."
        }
      }
    ]
  },
  "sklearn/sklearn.naive_bayes/CategoricalNB/fit": {},
  "sklearn/sklearn.naive_bayes/CategoricalNB/partial_fit": {},
  "sklearn/sklearn.naive_bayes/CategoricalNB/_more_tags": {},
  "sklearn/sklearn.naive_bayes/CategoricalNB/_check_X": {},
  "sklearn/sklearn.naive_bayes/CategoricalNB/_check_X_y": {},
  "sklearn/sklearn.naive_bayes/CategoricalNB/_init_counters": {},
  "sklearn/sklearn.naive_bayes/CategoricalNB/_validate_n_categories": {},
  "sklearn/sklearn.naive_bayes/CategoricalNB/_count": {},
  "sklearn/sklearn.naive_bayes/CategoricalNB/_update_feature_log_prob": {},
  "sklearn/sklearn.naive_bayes/CategoricalNB/_joint_log_likelihood": {},
  "sklearn/sklearn.pipeline/_final_estimator_has": {},
  "sklearn/sklearn.pipeline/Pipeline/__init__": {},
  "sklearn/sklearn.pipeline/Pipeline/set_output": {},
  "sklearn/sklearn.pipeline/Pipeline/get_params": {},
  "sklearn/sklearn.pipeline/Pipeline/set_params": {},
  "sklearn/sklearn.pipeline/Pipeline/_validate_steps": {},
  "sklearn/sklearn.pipeline/Pipeline/_iter": {},
  "sklearn/sklearn.pipeline/Pipeline/__len__": {},
  "sklearn/sklearn.pipeline/Pipeline/__getitem__": {},
  "sklearn/sklearn.pipeline/Pipeline/_estimator_type@getter": {},
  "sklearn/sklearn.pipeline/Pipeline/named_steps@getter": {},
  "sklearn/sklearn.pipeline/Pipeline/_final_estimator@getter": {},
  "sklearn/sklearn.pipeline/Pipeline/_log_message": {},
  "sklearn/sklearn.pipeline/Pipeline/_check_fit_params": {},
  "sklearn/sklearn.pipeline/Pipeline/_fit": {},
  "sklearn/sklearn.pipeline/Pipeline/fit": {},
  "sklearn/sklearn.pipeline/Pipeline/fit_transform": {},
  "sklearn/sklearn.pipeline/Pipeline/predict": {},
  "sklearn/sklearn.pipeline/Pipeline/fit_predict": {},
  "sklearn/sklearn.pipeline/Pipeline/predict_proba": {},
  "sklearn/sklearn.pipeline/Pipeline/decision_function": {},
  "sklearn/sklearn.pipeline/Pipeline/score_samples": {},
  "sklearn/sklearn.pipeline/Pipeline/predict_log_proba": {},
  "sklearn/sklearn.pipeline/Pipeline/_can_transform": {},
  "sklearn/sklearn.pipeline/Pipeline/transform": {},
  "sklearn/sklearn.pipeline/Pipeline/_can_inverse_transform": {},
  "sklearn/sklearn.pipeline/Pipeline/inverse_transform": {},
  "sklearn/sklearn.pipeline/Pipeline/score": {},
  "sklearn/sklearn.pipeline/Pipeline/classes_@getter": {},
  "sklearn/sklearn.pipeline/Pipeline/_more_tags": {},
  "sklearn/sklearn.pipeline/Pipeline/get_feature_names_out": {},
  "sklearn/sklearn.pipeline/Pipeline/n_features_in_@getter": {},
  "sklearn/sklearn.pipeline/Pipeline/feature_names_in_@getter": {},
  "sklearn/sklearn.pipeline/Pipeline/__sklearn_is_fitted__": {},
  "sklearn/sklearn.pipeline/Pipeline/_sk_visual_block_": {},
  "sklearn/sklearn.pipeline/_name_estimators": {},
  "sklearn/sklearn.pipeline/make_pipeline": {},
  "sklearn/sklearn.pipeline/_transform_one": {},
  "sklearn/sklearn.pipeline/_fit_transform_one": {},
  "sklearn/sklearn.pipeline/_fit_one": {},
  "sklearn/sklearn.pipeline/FeatureUnion/__init__": {},
  "sklearn/sklearn.pipeline/FeatureUnion/set_output": {},
  "sklearn/sklearn.pipeline/FeatureUnion/named_transformers@getter": {},
  "sklearn/sklearn.pipeline/FeatureUnion/get_params": {},
  "sklearn/sklearn.pipeline/FeatureUnion/set_params": {},
  "sklearn/sklearn.pipeline/FeatureUnion/_validate_transformers": {},
  "sklearn/sklearn.pipeline/FeatureUnion/_validate_transformer_weights": {},
  "sklearn/sklearn.pipeline/FeatureUnion/_iter": {},
  "sklearn/sklearn.pipeline/FeatureUnion/get_feature_names_out": {},
  "sklearn/sklearn.pipeline/FeatureUnion/fit": {},
  "sklearn/sklearn.pipeline/FeatureUnion/fit_transform": {},
  "sklearn/sklearn.pipeline/FeatureUnion/_log_message": {},
  "sklearn/sklearn.pipeline/FeatureUnion/_parallel_func": {},
  "sklearn/sklearn.pipeline/FeatureUnion/transform": {},
  "sklearn/sklearn.pipeline/FeatureUnion/_hstack": {},
  "sklearn/sklearn.pipeline/FeatureUnion/_update_transformer_list": {},
  "sklearn/sklearn.pipeline/FeatureUnion/n_features_in_@getter": {},
  "sklearn/sklearn.pipeline/FeatureUnion/__sklearn_is_fitted__": {},
  "sklearn/sklearn.pipeline/FeatureUnion/_sk_visual_block_": {},
  "sklearn/sklearn.pipeline/make_union": {},
  "sklearn/sklearn.random_projection/johnson_lindenstrauss_min_dim": {},
  "sklearn/sklearn.random_projection/_check_density": {},
  "sklearn/sklearn.random_projection/_check_input_size": {},
  "sklearn/sklearn.random_projection/_gaussian_random_matrix": {},
  "sklearn/sklearn.random_projection/_sparse_random_matrix": {
    "density": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.random_projection/_sparse_random_matrix/density",
          "name": "density",
          "qname": "sklearn.random_projection._sparse_random_matrix.density",
          "default_value": "'auto'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "float or 'auto'",
            "default_value": "'auto'",
            "description": "Ratio of non-zero component in the random projection matrix in the\nrange `(0, 1]`\n\nIf density = 'auto', the value is set to the minimum density\nas recommended by Ping Li et al.: 1 / sqrt(n_features).\n\nUse density = 1 / 3.0 if you want to reproduce the results from\nAchlioptas, 2001."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "float"
              },
              {
                "kind": "NamedType",
                "name": "'auto'"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.random_projection/_sparse_random_matrix/density",
          "name": "density",
          "qname": "sklearn.random_projection._sparse_random_matrix.density",
          "default_value": "'auto'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "float or 'auto'",
            "default_value": "'auto'",
            "description": "Ratio of non-zero component in the random projection matrix in the\nrange `(0, 1]`\n\nIf density = 'auto', the value is set to the minimum density\nas recommended by Ping Li et al.: 1 / sqrt(n_features).\n\nUse density = 1 / 3.0 if you want to reproduce the results from\nAchlioptas, 2001."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "float"
              },
              {
                "kind": "NamedType",
                "name": "'auto'"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If density equals auto"
        },
        "hasAction": {
          "action": "Ratio of non - zero component in the random projection matrix in the range ( 0 , 1 ] , the value is set to the minimum density as recommended by Ping Li et al . : 1 / sqrt(n_features )"
        }
      }
    ]
  },
  "sklearn/sklearn.random_projection/BaseRandomProjection/__init__": {},
  "sklearn/sklearn.random_projection/BaseRandomProjection/_make_random_matrix": {},
  "sklearn/sklearn.random_projection/BaseRandomProjection/_compute_inverse_components": {},
  "sklearn/sklearn.random_projection/BaseRandomProjection/fit": {},
  "sklearn/sklearn.random_projection/BaseRandomProjection/_n_features_out@getter": {},
  "sklearn/sklearn.random_projection/BaseRandomProjection/inverse_transform": {},
  "sklearn/sklearn.random_projection/BaseRandomProjection/_more_tags": {},
  "sklearn/sklearn.random_projection/GaussianRandomProjection/__init__": {
    "eps": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.random_projection/GaussianRandomProjection/__init__/eps",
          "name": "eps",
          "qname": "sklearn.random_projection.GaussianRandomProjection.__init__.eps",
          "default_value": "0.1",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "0.1",
            "description": "Parameter to control the quality of the embedding according to\nthe Johnson-Lindenstrauss lemma when `n_components` is set to\n'auto'. The value should be strictly positive.\n\nSmaller values lead to better embedding and higher number of\ndimensions (n_components) in the target projection space."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.random_projection/GaussianRandomProjection/__init__/n_components",
          "name": "n_components",
          "qname": "sklearn.random_projection.GaussianRandomProjection.__init__.n_components",
          "default_value": "'auto'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "int or 'auto'",
            "default_value": "'auto'",
            "description": "Dimensionality of the target projection space.\n\nn_components can be automatically adjusted according to the\nnumber of samples in the dataset and the bound given by the\nJohnson-Lindenstrauss lemma. In that case the quality of the\nembedding is controlled by the ``eps`` parameter.\n\nIt should be noted that Johnson-Lindenstrauss lemma can yield\nvery conservative estimated of the required number of components\nas it makes no assumption on the structure of the dataset."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "'auto'"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "when n_components is set to auto"
        },
        "hasAction": {
          "action": "Parameter to control the quality of the embedding according to the Johnson - Lindenstrauss lemma"
        }
      }
    ]
  },
  "sklearn/sklearn.random_projection/GaussianRandomProjection/_make_random_matrix": {},
  "sklearn/sklearn.random_projection/GaussianRandomProjection/transform": {},
  "sklearn/sklearn.random_projection/SparseRandomProjection/__init__": {
    "density": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.random_projection/SparseRandomProjection/__init__/density",
          "name": "density",
          "qname": "sklearn.random_projection.SparseRandomProjection.__init__.density",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float or 'auto'",
            "default_value": "'auto'",
            "description": "Ratio in the range (0, 1] of non-zero component in the random\nprojection matrix.\n\nIf density = 'auto', the value is set to the minimum density\nas recommended by Ping Li et al.: 1 / sqrt(n_features).\n\nUse density = 1 / 3.0 if you want to reproduce the results from\nAchlioptas, 2001."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "BoundaryType",
                "base_type": "float",
                "min": 0.0,
                "max": 1.0,
                "min_inclusive": false,
                "max_inclusive": true
              },
              {
                "kind": "NamedType",
                "name": "float"
              },
              {
                "kind": "NamedType",
                "name": "'auto'"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.random_projection/SparseRandomProjection/__init__/density",
          "name": "density",
          "qname": "sklearn.random_projection.SparseRandomProjection.__init__.density",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float or 'auto'",
            "default_value": "'auto'",
            "description": "Ratio in the range (0, 1] of non-zero component in the random\nprojection matrix.\n\nIf density = 'auto', the value is set to the minimum density\nas recommended by Ping Li et al.: 1 / sqrt(n_features).\n\nUse density = 1 / 3.0 if you want to reproduce the results from\nAchlioptas, 2001."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "BoundaryType",
                "base_type": "float",
                "min": 0.0,
                "max": 1.0,
                "min_inclusive": false,
                "max_inclusive": true
              },
              {
                "kind": "NamedType",
                "name": "float"
              },
              {
                "kind": "NamedType",
                "name": "'auto'"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If density equals auto"
        },
        "hasAction": {
          "action": ", the value is set to the minimum density as recommended by Ping Li et al . : 1 / sqrt(n_features )"
        }
      }
    ],
    "eps": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.random_projection/SparseRandomProjection/__init__/eps",
          "name": "eps",
          "qname": "sklearn.random_projection.SparseRandomProjection.__init__.eps",
          "default_value": "0.1",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "0.1",
            "description": "Parameter to control the quality of the embedding according to\nthe Johnson-Lindenstrauss lemma when n_components is set to\n'auto'. This value should be strictly positive.\n\nSmaller values lead to better embedding and higher number of\ndimensions (n_components) in the target projection space."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.random_projection/SparseRandomProjection/__init__/n_components",
          "name": "n_components",
          "qname": "sklearn.random_projection.SparseRandomProjection.__init__.n_components",
          "default_value": "'auto'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "int or 'auto'",
            "default_value": "'auto'",
            "description": "Dimensionality of the target projection space.\n\nn_components can be automatically adjusted according to the\nnumber of samples in the dataset and the bound given by the\nJohnson-Lindenstrauss lemma. In that case the quality of the\nembedding is controlled by the ``eps`` parameter.\n\nIt should be noted that Johnson-Lindenstrauss lemma can yield\nvery conservative estimated of the required number of components\nas it makes no assumption on the structure of the dataset."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "'auto'"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "when n_components is set to auto"
        },
        "hasAction": {
          "action": "Parameter to control the quality of the embedding according to the Johnson - Lindenstrauss lemma"
        }
      }
    ]
  },
  "sklearn/sklearn.random_projection/SparseRandomProjection/_make_random_matrix": {},
  "sklearn/sklearn.random_projection/SparseRandomProjection/transform": {},
  "sklearn/sklearn._config/_get_threadlocal_config": {},
  "sklearn/sklearn._config/get_config": {},
  "sklearn/sklearn._config/set_config": {},
  "sklearn/sklearn._config/config_context": {},
  "sklearn/sklearn.cluster._affinity_propagation/_equal_similarities_and_preferences": {},
  "sklearn/sklearn.cluster._affinity_propagation/_affinity_propagation": {},
  "sklearn/sklearn.cluster._affinity_propagation/affinity_propagation": {
    "copy": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.cluster._affinity_propagation/affinity_propagation/copy",
          "name": "copy",
          "qname": "sklearn.cluster._affinity_propagation.affinity_propagation.copy",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "If copy is False, the affinity matrix is modified inplace by the\nalgorithm, for memory efficiency."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.cluster._affinity_propagation/affinity_propagation/copy",
          "name": "copy",
          "qname": "sklearn.cluster._affinity_propagation.affinity_propagation.copy",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "If copy is False, the affinity matrix is modified inplace by the\nalgorithm, for memory efficiency."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "If copy is False"
        },
        "hasAction": {
          "action": ", the affinity matrix is modified inplace by the algorithm , for memory efficiency"
        }
      }
    ]
  },
  "sklearn/sklearn.cluster._affinity_propagation/AffinityPropagation/__init__": {},
  "sklearn/sklearn.cluster._affinity_propagation/AffinityPropagation/_more_tags": {},
  "sklearn/sklearn.cluster._affinity_propagation/AffinityPropagation/fit": {},
  "sklearn/sklearn.cluster._affinity_propagation/AffinityPropagation/predict": {},
  "sklearn/sklearn.cluster._affinity_propagation/AffinityPropagation/fit_predict": {},
  "sklearn/sklearn.cluster._agglomerative/_fix_connectivity": {},
  "sklearn/sklearn.cluster._agglomerative/_single_linkage_tree": {},
  "sklearn/sklearn.cluster._agglomerative/ward_tree": {},
  "sklearn/sklearn.cluster._agglomerative/linkage_tree": {},
  "sklearn/sklearn.cluster._agglomerative/_complete_linkage": {},
  "sklearn/sklearn.cluster._agglomerative/_average_linkage": {},
  "sklearn/sklearn.cluster._agglomerative/_single_linkage": {},
  "sklearn/sklearn.cluster._agglomerative/_hc_cut": {},
  "sklearn/sklearn.cluster._agglomerative/AgglomerativeClustering/__init__": {
    "affinity": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.cluster._agglomerative/AgglomerativeClustering/__init__/affinity",
          "name": "affinity",
          "qname": "sklearn.cluster._agglomerative.AgglomerativeClustering.__init__.affinity",
          "default_value": "'deprecated'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'euclidean'",
            "description": "The metric to use when calculating distance between instances in a\nfeature array. If metric is a string or callable, it must be one of\nthe options allowed by :func:`sklearn.metrics.pairwise_distances` for\nits metric parameter.\nIf linkage is \"ward\", only \"euclidean\" is accepted.\nIf \"precomputed\", a distance matrix (instead of a similarity matrix)\nis needed as input for the fit method.\n\n.. deprecated:: 1.2\n    `affinity` was deprecated in version 1.2 and will be renamed to\n    `metric` in 1.4."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.cluster._agglomerative/AgglomerativeClustering/__init__/linkage",
          "name": "linkage",
          "qname": "sklearn.cluster._agglomerative.AgglomerativeClustering.__init__.linkage",
          "default_value": "'ward'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'ward', 'complete', 'average', 'single'}",
            "default_value": "'ward'",
            "description": "Which linkage criterion to use. The linkage criterion determines which\ndistance to use between sets of observation. The algorithm will merge\nthe pairs of cluster that minimize this criterion.\n\n- 'ward' minimizes the variance of the clusters being merged.\n- 'average' uses the average of the distances of each observation of\n  the two sets.\n- 'complete' or 'maximum' linkage uses the maximum distances between\n  all observations of the two sets.\n- 'single' uses the minimum of the distances between all observations\n  of the two sets.\n\n.. versionadded:: 0.20\n    Added the 'single' option"
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "ward",
              "average",
              "single",
              "complete"
            ]
          }
        },
        "hasCondition": {
          "condition": "If linkage is ward"
        },
        "hasAction": {
          "action": ", only euclidean is accepted"
        }
      }
    ],
    "metric": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.cluster._agglomerative/AgglomerativeClustering/__init__/metric",
          "name": "metric",
          "qname": "sklearn.cluster._agglomerative.AgglomerativeClustering.__init__.metric",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "None",
            "description": "Metric used to compute the linkage. Can be \"euclidean\", \"l1\", \"l2\",\n\"manhattan\", \"cosine\", or \"precomputed\". If set to `None` then\n\"euclidean\" is used. If linkage is \"ward\", only \"euclidean\" is\naccepted. If \"precomputed\", a distance matrix is needed as input for\nthe fit method.\n\n.. versionadded:: 1.2"
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.cluster._agglomerative/AgglomerativeClustering/__init__/linkage",
          "name": "linkage",
          "qname": "sklearn.cluster._agglomerative.AgglomerativeClustering.__init__.linkage",
          "default_value": "'ward'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'ward', 'complete', 'average', 'single'}",
            "default_value": "'ward'",
            "description": "Which linkage criterion to use. The linkage criterion determines which\ndistance to use between sets of observation. The algorithm will merge\nthe pairs of cluster that minimize this criterion.\n\n- 'ward' minimizes the variance of the clusters being merged.\n- 'average' uses the average of the distances of each observation of\n  the two sets.\n- 'complete' or 'maximum' linkage uses the maximum distances between\n  all observations of the two sets.\n- 'single' uses the minimum of the distances between all observations\n  of the two sets.\n\n.. versionadded:: 0.20\n    Added the 'single' option"
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "ward",
              "average",
              "single",
              "complete"
            ]
          }
        },
        "hasCondition": {
          "condition": "If linkage is ward"
        },
        "hasAction": {
          "action": ", only euclidean is accepted"
        }
      }
    ],
    "compute_distances": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.cluster._agglomerative/AgglomerativeClustering/__init__/compute_distances",
          "name": "compute_distances",
          "qname": "sklearn.cluster._agglomerative.AgglomerativeClustering.__init__.compute_distances",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "Computes distances between clusters even if `distance_threshold` is not\nused. This can be used to make dendrogram visualization, but introduces\na computational and memory overhead.\n\n.. versionadded:: 0.24"
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.cluster._agglomerative/AgglomerativeClustering/__init__/distance_threshold",
          "name": "distance_threshold",
          "qname": "sklearn.cluster._agglomerative.AgglomerativeClustering.__init__.distance_threshold",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "None",
            "description": "The linkage distance threshold at or above which clusters will not be\nmerged. If not ``None``, ``n_clusters`` must be ``None`` and\n``compute_full_tree`` must be ``True``.\n\n.. versionadded:: 0.21"
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "hasCondition": {
          "condition": "even if distance_threshold is not used"
        },
        "hasAction": {
          "action": "Computes distances between clusters"
        }
      }
    ]
  },
  "sklearn/sklearn.cluster._agglomerative/AgglomerativeClustering/fit": {},
  "sklearn/sklearn.cluster._agglomerative/AgglomerativeClustering/_fit": {},
  "sklearn/sklearn.cluster._agglomerative/AgglomerativeClustering/fit_predict": {},
  "sklearn/sklearn.cluster._agglomerative/FeatureAgglomeration/__init__": {
    "affinity": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.cluster._agglomerative/FeatureAgglomeration/__init__/affinity",
          "name": "affinity",
          "qname": "sklearn.cluster._agglomerative.FeatureAgglomeration.__init__.affinity",
          "default_value": "'deprecated'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'euclidean'",
            "description": "The metric to use when calculating distance between instances in a\nfeature array. If metric is a string or callable, it must be one of\nthe options allowed by :func:`sklearn.metrics.pairwise_distances` for\nits metric parameter.\nIf linkage is \"ward\", only \"euclidean\" is accepted.\nIf \"precomputed\", a distance matrix (instead of a similarity matrix)\nis needed as input for the fit method.\n\n.. deprecated:: 1.2\n    `affinity` was deprecated in version 1.2 and will be renamed to\n    `metric` in 1.4."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.cluster._agglomerative/FeatureAgglomeration/__init__/linkage",
          "name": "linkage",
          "qname": "sklearn.cluster._agglomerative.FeatureAgglomeration.__init__.linkage",
          "default_value": "'ward'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{\"ward\", \"complete\", \"average\", \"single\"}",
            "default_value": "\"ward\"",
            "description": "Which linkage criterion to use. The linkage criterion determines which\ndistance to use between sets of features. The algorithm will merge\nthe pairs of cluster that minimize this criterion.\n\n- \"ward\" minimizes the variance of the clusters being merged.\n- \"complete\" or maximum linkage uses the maximum distances between\n  all features of the two sets.\n- \"average\" uses the average of the distances of each feature of\n  the two sets.\n- \"single\" uses the minimum of the distances between all features\n  of the two sets."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "ward",
              "average",
              "single",
              "complete"
            ]
          }
        },
        "hasCondition": {
          "condition": "If linkage is ward"
        },
        "hasAction": {
          "action": ", only euclidean is accepted"
        }
      }
    ],
    "metric": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.cluster._agglomerative/FeatureAgglomeration/__init__/metric",
          "name": "metric",
          "qname": "sklearn.cluster._agglomerative.FeatureAgglomeration.__init__.metric",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "None",
            "description": "Metric used to compute the linkage. Can be \"euclidean\", \"l1\", \"l2\",\n\"manhattan\", \"cosine\", or \"precomputed\". If set to `None` then\n\"euclidean\" is used. If linkage is \"ward\", only \"euclidean\" is\naccepted. If \"precomputed\", a distance matrix is needed as input for\nthe fit method.\n\n.. versionadded:: 1.2"
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.cluster._agglomerative/FeatureAgglomeration/__init__/linkage",
          "name": "linkage",
          "qname": "sklearn.cluster._agglomerative.FeatureAgglomeration.__init__.linkage",
          "default_value": "'ward'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{\"ward\", \"complete\", \"average\", \"single\"}",
            "default_value": "\"ward\"",
            "description": "Which linkage criterion to use. The linkage criterion determines which\ndistance to use between sets of features. The algorithm will merge\nthe pairs of cluster that minimize this criterion.\n\n- \"ward\" minimizes the variance of the clusters being merged.\n- \"complete\" or maximum linkage uses the maximum distances between\n  all features of the two sets.\n- \"average\" uses the average of the distances of each feature of\n  the two sets.\n- \"single\" uses the minimum of the distances between all features\n  of the two sets."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "ward",
              "average",
              "single",
              "complete"
            ]
          }
        },
        "hasCondition": {
          "condition": "If linkage is ward"
        },
        "hasAction": {
          "action": ", only euclidean is accepted"
        }
      }
    ],
    "compute_distances": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.cluster._agglomerative/FeatureAgglomeration/__init__/compute_distances",
          "name": "compute_distances",
          "qname": "sklearn.cluster._agglomerative.FeatureAgglomeration.__init__.compute_distances",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "Computes distances between clusters even if `distance_threshold` is not\nused. This can be used to make dendrogram visualization, but introduces\na computational and memory overhead.\n\n.. versionadded:: 0.24"
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.cluster._agglomerative/FeatureAgglomeration/__init__/distance_threshold",
          "name": "distance_threshold",
          "qname": "sklearn.cluster._agglomerative.FeatureAgglomeration.__init__.distance_threshold",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "None",
            "description": "The linkage distance threshold at or above which clusters will not be\nmerged. If not ``None``, ``n_clusters`` must be ``None`` and\n``compute_full_tree`` must be ``True``.\n\n.. versionadded:: 0.21"
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "hasCondition": {
          "condition": "even if distance_threshold is not used"
        },
        "hasAction": {
          "action": "Computes distances between clusters"
        }
      }
    ]
  },
  "sklearn/sklearn.cluster._agglomerative/FeatureAgglomeration/fit": {},
  "sklearn/sklearn.cluster._agglomerative/FeatureAgglomeration/fit_predict@getter": {},
  "sklearn/sklearn.cluster._bicluster/_scale_normalize": {},
  "sklearn/sklearn.cluster._bicluster/_bistochastic_normalize": {},
  "sklearn/sklearn.cluster._bicluster/_log_normalize": {},
  "sklearn/sklearn.cluster._bicluster/BaseSpectral/__init__": {},
  "sklearn/sklearn.cluster._bicluster/BaseSpectral/_check_parameters": {},
  "sklearn/sklearn.cluster._bicluster/BaseSpectral/fit": {},
  "sklearn/sklearn.cluster._bicluster/BaseSpectral/_svd": {},
  "sklearn/sklearn.cluster._bicluster/BaseSpectral/_k_means": {},
  "sklearn/sklearn.cluster._bicluster/BaseSpectral/_more_tags": {},
  "sklearn/sklearn.cluster._bicluster/SpectralCoclustering/__init__": {
    "n_svd_vecs": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.cluster._bicluster/SpectralCoclustering/__init__/n_svd_vecs",
          "name": "n_svd_vecs",
          "qname": "sklearn.cluster._bicluster.SpectralCoclustering.__init__.n_svd_vecs",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "None",
            "description": "Number of vectors to use in calculating the SVD. Corresponds\nto `ncv` when `svd_method=arpack` and `n_oversamples` when\n`svd_method` is 'randomized`."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.cluster._bicluster/SpectralCoclustering/__init__/svd_method",
          "name": "svd_method",
          "qname": "sklearn.cluster._bicluster.SpectralCoclustering.__init__.svd_method",
          "default_value": "'randomized'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'randomized', 'arpack'}",
            "default_value": "'randomized'",
            "description": "Selects the algorithm for finding singular vectors. May be\n'randomized' or 'arpack'. If 'randomized', use\n:func:`sklearn.utils.extmath.randomized_svd`, which may be faster\nfor large matrices. If 'arpack', use\n:func:`scipy.sparse.linalg.svds`, which is more accurate, but\npossibly slower in some cases."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "randomized",
              "arpack"
            ]
          }
        },
        "hasCondition": {
          "condition": "when svd_method is randomized"
        },
        "hasAction": {
          "action": "n_oversamples"
        }
      }
    ]
  },
  "sklearn/sklearn.cluster._bicluster/SpectralCoclustering/_check_parameters": {},
  "sklearn/sklearn.cluster._bicluster/SpectralCoclustering/_fit": {},
  "sklearn/sklearn.cluster._bicluster/SpectralBiclustering/__init__": {
    "n_svd_vecs": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.cluster._bicluster/SpectralBiclustering/__init__/n_svd_vecs",
          "name": "n_svd_vecs",
          "qname": "sklearn.cluster._bicluster.SpectralBiclustering.__init__.n_svd_vecs",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "None",
            "description": "Number of vectors to use in calculating the SVD. Corresponds\nto `ncv` when `svd_method=arpack` and `n_oversamples` when\n`svd_method` is 'randomized`."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.cluster._bicluster/SpectralBiclustering/__init__/svd_method",
          "name": "svd_method",
          "qname": "sklearn.cluster._bicluster.SpectralBiclustering.__init__.svd_method",
          "default_value": "'randomized'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'randomized', 'arpack'}",
            "default_value": "'randomized'",
            "description": "Selects the algorithm for finding singular vectors. May be\n'randomized' or 'arpack'. If 'randomized', uses\n:func:`~sklearn.utils.extmath.randomized_svd`, which may be faster\nfor large matrices. If 'arpack', uses\n`scipy.sparse.linalg.svds`, which is more accurate, but\npossibly slower in some cases."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "randomized",
              "arpack"
            ]
          }
        },
        "hasCondition": {
          "condition": "when svd_method is randomized"
        },
        "hasAction": {
          "action": "n_oversamples"
        }
      }
    ]
  },
  "sklearn/sklearn.cluster._bicluster/SpectralBiclustering/_check_parameters": {},
  "sklearn/sklearn.cluster._bicluster/SpectralBiclustering/_fit": {},
  "sklearn/sklearn.cluster._bicluster/SpectralBiclustering/_fit_best_piecewise": {},
  "sklearn/sklearn.cluster._bicluster/SpectralBiclustering/_project_and_cluster": {},
  "sklearn/sklearn.cluster._birch/_iterate_sparse_X": {},
  "sklearn/sklearn.cluster._birch/_split_node": {},
  "sklearn/sklearn.cluster._birch/_CFNode/__init__": {},
  "sklearn/sklearn.cluster._birch/_CFNode/append_subcluster": {},
  "sklearn/sklearn.cluster._birch/_CFNode/update_split_subclusters": {},
  "sklearn/sklearn.cluster._birch/_CFNode/insert_cf_subcluster": {},
  "sklearn/sklearn.cluster._birch/_CFSubcluster/__init__": {},
  "sklearn/sklearn.cluster._birch/_CFSubcluster/update": {},
  "sklearn/sklearn.cluster._birch/_CFSubcluster/merge_subcluster": {},
  "sklearn/sklearn.cluster._birch/_CFSubcluster/radius@getter": {},
  "sklearn/sklearn.cluster._birch/Birch/__init__": {},
  "sklearn/sklearn.cluster._birch/Birch/fit": {},
  "sklearn/sklearn.cluster._birch/Birch/_fit": {},
  "sklearn/sklearn.cluster._birch/Birch/_get_leaves": {},
  "sklearn/sklearn.cluster._birch/Birch/partial_fit": {
    "X": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.cluster._birch/Birch/partial_fit/X",
          "name": "X",
          "qname": "sklearn.cluster._birch.Birch.partial_fit.X",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "{array-like, sparse matrix} of shape (n_samples, n_features)",
            "default_value": "None",
            "description": "Input data. If X is not provided, only the global clustering\nstep is done."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "EnumType",
                "values": []
              },
              {
                "kind": "NamedType",
                "name": "of shape (n_samples, n_features)"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.cluster._birch/Birch/partial_fit/X",
          "name": "X",
          "qname": "sklearn.cluster._birch.Birch.partial_fit.X",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "{array-like, sparse matrix} of shape (n_samples, n_features)",
            "default_value": "None",
            "description": "Input data. If X is not provided, only the global clustering\nstep is done."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "EnumType",
                "values": []
              },
              {
                "kind": "NamedType",
                "name": "of shape (n_samples, n_features)"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If X is not provided"
        },
        "hasAction": {
          "action": ", only the global clustering step is done"
        }
      }
    ]
  },
  "sklearn/sklearn.cluster._birch/Birch/_check_fit": {},
  "sklearn/sklearn.cluster._birch/Birch/predict": {},
  "sklearn/sklearn.cluster._birch/Birch/_predict": {},
  "sklearn/sklearn.cluster._birch/Birch/transform": {},
  "sklearn/sklearn.cluster._birch/Birch/_global_clustering": {},
  "sklearn/sklearn.cluster._birch/Birch/_more_tags": {},
  "sklearn/sklearn.cluster._bisect_k_means/_BisectingTree/__init__": {},
  "sklearn/sklearn.cluster._bisect_k_means/_BisectingTree/split": {},
  "sklearn/sklearn.cluster._bisect_k_means/_BisectingTree/get_cluster_to_bisect": {},
  "sklearn/sklearn.cluster._bisect_k_means/_BisectingTree/iter_leaves": {},
  "sklearn/sklearn.cluster._bisect_k_means/BisectingKMeans/__init__": {
    "copy_x": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.cluster._bisect_k_means/BisectingKMeans/__init__/copy_x",
          "name": "copy_x",
          "qname": "sklearn.cluster._bisect_k_means.BisectingKMeans.__init__.copy_x",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "When pre-computing distances it is more numerically accurate to center\nthe data first. If copy_x is True (default), then the original data is\nnot modified. If False, the original data is modified, and put back\nbefore the function returns, but small numerical differences may be\nintroduced by subtracting and then adding the data mean. Note that if\nthe original data is not C-contiguous, a copy will be made even if\ncopy_x is False. If the original data is sparse, but not in CSR format,\na copy will be made even if copy_x is False."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.cluster._bisect_k_means/BisectingKMeans/__init__/copy_x",
          "name": "copy_x",
          "qname": "sklearn.cluster._bisect_k_means.BisectingKMeans.__init__.copy_x",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "When pre-computing distances it is more numerically accurate to center\nthe data first. If copy_x is True (default), then the original data is\nnot modified. If False, the original data is modified, and put back\nbefore the function returns, but small numerical differences may be\nintroduced by subtracting and then adding the data mean. Note that if\nthe original data is not C-contiguous, a copy will be made even if\ncopy_x is False. If the original data is sparse, but not in CSR format,\na copy will be made even if copy_x is False."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "If copy_x is True ( default )"
        },
        "hasAction": {
          "action": ", then the original data is not modified"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.cluster._bisect_k_means/BisectingKMeans/__init__/copy_x",
          "name": "copy_x",
          "qname": "sklearn.cluster._bisect_k_means.BisectingKMeans.__init__.copy_x",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "When pre-computing distances it is more numerically accurate to center\nthe data first. If copy_x is True (default), then the original data is\nnot modified. If False, the original data is modified, and put back\nbefore the function returns, but small numerical differences may be\nintroduced by subtracting and then adding the data mean. Note that if\nthe original data is not C-contiguous, a copy will be made even if\ncopy_x is False. If the original data is sparse, but not in CSR format,\na copy will be made even if copy_x is False."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.cluster._bisect_k_means/BisectingKMeans/__init__/copy_x",
          "name": "copy_x",
          "qname": "sklearn.cluster._bisect_k_means.BisectingKMeans.__init__.copy_x",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "When pre-computing distances it is more numerically accurate to center\nthe data first. If copy_x is True (default), then the original data is\nnot modified. If False, the original data is modified, and put back\nbefore the function returns, but small numerical differences may be\nintroduced by subtracting and then adding the data mean. Note that if\nthe original data is not C-contiguous, a copy will be made even if\ncopy_x is False. If the original data is sparse, but not in CSR format,\na copy will be made even if copy_x is False."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "even if copy_x is False"
        },
        "hasAction": {
          "action": "that if the original data is not C - contiguous , a copy will be made"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.cluster._bisect_k_means/BisectingKMeans/__init__/copy_x",
          "name": "copy_x",
          "qname": "sklearn.cluster._bisect_k_means.BisectingKMeans.__init__.copy_x",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "When pre-computing distances it is more numerically accurate to center\nthe data first. If copy_x is True (default), then the original data is\nnot modified. If False, the original data is modified, and put back\nbefore the function returns, but small numerical differences may be\nintroduced by subtracting and then adding the data mean. Note that if\nthe original data is not C-contiguous, a copy will be made even if\ncopy_x is False. If the original data is sparse, but not in CSR format,\na copy will be made even if copy_x is False."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.cluster._bisect_k_means/BisectingKMeans/__init__/copy_x",
          "name": "copy_x",
          "qname": "sklearn.cluster._bisect_k_means.BisectingKMeans.__init__.copy_x",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "When pre-computing distances it is more numerically accurate to center\nthe data first. If copy_x is True (default), then the original data is\nnot modified. If False, the original data is modified, and put back\nbefore the function returns, but small numerical differences may be\nintroduced by subtracting and then adding the data mean. Note that if\nthe original data is not C-contiguous, a copy will be made even if\ncopy_x is False. If the original data is sparse, but not in CSR format,\na copy will be made even if copy_x is False."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "even if copy_x is False"
        },
        "hasAction": {
          "action": "If the original data is sparse , but not in CSR format , a copy will be made"
        }
      }
    ]
  },
  "sklearn/sklearn.cluster._bisect_k_means/BisectingKMeans/_warn_mkl_vcomp": {},
  "sklearn/sklearn.cluster._bisect_k_means/BisectingKMeans/_inertia_per_cluster": {},
  "sklearn/sklearn.cluster._bisect_k_means/BisectingKMeans/_bisect": {},
  "sklearn/sklearn.cluster._bisect_k_means/BisectingKMeans/fit": {},
  "sklearn/sklearn.cluster._bisect_k_means/BisectingKMeans/predict": {},
  "sklearn/sklearn.cluster._bisect_k_means/BisectingKMeans/_predict_recursive": {},
  "sklearn/sklearn.cluster._bisect_k_means/BisectingKMeans/_more_tags": {},
  "sklearn/sklearn.cluster._dbscan/dbscan": {
    "metric": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.cluster._dbscan/dbscan/metric",
          "name": "metric",
          "qname": "sklearn.cluster._dbscan.dbscan.metric",
          "default_value": "'minkowski'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'minkowski'",
            "description": "The metric to use when calculating distance between instances in a\nfeature array. If metric is a string or callable, it must be one of\nthe options allowed by :func:`sklearn.metrics.pairwise_distances` for\nits metric parameter.\nIf metric is \"precomputed\", X is assumed to be a distance matrix and\nmust be square during fit.\nX may be a :term:`sparse graph <sparse graph>`,\nin which case only \"nonzero\" elements may be considered neighbors."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.cluster._dbscan/dbscan/metric",
          "name": "metric",
          "qname": "sklearn.cluster._dbscan.dbscan.metric",
          "default_value": "'minkowski'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'minkowski'",
            "description": "The metric to use when calculating distance between instances in a\nfeature array. If metric is a string or callable, it must be one of\nthe options allowed by :func:`sklearn.metrics.pairwise_distances` for\nits metric parameter.\nIf metric is \"precomputed\", X is assumed to be a distance matrix and\nmust be square during fit.\nX may be a :term:`sparse graph <sparse graph>`,\nin which case only \"nonzero\" elements may be considered neighbors."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If metric is precomputed"
        },
        "hasAction": {
          "action": ", X is assumed to be a distance matrix and must be square during fit"
        }
      }
    ]
  },
  "sklearn/sklearn.cluster._dbscan/DBSCAN/__init__": {
    "metric": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.cluster._dbscan/DBSCAN/__init__/metric",
          "name": "metric",
          "qname": "sklearn.cluster._dbscan.DBSCAN.__init__.metric",
          "default_value": "'euclidean'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str, or callable",
            "default_value": "'euclidean'",
            "description": "The metric to use when calculating distance between instances in a\nfeature array. If metric is a string or callable, it must be one of\nthe options allowed by :func:`sklearn.metrics.pairwise_distances` for\nits metric parameter.\nIf metric is \"precomputed\", X is assumed to be a distance matrix and\nmust be square. X may be a :term:`sparse graph`, in which\ncase only \"nonzero\" elements may be considered neighbors for DBSCAN.\n\n.. versionadded:: 0.17\n   metric *precomputed* to accept precomputed sparse matrix."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.cluster._dbscan/DBSCAN/__init__/metric",
          "name": "metric",
          "qname": "sklearn.cluster._dbscan.DBSCAN.__init__.metric",
          "default_value": "'euclidean'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str, or callable",
            "default_value": "'euclidean'",
            "description": "The metric to use when calculating distance between instances in a\nfeature array. If metric is a string or callable, it must be one of\nthe options allowed by :func:`sklearn.metrics.pairwise_distances` for\nits metric parameter.\nIf metric is \"precomputed\", X is assumed to be a distance matrix and\nmust be square. X may be a :term:`sparse graph`, in which\ncase only \"nonzero\" elements may be considered neighbors for DBSCAN.\n\n.. versionadded:: 0.17\n   metric *precomputed* to accept precomputed sparse matrix."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If metric is precomputed"
        },
        "hasAction": {
          "action": ", X is assumed to be a distance matrix and must be square"
        }
      }
    ]
  },
  "sklearn/sklearn.cluster._dbscan/DBSCAN/fit": {},
  "sklearn/sklearn.cluster._dbscan/DBSCAN/fit_predict": {},
  "sklearn/sklearn.cluster._dbscan/DBSCAN/_more_tags": {},
  "sklearn/sklearn.cluster._feature_agglomeration/AgglomerationTransform/transform": {},
  "sklearn/sklearn.cluster._feature_agglomeration/AgglomerationTransform/inverse_transform": {},
  "sklearn/sklearn.cluster._kmeans/kmeans_plusplus": {},
  "sklearn/sklearn.cluster._kmeans/_kmeans_plusplus": {},
  "sklearn/sklearn.cluster._kmeans/_tolerance": {},
  "sklearn/sklearn.cluster._kmeans/k_means": {
    "copy_x": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.cluster._kmeans/k_means/copy_x",
          "name": "copy_x",
          "qname": "sklearn.cluster._kmeans.k_means.copy_x",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "When pre-computing distances it is more numerically accurate to center\nthe data first. If `copy_x` is True (default), then the original data is\nnot modified. If False, the original data is modified, and put back\nbefore the function returns, but small numerical differences may be\nintroduced by subtracting and then adding the data mean. Note that if\nthe original data is not C-contiguous, a copy will be made even if\n`copy_x` is False. If the original data is sparse, but not in CSR format,\na copy will be made even if `copy_x` is False."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.cluster._kmeans/k_means/copy_x",
          "name": "copy_x",
          "qname": "sklearn.cluster._kmeans.k_means.copy_x",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "When pre-computing distances it is more numerically accurate to center\nthe data first. If `copy_x` is True (default), then the original data is\nnot modified. If False, the original data is modified, and put back\nbefore the function returns, but small numerical differences may be\nintroduced by subtracting and then adding the data mean. Note that if\nthe original data is not C-contiguous, a copy will be made even if\n`copy_x` is False. If the original data is sparse, but not in CSR format,\na copy will be made even if `copy_x` is False."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "If copy_x is True ( default )"
        },
        "hasAction": {
          "action": ", then the original data is not modified"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.cluster._kmeans/k_means/copy_x",
          "name": "copy_x",
          "qname": "sklearn.cluster._kmeans.k_means.copy_x",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "When pre-computing distances it is more numerically accurate to center\nthe data first. If `copy_x` is True (default), then the original data is\nnot modified. If False, the original data is modified, and put back\nbefore the function returns, but small numerical differences may be\nintroduced by subtracting and then adding the data mean. Note that if\nthe original data is not C-contiguous, a copy will be made even if\n`copy_x` is False. If the original data is sparse, but not in CSR format,\na copy will be made even if `copy_x` is False."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.cluster._kmeans/k_means/copy_x",
          "name": "copy_x",
          "qname": "sklearn.cluster._kmeans.k_means.copy_x",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "When pre-computing distances it is more numerically accurate to center\nthe data first. If `copy_x` is True (default), then the original data is\nnot modified. If False, the original data is modified, and put back\nbefore the function returns, but small numerical differences may be\nintroduced by subtracting and then adding the data mean. Note that if\nthe original data is not C-contiguous, a copy will be made even if\n`copy_x` is False. If the original data is sparse, but not in CSR format,\na copy will be made even if `copy_x` is False."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "even if copy_x is False"
        },
        "hasAction": {
          "action": "that if the original data is not C - contiguous , a copy will be made"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.cluster._kmeans/k_means/copy_x",
          "name": "copy_x",
          "qname": "sklearn.cluster._kmeans.k_means.copy_x",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "When pre-computing distances it is more numerically accurate to center\nthe data first. If `copy_x` is True (default), then the original data is\nnot modified. If False, the original data is modified, and put back\nbefore the function returns, but small numerical differences may be\nintroduced by subtracting and then adding the data mean. Note that if\nthe original data is not C-contiguous, a copy will be made even if\n`copy_x` is False. If the original data is sparse, but not in CSR format,\na copy will be made even if `copy_x` is False."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.cluster._kmeans/k_means/copy_x",
          "name": "copy_x",
          "qname": "sklearn.cluster._kmeans.k_means.copy_x",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "When pre-computing distances it is more numerically accurate to center\nthe data first. If `copy_x` is True (default), then the original data is\nnot modified. If False, the original data is modified, and put back\nbefore the function returns, but small numerical differences may be\nintroduced by subtracting and then adding the data mean. Note that if\nthe original data is not C-contiguous, a copy will be made even if\n`copy_x` is False. If the original data is sparse, but not in CSR format,\na copy will be made even if `copy_x` is False."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "even if copy_x is False"
        },
        "hasAction": {
          "action": "If the original data is sparse , but not in CSR format , a copy will be made"
        }
      }
    ]
  },
  "sklearn/sklearn.cluster._kmeans/_kmeans_single_elkan": {},
  "sklearn/sklearn.cluster._kmeans/_kmeans_single_lloyd": {},
  "sklearn/sklearn.cluster._kmeans/_labels_inertia": {},
  "sklearn/sklearn.cluster._kmeans/_labels_inertia_threadpool_limit": {},
  "sklearn/sklearn.cluster._kmeans/_BaseKMeans/__init__": {},
  "sklearn/sklearn.cluster._kmeans/_BaseKMeans/_check_params_vs_input": {},
  "sklearn/sklearn.cluster._kmeans/_BaseKMeans/_warn_mkl_vcomp": {},
  "sklearn/sklearn.cluster._kmeans/_BaseKMeans/_check_mkl_vcomp": {},
  "sklearn/sklearn.cluster._kmeans/_BaseKMeans/_validate_center_shape": {},
  "sklearn/sklearn.cluster._kmeans/_BaseKMeans/_check_test_data": {},
  "sklearn/sklearn.cluster._kmeans/_BaseKMeans/_init_centroids": {},
  "sklearn/sklearn.cluster._kmeans/_BaseKMeans/fit_predict": {},
  "sklearn/sklearn.cluster._kmeans/_BaseKMeans/predict": {},
  "sklearn/sklearn.cluster._kmeans/_BaseKMeans/fit_transform": {},
  "sklearn/sklearn.cluster._kmeans/_BaseKMeans/transform": {},
  "sklearn/sklearn.cluster._kmeans/_BaseKMeans/_transform": {},
  "sklearn/sklearn.cluster._kmeans/_BaseKMeans/score": {},
  "sklearn/sklearn.cluster._kmeans/_BaseKMeans/_more_tags": {},
  "sklearn/sklearn.cluster._kmeans/KMeans/__init__": {
    "copy_x": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.cluster._kmeans/KMeans/__init__/copy_x",
          "name": "copy_x",
          "qname": "sklearn.cluster._kmeans.KMeans.__init__.copy_x",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "When pre-computing distances it is more numerically accurate to center\nthe data first. If copy_x is True (default), then the original data is\nnot modified. If False, the original data is modified, and put back\nbefore the function returns, but small numerical differences may be\nintroduced by subtracting and then adding the data mean. Note that if\nthe original data is not C-contiguous, a copy will be made even if\ncopy_x is False. If the original data is sparse, but not in CSR format,\na copy will be made even if copy_x is False."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.cluster._kmeans/KMeans/__init__/copy_x",
          "name": "copy_x",
          "qname": "sklearn.cluster._kmeans.KMeans.__init__.copy_x",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "When pre-computing distances it is more numerically accurate to center\nthe data first. If copy_x is True (default), then the original data is\nnot modified. If False, the original data is modified, and put back\nbefore the function returns, but small numerical differences may be\nintroduced by subtracting and then adding the data mean. Note that if\nthe original data is not C-contiguous, a copy will be made even if\ncopy_x is False. If the original data is sparse, but not in CSR format,\na copy will be made even if copy_x is False."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "If copy_x is True ( default )"
        },
        "hasAction": {
          "action": ", then the original data is not modified"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.cluster._kmeans/KMeans/__init__/copy_x",
          "name": "copy_x",
          "qname": "sklearn.cluster._kmeans.KMeans.__init__.copy_x",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "When pre-computing distances it is more numerically accurate to center\nthe data first. If copy_x is True (default), then the original data is\nnot modified. If False, the original data is modified, and put back\nbefore the function returns, but small numerical differences may be\nintroduced by subtracting and then adding the data mean. Note that if\nthe original data is not C-contiguous, a copy will be made even if\ncopy_x is False. If the original data is sparse, but not in CSR format,\na copy will be made even if copy_x is False."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.cluster._kmeans/KMeans/__init__/copy_x",
          "name": "copy_x",
          "qname": "sklearn.cluster._kmeans.KMeans.__init__.copy_x",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "When pre-computing distances it is more numerically accurate to center\nthe data first. If copy_x is True (default), then the original data is\nnot modified. If False, the original data is modified, and put back\nbefore the function returns, but small numerical differences may be\nintroduced by subtracting and then adding the data mean. Note that if\nthe original data is not C-contiguous, a copy will be made even if\ncopy_x is False. If the original data is sparse, but not in CSR format,\na copy will be made even if copy_x is False."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "even if copy_x is False"
        },
        "hasAction": {
          "action": "that if the original data is not C - contiguous , a copy will be made"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.cluster._kmeans/KMeans/__init__/copy_x",
          "name": "copy_x",
          "qname": "sklearn.cluster._kmeans.KMeans.__init__.copy_x",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "When pre-computing distances it is more numerically accurate to center\nthe data first. If copy_x is True (default), then the original data is\nnot modified. If False, the original data is modified, and put back\nbefore the function returns, but small numerical differences may be\nintroduced by subtracting and then adding the data mean. Note that if\nthe original data is not C-contiguous, a copy will be made even if\ncopy_x is False. If the original data is sparse, but not in CSR format,\na copy will be made even if copy_x is False."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.cluster._kmeans/KMeans/__init__/copy_x",
          "name": "copy_x",
          "qname": "sklearn.cluster._kmeans.KMeans.__init__.copy_x",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "When pre-computing distances it is more numerically accurate to center\nthe data first. If copy_x is True (default), then the original data is\nnot modified. If False, the original data is modified, and put back\nbefore the function returns, but small numerical differences may be\nintroduced by subtracting and then adding the data mean. Note that if\nthe original data is not C-contiguous, a copy will be made even if\ncopy_x is False. If the original data is sparse, but not in CSR format,\na copy will be made even if copy_x is False."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "even if copy_x is False"
        },
        "hasAction": {
          "action": "If the original data is sparse , but not in CSR format , a copy will be made"
        }
      }
    ]
  },
  "sklearn/sklearn.cluster._kmeans/KMeans/_check_params_vs_input": {},
  "sklearn/sklearn.cluster._kmeans/KMeans/_warn_mkl_vcomp": {},
  "sklearn/sklearn.cluster._kmeans/KMeans/fit": {},
  "sklearn/sklearn.cluster._kmeans/_mini_batch_step": {},
  "sklearn/sklearn.cluster._kmeans/MiniBatchKMeans/__init__": {},
  "sklearn/sklearn.cluster._kmeans/MiniBatchKMeans/_check_params_vs_input": {},
  "sklearn/sklearn.cluster._kmeans/MiniBatchKMeans/_warn_mkl_vcomp": {},
  "sklearn/sklearn.cluster._kmeans/MiniBatchKMeans/_mini_batch_convergence": {},
  "sklearn/sklearn.cluster._kmeans/MiniBatchKMeans/_random_reassign": {},
  "sklearn/sklearn.cluster._kmeans/MiniBatchKMeans/fit": {},
  "sklearn/sklearn.cluster._kmeans/MiniBatchKMeans/partial_fit": {},
  "sklearn/sklearn.cluster._mean_shift/estimate_bandwidth": {},
  "sklearn/sklearn.cluster._mean_shift/_mean_shift_single_seed": {},
  "sklearn/sklearn.cluster._mean_shift/mean_shift": {
    "bandwidth": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.cluster._mean_shift/mean_shift/bandwidth",
          "name": "bandwidth",
          "qname": "sklearn.cluster._mean_shift.mean_shift.bandwidth",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "None",
            "description": "Kernel bandwidth.\n\nIf bandwidth is not given, it is determined using a heuristic based on\nthe median of all pairwise distances. This will take quadratic time in\nthe number of samples. The sklearn.cluster.estimate_bandwidth function\ncan be used to do this more efficiently."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.cluster._mean_shift/mean_shift/bandwidth",
          "name": "bandwidth",
          "qname": "sklearn.cluster._mean_shift.mean_shift.bandwidth",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "None",
            "description": "Kernel bandwidth.\n\nIf bandwidth is not given, it is determined using a heuristic based on\nthe median of all pairwise distances. This will take quadratic time in\nthe number of samples. The sklearn.cluster.estimate_bandwidth function\ncan be used to do this more efficiently."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "hasCondition": {
          "condition": "If bandwidth is not given"
        },
        "hasAction": {
          "action": ", it is determined using a heuristic based on the median of all pairwise distances"
        }
      }
    ],
    "bin_seeding": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.cluster._mean_shift/mean_shift/bin_seeding",
          "name": "bin_seeding",
          "qname": "sklearn.cluster._mean_shift.mean_shift.bin_seeding",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "If true, initial kernel locations are not locations of all\npoints, but rather the location of the discretized version of\npoints, where points are binned onto a grid whose coarseness\ncorresponds to the bandwidth. Setting this option to True will speed\nup the algorithm because fewer seeds will be initialized.\nIgnored if seeds argument is not None."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.cluster._mean_shift/mean_shift/seeds",
          "name": "seeds",
          "qname": "sklearn.cluster._mean_shift.mean_shift.seeds",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "array-like of shape (n_seeds, n_features) or None",
            "default_value": "",
            "description": "Point used as initial kernel locations. If None and bin_seeding=False,\neach data point is used as a seed. If None and bin_seeding=True,\nsee bin_seeding."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of shape (n_seeds, n_features)"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "because fewer seeds will be initialized"
        },
        "hasAction": {
          "action": "Setting this option to True will speed up the algorithm"
        }
      }
    ]
  },
  "sklearn/sklearn.cluster._mean_shift/get_bin_seeds": {},
  "sklearn/sklearn.cluster._mean_shift/MeanShift/__init__": {
    "bin_seeding": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.cluster._mean_shift/MeanShift/__init__/bin_seeding",
          "name": "bin_seeding",
          "qname": "sklearn.cluster._mean_shift.MeanShift.__init__.bin_seeding",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "If true, initial kernel locations are not locations of all\npoints, but rather the location of the discretized version of\npoints, where points are binned onto a grid whose coarseness\ncorresponds to the bandwidth. Setting this option to True will speed\nup the algorithm because fewer seeds will be initialized.\nThe default value is False.\nIgnored if seeds argument is not None."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.cluster._mean_shift/MeanShift/__init__/seeds",
          "name": "seeds",
          "qname": "sklearn.cluster._mean_shift.MeanShift.__init__.seeds",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "array-like of shape (n_samples, n_features)",
            "default_value": "None",
            "description": "Seeds used to initialize kernels. If not set,\nthe seeds are calculated by clustering.get_bin_seeds\nwith bandwidth as the grid size and default values for\nother parameters."
          },
          "type": {
            "kind": "NamedType",
            "name": "array-like of shape (n_samples, n_features)"
          }
        },
        "hasCondition": {
          "condition": "because fewer seeds will be initialized"
        },
        "hasAction": {
          "action": "Setting this option to True will speed up the algorithm"
        }
      }
    ]
  },
  "sklearn/sklearn.cluster._mean_shift/MeanShift/fit": {},
  "sklearn/sklearn.cluster._mean_shift/MeanShift/predict": {},
  "sklearn/sklearn.cluster._optics/OPTICS/__init__": {
    "metric": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.cluster._optics/OPTICS/__init__/metric",
          "name": "metric",
          "qname": "sklearn.cluster._optics.OPTICS.__init__.metric",
          "default_value": "'minkowski'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'minkowski'",
            "description": "Metric to use for distance computation. Any metric from scikit-learn\nor scipy.spatial.distance can be used.\n\nIf metric is a callable function, it is called on each\npair of instances (rows) and the resulting value recorded. The callable\nshould take two arrays as input and return one value indicating the\ndistance between them. This works for Scipy's metrics, but is less\nefficient than passing the metric name as a string. If metric is\n\"precomputed\", `X` is assumed to be a distance matrix and must be\nsquare.\n\nValid values for metric are:\n\n- from scikit-learn: ['cityblock', 'cosine', 'euclidean', 'l1', 'l2',\n  'manhattan']\n\n- from scipy.spatial.distance: ['braycurtis', 'canberra', 'chebyshev',\n  'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski',\n  'mahalanobis', 'minkowski', 'rogerstanimoto', 'russellrao',\n  'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean',\n  'yule']\n\nSparse matrices are only supported by scikit-learn metrics.\nSee the documentation for scipy.spatial.distance for details on these\nmetrics."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.cluster._optics/OPTICS/__init__/metric",
          "name": "metric",
          "qname": "sklearn.cluster._optics.OPTICS.__init__.metric",
          "default_value": "'minkowski'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'minkowski'",
            "description": "Metric to use for distance computation. Any metric from scikit-learn\nor scipy.spatial.distance can be used.\n\nIf metric is a callable function, it is called on each\npair of instances (rows) and the resulting value recorded. The callable\nshould take two arrays as input and return one value indicating the\ndistance between them. This works for Scipy's metrics, but is less\nefficient than passing the metric name as a string. If metric is\n\"precomputed\", `X` is assumed to be a distance matrix and must be\nsquare.\n\nValid values for metric are:\n\n- from scikit-learn: ['cityblock', 'cosine', 'euclidean', 'l1', 'l2',\n  'manhattan']\n\n- from scipy.spatial.distance: ['braycurtis', 'canberra', 'chebyshev',\n  'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski',\n  'mahalanobis', 'minkowski', 'rogerstanimoto', 'russellrao',\n  'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean',\n  'yule']\n\nSparse matrices are only supported by scikit-learn metrics.\nSee the documentation for scipy.spatial.distance for details on these\nmetrics."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If metric is a callable function"
        },
        "hasAction": {
          "action": ", it is called on each pair of instances ( rows ) and the resulting value recorded"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.cluster._optics/OPTICS/__init__/metric",
          "name": "metric",
          "qname": "sklearn.cluster._optics.OPTICS.__init__.metric",
          "default_value": "'minkowski'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'minkowski'",
            "description": "Metric to use for distance computation. Any metric from scikit-learn\nor scipy.spatial.distance can be used.\n\nIf metric is a callable function, it is called on each\npair of instances (rows) and the resulting value recorded. The callable\nshould take two arrays as input and return one value indicating the\ndistance between them. This works for Scipy's metrics, but is less\nefficient than passing the metric name as a string. If metric is\n\"precomputed\", `X` is assumed to be a distance matrix and must be\nsquare.\n\nValid values for metric are:\n\n- from scikit-learn: ['cityblock', 'cosine', 'euclidean', 'l1', 'l2',\n  'manhattan']\n\n- from scipy.spatial.distance: ['braycurtis', 'canberra', 'chebyshev',\n  'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski',\n  'mahalanobis', 'minkowski', 'rogerstanimoto', 'russellrao',\n  'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean',\n  'yule']\n\nSparse matrices are only supported by scikit-learn metrics.\nSee the documentation for scipy.spatial.distance for details on these\nmetrics."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.cluster._optics/OPTICS/__init__/metric",
          "name": "metric",
          "qname": "sklearn.cluster._optics.OPTICS.__init__.metric",
          "default_value": "'minkowski'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'minkowski'",
            "description": "Metric to use for distance computation. Any metric from scikit-learn\nor scipy.spatial.distance can be used.\n\nIf metric is a callable function, it is called on each\npair of instances (rows) and the resulting value recorded. The callable\nshould take two arrays as input and return one value indicating the\ndistance between them. This works for Scipy's metrics, but is less\nefficient than passing the metric name as a string. If metric is\n\"precomputed\", `X` is assumed to be a distance matrix and must be\nsquare.\n\nValid values for metric are:\n\n- from scikit-learn: ['cityblock', 'cosine', 'euclidean', 'l1', 'l2',\n  'manhattan']\n\n- from scipy.spatial.distance: ['braycurtis', 'canberra', 'chebyshev',\n  'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski',\n  'mahalanobis', 'minkowski', 'rogerstanimoto', 'russellrao',\n  'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean',\n  'yule']\n\nSparse matrices are only supported by scikit-learn metrics.\nSee the documentation for scipy.spatial.distance for details on these\nmetrics."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If metric is precomputed"
        },
        "hasAction": {
          "action": ", X is assumed to be a distance matrix and must be square"
        }
      }
    ],
    "eps": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.cluster._optics/OPTICS/__init__/eps",
          "name": "eps",
          "qname": "sklearn.cluster._optics.OPTICS.__init__.eps",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "None",
            "description": "The maximum distance between two samples for one to be considered as\nin the neighborhood of the other. By default it assumes the same value\nas ``max_eps``.\nUsed only when ``cluster_method='dbscan'``."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.cluster._optics/OPTICS/__init__/cluster_method",
          "name": "cluster_method",
          "qname": "sklearn.cluster._optics.OPTICS.__init__.cluster_method",
          "default_value": "'xi'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "'xi'",
            "description": "The extraction method used to extract clusters using the calculated\nreachability and ordering. Possible values are \"xi\" and \"dbscan\"."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        "hasCondition": {
          "condition": "only when cluster_method equals dbscan"
        },
        "hasAction": {
          "action": "Used"
        }
      }
    ],
    "xi": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.cluster._optics/OPTICS/__init__/xi",
          "name": "xi",
          "qname": "sklearn.cluster._optics.OPTICS.__init__.xi",
          "default_value": "0.05",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float between 0 and 1",
            "default_value": "0.05",
            "description": "Determines the minimum steepness on the reachability plot that\nconstitutes a cluster boundary. For example, an upwards point in the\nreachability plot is defined by the ratio from one point to its\nsuccessor being at most 1-xi.\nUsed only when ``cluster_method='xi'``."
          },
          "type": {
            "kind": "NamedType",
            "name": "float between 0 and 1"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.cluster._optics/OPTICS/__init__/cluster_method",
          "name": "cluster_method",
          "qname": "sklearn.cluster._optics.OPTICS.__init__.cluster_method",
          "default_value": "'xi'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "'xi'",
            "description": "The extraction method used to extract clusters using the calculated\nreachability and ordering. Possible values are \"xi\" and \"dbscan\"."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        "hasCondition": {
          "condition": "only when cluster_method equals xi"
        },
        "hasAction": {
          "action": "Used"
        }
      }
    ],
    "predecessor_correction": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.cluster._optics/OPTICS/__init__/predecessor_correction",
          "name": "predecessor_correction",
          "qname": "sklearn.cluster._optics.OPTICS.__init__.predecessor_correction",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Correct clusters according to the predecessors calculated by OPTICS\n[2]_. This parameter has minimal effect on most datasets.\nUsed only when ``cluster_method='xi'``."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.cluster._optics/OPTICS/__init__/cluster_method",
          "name": "cluster_method",
          "qname": "sklearn.cluster._optics.OPTICS.__init__.cluster_method",
          "default_value": "'xi'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "'xi'",
            "description": "The extraction method used to extract clusters using the calculated\nreachability and ordering. Possible values are \"xi\" and \"dbscan\"."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        "hasCondition": {
          "condition": "only when cluster_method equals xi"
        },
        "hasAction": {
          "action": "Used"
        }
      }
    ],
    "min_cluster_size": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.cluster._optics/OPTICS/__init__/min_cluster_size",
          "name": "min_cluster_size",
          "qname": "sklearn.cluster._optics.OPTICS.__init__.min_cluster_size",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int > 1 or float between 0 and 1",
            "default_value": "None",
            "description": "Minimum number of samples in an OPTICS cluster, expressed as an\nabsolute number or a fraction of the number of samples (rounded to be\nat least 2). If ``None``, the value of ``min_samples`` is used instead.\nUsed only when ``cluster_method='xi'``."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int > 1"
              },
              {
                "kind": "NamedType",
                "name": "float between 0 and 1"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.cluster._optics/OPTICS/__init__/cluster_method",
          "name": "cluster_method",
          "qname": "sklearn.cluster._optics.OPTICS.__init__.cluster_method",
          "default_value": "'xi'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "'xi'",
            "description": "The extraction method used to extract clusters using the calculated\nreachability and ordering. Possible values are \"xi\" and \"dbscan\"."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        "hasCondition": {
          "condition": "only when cluster_method equals xi"
        },
        "hasAction": {
          "action": "Used"
        }
      }
    ]
  },
  "sklearn/sklearn.cluster._optics/OPTICS/fit": {},
  "sklearn/sklearn.cluster._optics/_validate_size": {},
  "sklearn/sklearn.cluster._optics/_compute_core_distances_": {},
  "sklearn/sklearn.cluster._optics/compute_optics_graph": {
    "metric": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.cluster._optics/compute_optics_graph/metric",
          "name": "metric",
          "qname": "sklearn.cluster._optics.compute_optics_graph.metric",
          "default_value": null,
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'minkowski'",
            "description": "Metric to use for distance computation. Any metric from scikit-learn\nor scipy.spatial.distance can be used.\n\nIf metric is a callable function, it is called on each\npair of instances (rows) and the resulting value recorded. The callable\nshould take two arrays as input and return one value indicating the\ndistance between them. This works for Scipy's metrics, but is less\nefficient than passing the metric name as a string. If metric is\n\"precomputed\", X is assumed to be a distance matrix and must be square.\n\nValid values for metric are:\n\n- from scikit-learn: ['cityblock', 'cosine', 'euclidean', 'l1', 'l2',\n  'manhattan']\n\n- from scipy.spatial.distance: ['braycurtis', 'canberra', 'chebyshev',\n  'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski',\n  'mahalanobis', 'minkowski', 'rogerstanimoto', 'russellrao',\n  'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean',\n  'yule']\n\nSee the documentation for scipy.spatial.distance for details on these\nmetrics."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.cluster._optics/compute_optics_graph/metric",
          "name": "metric",
          "qname": "sklearn.cluster._optics.compute_optics_graph.metric",
          "default_value": null,
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'minkowski'",
            "description": "Metric to use for distance computation. Any metric from scikit-learn\nor scipy.spatial.distance can be used.\n\nIf metric is a callable function, it is called on each\npair of instances (rows) and the resulting value recorded. The callable\nshould take two arrays as input and return one value indicating the\ndistance between them. This works for Scipy's metrics, but is less\nefficient than passing the metric name as a string. If metric is\n\"precomputed\", X is assumed to be a distance matrix and must be square.\n\nValid values for metric are:\n\n- from scikit-learn: ['cityblock', 'cosine', 'euclidean', 'l1', 'l2',\n  'manhattan']\n\n- from scipy.spatial.distance: ['braycurtis', 'canberra', 'chebyshev',\n  'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski',\n  'mahalanobis', 'minkowski', 'rogerstanimoto', 'russellrao',\n  'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean',\n  'yule']\n\nSee the documentation for scipy.spatial.distance for details on these\nmetrics."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If metric is a callable function"
        },
        "hasAction": {
          "action": ", it is called on each pair of instances ( rows ) and the resulting value recorded"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.cluster._optics/compute_optics_graph/metric",
          "name": "metric",
          "qname": "sklearn.cluster._optics.compute_optics_graph.metric",
          "default_value": null,
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'minkowski'",
            "description": "Metric to use for distance computation. Any metric from scikit-learn\nor scipy.spatial.distance can be used.\n\nIf metric is a callable function, it is called on each\npair of instances (rows) and the resulting value recorded. The callable\nshould take two arrays as input and return one value indicating the\ndistance between them. This works for Scipy's metrics, but is less\nefficient than passing the metric name as a string. If metric is\n\"precomputed\", X is assumed to be a distance matrix and must be square.\n\nValid values for metric are:\n\n- from scikit-learn: ['cityblock', 'cosine', 'euclidean', 'l1', 'l2',\n  'manhattan']\n\n- from scipy.spatial.distance: ['braycurtis', 'canberra', 'chebyshev',\n  'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski',\n  'mahalanobis', 'minkowski', 'rogerstanimoto', 'russellrao',\n  'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean',\n  'yule']\n\nSee the documentation for scipy.spatial.distance for details on these\nmetrics."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.cluster._optics/compute_optics_graph/metric",
          "name": "metric",
          "qname": "sklearn.cluster._optics.compute_optics_graph.metric",
          "default_value": null,
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'minkowski'",
            "description": "Metric to use for distance computation. Any metric from scikit-learn\nor scipy.spatial.distance can be used.\n\nIf metric is a callable function, it is called on each\npair of instances (rows) and the resulting value recorded. The callable\nshould take two arrays as input and return one value indicating the\ndistance between them. This works for Scipy's metrics, but is less\nefficient than passing the metric name as a string. If metric is\n\"precomputed\", X is assumed to be a distance matrix and must be square.\n\nValid values for metric are:\n\n- from scikit-learn: ['cityblock', 'cosine', 'euclidean', 'l1', 'l2',\n  'manhattan']\n\n- from scipy.spatial.distance: ['braycurtis', 'canberra', 'chebyshev',\n  'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski',\n  'mahalanobis', 'minkowski', 'rogerstanimoto', 'russellrao',\n  'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean',\n  'yule']\n\nSee the documentation for scipy.spatial.distance for details on these\nmetrics."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If metric is precomputed"
        },
        "hasAction": {
          "action": ", X is assumed to be a distance matrix and must be square"
        }
      }
    ]
  },
  "sklearn/sklearn.cluster._optics/_set_reach_dist": {},
  "sklearn/sklearn.cluster._optics/cluster_optics_dbscan": {},
  "sklearn/sklearn.cluster._optics/cluster_optics_xi": {},
  "sklearn/sklearn.cluster._optics/_extend_region": {},
  "sklearn/sklearn.cluster._optics/_update_filter_sdas": {},
  "sklearn/sklearn.cluster._optics/_correct_predecessor": {},
  "sklearn/sklearn.cluster._optics/_xi_cluster": {},
  "sklearn/sklearn.cluster._optics/_extract_xi_labels": {},
  "sklearn/sklearn.cluster._spectral/cluster_qr": {},
  "sklearn/sklearn.cluster._spectral/discretize": {},
  "sklearn/sklearn.cluster._spectral/spectral_clustering": {
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.cluster._spectral/spectral_clustering/random_state",
          "name": "random_state",
          "qname": "sklearn.cluster._spectral.spectral_clustering.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance",
            "default_value": "None",
            "description": "A pseudo random number generator used for the initialization\nof the lobpcg eigenvectors decomposition when `eigen_solver ==\n'amg'`, and for the K-Means initialization. Use an int to make\nthe results deterministic across calls (See\n:term:`Glossary <random_state>`).\n\n.. note::\n    When using `eigen_solver == 'amg'`,\n    it is necessary to also fix the global numpy seed with\n    `np.random.seed(int)` to get deterministic results. See\n    https://github.com/pyamg/pyamg/issues/139 for further\n    information."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.cluster._spectral/spectral_clustering/eigen_solver",
          "name": "eigen_solver",
          "qname": "sklearn.cluster._spectral.spectral_clustering.eigen_solver",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{None, 'arpack', 'lobpcg', or 'amg'}",
            "default_value": "",
            "description": "The eigenvalue decomposition method. If None then ``'arpack'`` is used.\nSee [4]_ for more details regarding ``'lobpcg'``.\nEigensolver ``'amg'`` runs ``'lobpcg'`` with optional\nAlgebraic MultiGrid preconditioning and requires pyamg to be installed.\nIt can be faster on very large sparse problems [6]_ and [7]_."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "amg",
              "arpack",
              "lobpcg"
            ]
          }
        },
        "hasCondition": {
          "condition": "when eigen_solver equals amg"
        },
        "hasAction": {
          "action": "used for the initialization of the lobpcg eigenvectors decomposition"
        }
      }
    ],
    "n_init": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.cluster._spectral/spectral_clustering/n_init",
          "name": "n_init",
          "qname": "sklearn.cluster._spectral.spectral_clustering.n_init",
          "default_value": "10",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "10",
            "description": "Number of time the k-means algorithm will be run with different\ncentroid seeds. The final results will be the best output of n_init\nconsecutive runs in terms of inertia. Only used if\n``assign_labels='kmeans'``."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.cluster._spectral/spectral_clustering/assign_labels",
          "name": "assign_labels",
          "qname": "sklearn.cluster._spectral.spectral_clustering.assign_labels",
          "default_value": "'kmeans'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'kmeans', 'discretize', 'cluster_qr'}",
            "default_value": "'kmeans'",
            "description": "The strategy to use to assign labels in the embedding\nspace.  There are three ways to assign labels after the Laplacian\nembedding.  k-means can be applied and is a popular choice. But it can\nalso be sensitive to initialization. Discretization is another\napproach which is less sensitive to random initialization [3]_.\nThe cluster_qr method [5]_ directly extracts clusters from eigenvectors\nin spectral clustering. In contrast to k-means and discretization, cluster_qr\nhas no tuning parameters and is not an iterative method, yet may outperform\nk-means and discretization in terms of both quality and speed.\n\n.. versionchanged:: 1.1\n   Added new labeling method 'cluster_qr'."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "cluster_qr",
              "discretize",
              "kmeans"
            ]
          }
        },
        "hasCondition": {
          "condition": "if assign_labels equals kmeans"
        },
        "hasAction": {
          "action": "Only used"
        }
      }
    ],
    "eigen_tol": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.cluster._spectral/spectral_clustering/eigen_tol",
          "name": "eigen_tol",
          "qname": "sklearn.cluster._spectral.spectral_clustering.eigen_tol",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "\"auto\"",
            "description": "Stopping criterion for eigendecomposition of the Laplacian matrix.\nIf `eigen_tol=\"auto\"` then the passed tolerance will depend on the\n`eigen_solver`:\n\n- If `eigen_solver=\"arpack\"`, then `eigen_tol=0.0`;\n- If `eigen_solver=\"lobpcg\"` or `eigen_solver=\"amg\"`, then\n  `eigen_tol=None` which configures the underlying `lobpcg` solver to\n  automatically resolve the value according to their heuristics. See,\n  :func:`scipy.sparse.linalg.lobpcg` for details.\n\nNote that when using `eigen_solver=\"lobpcg\"` or `eigen_solver=\"amg\"`\nvalues of `tol<1e-5` may lead to convergence issues and should be\navoided.\n\n.. versionadded:: 1.2\n   Added 'auto' option."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.cluster._spectral/spectral_clustering/eigen_tol",
          "name": "eigen_tol",
          "qname": "sklearn.cluster._spectral.spectral_clustering.eigen_tol",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "\"auto\"",
            "description": "Stopping criterion for eigendecomposition of the Laplacian matrix.\nIf `eigen_tol=\"auto\"` then the passed tolerance will depend on the\n`eigen_solver`:\n\n- If `eigen_solver=\"arpack\"`, then `eigen_tol=0.0`;\n- If `eigen_solver=\"lobpcg\"` or `eigen_solver=\"amg\"`, then\n  `eigen_tol=None` which configures the underlying `lobpcg` solver to\n  automatically resolve the value according to their heuristics. See,\n  :func:`scipy.sparse.linalg.lobpcg` for details.\n\nNote that when using `eigen_solver=\"lobpcg\"` or `eigen_solver=\"amg\"`\nvalues of `tol<1e-5` may lead to convergence issues and should be\navoided.\n\n.. versionadded:: 1.2\n   Added 'auto' option."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "hasCondition": {
          "condition": "If eigen_tol equals auto"
        },
        "hasAction": {
          "action": "then the passed tolerance will depend on the eigen_solver : -"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.cluster._spectral/spectral_clustering/eigen_tol",
          "name": "eigen_tol",
          "qname": "sklearn.cluster._spectral.spectral_clustering.eigen_tol",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "\"auto\"",
            "description": "Stopping criterion for eigendecomposition of the Laplacian matrix.\nIf `eigen_tol=\"auto\"` then the passed tolerance will depend on the\n`eigen_solver`:\n\n- If `eigen_solver=\"arpack\"`, then `eigen_tol=0.0`;\n- If `eigen_solver=\"lobpcg\"` or `eigen_solver=\"amg\"`, then\n  `eigen_tol=None` which configures the underlying `lobpcg` solver to\n  automatically resolve the value according to their heuristics. See,\n  :func:`scipy.sparse.linalg.lobpcg` for details.\n\nNote that when using `eigen_solver=\"lobpcg\"` or `eigen_solver=\"amg\"`\nvalues of `tol<1e-5` may lead to convergence issues and should be\navoided.\n\n.. versionadded:: 1.2\n   Added 'auto' option."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.cluster._spectral/spectral_clustering/eigen_solver",
          "name": "eigen_solver",
          "qname": "sklearn.cluster._spectral.spectral_clustering.eigen_solver",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{None, 'arpack', 'lobpcg', or 'amg'}",
            "default_value": "",
            "description": "The eigenvalue decomposition method. If None then ``'arpack'`` is used.\nSee [4]_ for more details regarding ``'lobpcg'``.\nEigensolver ``'amg'`` runs ``'lobpcg'`` with optional\nAlgebraic MultiGrid preconditioning and requires pyamg to be installed.\nIt can be faster on very large sparse problems [6]_ and [7]_."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "amg",
              "arpack",
              "lobpcg"
            ]
          }
        },
        "hasCondition": {
          "condition": "If eigen_solver equals arpack"
        },
        "hasAction": {
          "action": "If eigen_tol equals auto then the passed tolerance will depend on the eigen_solver : - , then eigen_tol equals 0.0 ; - If eigen_solver equals lobpcg or eigen_solver equals amg"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.cluster._spectral/spectral_clustering/eigen_tol",
          "name": "eigen_tol",
          "qname": "sklearn.cluster._spectral.spectral_clustering.eigen_tol",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "\"auto\"",
            "description": "Stopping criterion for eigendecomposition of the Laplacian matrix.\nIf `eigen_tol=\"auto\"` then the passed tolerance will depend on the\n`eigen_solver`:\n\n- If `eigen_solver=\"arpack\"`, then `eigen_tol=0.0`;\n- If `eigen_solver=\"lobpcg\"` or `eigen_solver=\"amg\"`, then\n  `eigen_tol=None` which configures the underlying `lobpcg` solver to\n  automatically resolve the value according to their heuristics. See,\n  :func:`scipy.sparse.linalg.lobpcg` for details.\n\nNote that when using `eigen_solver=\"lobpcg\"` or `eigen_solver=\"amg\"`\nvalues of `tol<1e-5` may lead to convergence issues and should be\navoided.\n\n.. versionadded:: 1.2\n   Added 'auto' option."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.cluster._spectral/spectral_clustering/eigen_solver",
          "name": "eigen_solver",
          "qname": "sklearn.cluster._spectral.spectral_clustering.eigen_solver",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{None, 'arpack', 'lobpcg', or 'amg'}",
            "default_value": "",
            "description": "The eigenvalue decomposition method. If None then ``'arpack'`` is used.\nSee [4]_ for more details regarding ``'lobpcg'``.\nEigensolver ``'amg'`` runs ``'lobpcg'`` with optional\nAlgebraic MultiGrid preconditioning and requires pyamg to be installed.\nIt can be faster on very large sparse problems [6]_ and [7]_."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "amg",
              "arpack",
              "lobpcg"
            ]
          }
        },
        "hasCondition": {
          "condition": "If eigen_solver equals lobpcg or eigen_solver"
        },
        "hasAction": {
          "action": "equals amg"
        }
      }
    ]
  },
  "sklearn/sklearn.cluster._spectral/SpectralClustering/__init__": {
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.cluster._spectral/SpectralClustering/__init__/random_state",
          "name": "random_state",
          "qname": "sklearn.cluster._spectral.SpectralClustering.__init__.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance",
            "default_value": "None",
            "description": "A pseudo random number generator used for the initialization\nof the lobpcg eigenvectors decomposition when `eigen_solver ==\n'amg'`, and for the K-Means initialization. Use an int to make\nthe results deterministic across calls (See\n:term:`Glossary <random_state>`).\n\n.. note::\n    When using `eigen_solver == 'amg'`,\n    it is necessary to also fix the global numpy seed with\n    `np.random.seed(int)` to get deterministic results. See\n    https://github.com/pyamg/pyamg/issues/139 for further\n    information."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.cluster._spectral/SpectralClustering/__init__/eigen_solver",
          "name": "eigen_solver",
          "qname": "sklearn.cluster._spectral.SpectralClustering.__init__.eigen_solver",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'arpack', 'lobpcg', 'amg'}",
            "default_value": "None",
            "description": "The eigenvalue decomposition strategy to use. AMG requires pyamg\nto be installed. It can be faster on very large, sparse problems,\nbut may also lead to instabilities. If None, then ``'arpack'`` is\nused. See [4]_ for more details regarding `'lobpcg'`."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "amg",
              "arpack",
              "lobpcg"
            ]
          }
        },
        "hasCondition": {
          "condition": "when eigen_solver equals amg"
        },
        "hasAction": {
          "action": "used for the initialization of the lobpcg eigenvectors decomposition"
        }
      }
    ],
    "n_init": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.cluster._spectral/SpectralClustering/__init__/n_init",
          "name": "n_init",
          "qname": "sklearn.cluster._spectral.SpectralClustering.__init__.n_init",
          "default_value": "10",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "10",
            "description": "Number of time the k-means algorithm will be run with different\ncentroid seeds. The final results will be the best output of n_init\nconsecutive runs in terms of inertia. Only used if\n``assign_labels='kmeans'``."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.cluster._spectral/SpectralClustering/__init__/assign_labels",
          "name": "assign_labels",
          "qname": "sklearn.cluster._spectral.SpectralClustering.__init__.assign_labels",
          "default_value": "'kmeans'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'kmeans', 'discretize', 'cluster_qr'}",
            "default_value": "'kmeans'",
            "description": "The strategy for assigning labels in the embedding space. There are two\nways to assign labels after the Laplacian embedding. k-means is a\npopular choice, but it can be sensitive to initialization.\nDiscretization is another approach which is less sensitive to random\ninitialization [3]_.\nThe cluster_qr method [5]_ directly extract clusters from eigenvectors\nin spectral clustering. In contrast to k-means and discretization, cluster_qr\nhas no tuning parameters and runs no iterations, yet may outperform\nk-means and discretization in terms of both quality and speed.\n\n.. versionchanged:: 1.1\n   Added new labeling method 'cluster_qr'."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "cluster_qr",
              "discretize",
              "kmeans"
            ]
          }
        },
        "hasCondition": {
          "condition": "if assign_labels equals kmeans"
        },
        "hasAction": {
          "action": "Only used"
        }
      }
    ],
    "eigen_tol": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.cluster._spectral/SpectralClustering/__init__/eigen_tol",
          "name": "eigen_tol",
          "qname": "sklearn.cluster._spectral.SpectralClustering.__init__.eigen_tol",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "\"auto\"",
            "description": "Stopping criterion for eigendecomposition of the Laplacian matrix.\nIf `eigen_tol=\"auto\"` then the passed tolerance will depend on the\n`eigen_solver`:\n\n- If `eigen_solver=\"arpack\"`, then `eigen_tol=0.0`;\n- If `eigen_solver=\"lobpcg\"` or `eigen_solver=\"amg\"`, then\n  `eigen_tol=None` which configures the underlying `lobpcg` solver to\n  automatically resolve the value according to their heuristics. See,\n  :func:`scipy.sparse.linalg.lobpcg` for details.\n\nNote that when using `eigen_solver=\"lobpcg\"` or `eigen_solver=\"amg\"`\nvalues of `tol<1e-5` may lead to convergence issues and should be\navoided.\n\n.. versionadded:: 1.2\n   Added 'auto' option."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.cluster._spectral/SpectralClustering/__init__/eigen_tol",
          "name": "eigen_tol",
          "qname": "sklearn.cluster._spectral.SpectralClustering.__init__.eigen_tol",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "\"auto\"",
            "description": "Stopping criterion for eigendecomposition of the Laplacian matrix.\nIf `eigen_tol=\"auto\"` then the passed tolerance will depend on the\n`eigen_solver`:\n\n- If `eigen_solver=\"arpack\"`, then `eigen_tol=0.0`;\n- If `eigen_solver=\"lobpcg\"` or `eigen_solver=\"amg\"`, then\n  `eigen_tol=None` which configures the underlying `lobpcg` solver to\n  automatically resolve the value according to their heuristics. See,\n  :func:`scipy.sparse.linalg.lobpcg` for details.\n\nNote that when using `eigen_solver=\"lobpcg\"` or `eigen_solver=\"amg\"`\nvalues of `tol<1e-5` may lead to convergence issues and should be\navoided.\n\n.. versionadded:: 1.2\n   Added 'auto' option."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "hasCondition": {
          "condition": "If eigen_tol equals auto"
        },
        "hasAction": {
          "action": "then the passed tolerance will depend on the eigen_solver : -"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.cluster._spectral/SpectralClustering/__init__/eigen_tol",
          "name": "eigen_tol",
          "qname": "sklearn.cluster._spectral.SpectralClustering.__init__.eigen_tol",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "\"auto\"",
            "description": "Stopping criterion for eigendecomposition of the Laplacian matrix.\nIf `eigen_tol=\"auto\"` then the passed tolerance will depend on the\n`eigen_solver`:\n\n- If `eigen_solver=\"arpack\"`, then `eigen_tol=0.0`;\n- If `eigen_solver=\"lobpcg\"` or `eigen_solver=\"amg\"`, then\n  `eigen_tol=None` which configures the underlying `lobpcg` solver to\n  automatically resolve the value according to their heuristics. See,\n  :func:`scipy.sparse.linalg.lobpcg` for details.\n\nNote that when using `eigen_solver=\"lobpcg\"` or `eigen_solver=\"amg\"`\nvalues of `tol<1e-5` may lead to convergence issues and should be\navoided.\n\n.. versionadded:: 1.2\n   Added 'auto' option."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.cluster._spectral/SpectralClustering/__init__/eigen_solver",
          "name": "eigen_solver",
          "qname": "sklearn.cluster._spectral.SpectralClustering.__init__.eigen_solver",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'arpack', 'lobpcg', 'amg'}",
            "default_value": "None",
            "description": "The eigenvalue decomposition strategy to use. AMG requires pyamg\nto be installed. It can be faster on very large, sparse problems,\nbut may also lead to instabilities. If None, then ``'arpack'`` is\nused. See [4]_ for more details regarding `'lobpcg'`."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "amg",
              "arpack",
              "lobpcg"
            ]
          }
        },
        "hasCondition": {
          "condition": "If eigen_solver equals arpack"
        },
        "hasAction": {
          "action": "If eigen_tol equals auto then the passed tolerance will depend on the eigen_solver : - , then eigen_tol equals 0.0 ; - If eigen_solver equals lobpcg or eigen_solver equals amg"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.cluster._spectral/SpectralClustering/__init__/eigen_tol",
          "name": "eigen_tol",
          "qname": "sklearn.cluster._spectral.SpectralClustering.__init__.eigen_tol",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "\"auto\"",
            "description": "Stopping criterion for eigendecomposition of the Laplacian matrix.\nIf `eigen_tol=\"auto\"` then the passed tolerance will depend on the\n`eigen_solver`:\n\n- If `eigen_solver=\"arpack\"`, then `eigen_tol=0.0`;\n- If `eigen_solver=\"lobpcg\"` or `eigen_solver=\"amg\"`, then\n  `eigen_tol=None` which configures the underlying `lobpcg` solver to\n  automatically resolve the value according to their heuristics. See,\n  :func:`scipy.sparse.linalg.lobpcg` for details.\n\nNote that when using `eigen_solver=\"lobpcg\"` or `eigen_solver=\"amg\"`\nvalues of `tol<1e-5` may lead to convergence issues and should be\navoided.\n\n.. versionadded:: 1.2\n   Added 'auto' option."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.cluster._spectral/SpectralClustering/__init__/eigen_solver",
          "name": "eigen_solver",
          "qname": "sklearn.cluster._spectral.SpectralClustering.__init__.eigen_solver",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'arpack', 'lobpcg', 'amg'}",
            "default_value": "None",
            "description": "The eigenvalue decomposition strategy to use. AMG requires pyamg\nto be installed. It can be faster on very large, sparse problems,\nbut may also lead to instabilities. If None, then ``'arpack'`` is\nused. See [4]_ for more details regarding `'lobpcg'`."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "amg",
              "arpack",
              "lobpcg"
            ]
          }
        },
        "hasCondition": {
          "condition": "If eigen_solver equals lobpcg or eigen_solver"
        },
        "hasAction": {
          "action": "equals amg"
        }
      }
    ],
    "n_jobs": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.cluster._spectral/SpectralClustering/__init__/n_jobs",
          "name": "n_jobs",
          "qname": "sklearn.cluster._spectral.SpectralClustering.__init__.n_jobs",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "None",
            "description": "The number of parallel jobs to run when `affinity='nearest_neighbors'`\nor `affinity='precomputed_nearest_neighbors'`. The neighbors search\nwill be done in parallel.\n``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n``-1`` means using all processors. See :term:`Glossary <n_jobs>`\nfor more details."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.cluster._spectral/SpectralClustering/__init__/affinity",
          "name": "affinity",
          "qname": "sklearn.cluster._spectral.SpectralClustering.__init__.affinity",
          "default_value": "'rbf'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'rbf'",
            "description": "How to construct the affinity matrix.\n - 'nearest_neighbors': construct the affinity matrix by computing a\n   graph of nearest neighbors.\n - 'rbf': construct the affinity matrix using a radial basis function\n   (RBF) kernel.\n - 'precomputed': interpret ``X`` as a precomputed affinity matrix,\n   where larger values indicate greater similarity between instances.\n - 'precomputed_nearest_neighbors': interpret ``X`` as a sparse graph\n   of precomputed distances, and construct a binary affinity matrix\n   from the ``n_neighbors`` nearest neighbors of each instance.\n - one of the kernels supported by\n   :func:`~sklearn.metrics.pairwise_kernels`.\n\nOnly kernels that produce similarity scores (non-negative values that\nincrease with similarity) should be used. This property is not checked\nby the clustering algorithm."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "when affinity equals nearest_neighbors or affinity"
        },
        "hasAction": {
          "action": "to run"
        }
      }
    ]
  },
  "sklearn/sklearn.cluster._spectral/SpectralClustering/fit": {},
  "sklearn/sklearn.cluster._spectral/SpectralClustering/fit_predict": {},
  "sklearn/sklearn.cluster._spectral/SpectralClustering/_more_tags": {},
  "sklearn/sklearn.compose._column_transformer/ColumnTransformer/__init__": {},
  "sklearn/sklearn.compose._column_transformer/ColumnTransformer/_transformers@getter": {},
  "sklearn/sklearn.compose._column_transformer/ColumnTransformer/_transformers@setter": {},
  "sklearn/sklearn.compose._column_transformer/ColumnTransformer/set_output": {},
  "sklearn/sklearn.compose._column_transformer/ColumnTransformer/get_params": {},
  "sklearn/sklearn.compose._column_transformer/ColumnTransformer/set_params": {},
  "sklearn/sklearn.compose._column_transformer/ColumnTransformer/_iter": {},
  "sklearn/sklearn.compose._column_transformer/ColumnTransformer/_validate_transformers": {},
  "sklearn/sklearn.compose._column_transformer/ColumnTransformer/_validate_column_callables": {},
  "sklearn/sklearn.compose._column_transformer/ColumnTransformer/_validate_remainder": {},
  "sklearn/sklearn.compose._column_transformer/ColumnTransformer/named_transformers_@getter": {},
  "sklearn/sklearn.compose._column_transformer/ColumnTransformer/_get_feature_name_out_for_transformer": {},
  "sklearn/sklearn.compose._column_transformer/ColumnTransformer/get_feature_names_out": {
    "input_features": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.compose._column_transformer/ColumnTransformer/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.compose._column_transformer.ColumnTransformer.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features.\n\n- If `input_features` is `None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then the following input feature names are generated:\n  `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.compose._column_transformer/ColumnTransformer/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.compose._column_transformer.ColumnTransformer.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features.\n\n- If `input_features` is `None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then the following input feature names are generated:\n  `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If input_features is None , then feature_names_in _"
        },
        "hasAction": {
          "action": "is used as feature names in"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.compose._column_transformer/ColumnTransformer/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.compose._column_transformer.ColumnTransformer.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features.\n\n- If `input_features` is `None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then the following input feature names are generated:\n  `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.compose._column_transformer/ColumnTransformer/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.compose._column_transformer.ColumnTransformer.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features.\n\n- If `input_features` is `None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then the following input feature names are generated:\n  `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If input_features is"
        },
        "hasAction": {
          "action": "an array - like , then input_features must match feature_names_in _"
        }
      }
    ]
  },
  "sklearn/sklearn.compose._column_transformer/ColumnTransformer/_add_prefix_for_feature_names_out": {},
  "sklearn/sklearn.compose._column_transformer/ColumnTransformer/_update_fitted_transformers": {},
  "sklearn/sklearn.compose._column_transformer/ColumnTransformer/_validate_output": {},
  "sklearn/sklearn.compose._column_transformer/ColumnTransformer/_record_output_indices": {},
  "sklearn/sklearn.compose._column_transformer/ColumnTransformer/_log_message": {},
  "sklearn/sklearn.compose._column_transformer/ColumnTransformer/_fit_transform": {},
  "sklearn/sklearn.compose._column_transformer/ColumnTransformer/fit": {},
  "sklearn/sklearn.compose._column_transformer/ColumnTransformer/fit_transform": {},
  "sklearn/sklearn.compose._column_transformer/ColumnTransformer/transform": {},
  "sklearn/sklearn.compose._column_transformer/ColumnTransformer/_hstack": {},
  "sklearn/sklearn.compose._column_transformer/ColumnTransformer/_sk_visual_block_": {},
  "sklearn/sklearn.compose._column_transformer/_check_X": {},
  "sklearn/sklearn.compose._column_transformer/_is_empty_column_selection": {},
  "sklearn/sklearn.compose._column_transformer/_get_transformer_list": {},
  "sklearn/sklearn.compose._column_transformer/make_column_transformer": {},
  "sklearn/sklearn.compose._column_transformer/make_column_selector/__init__": {},
  "sklearn/sklearn.compose._column_transformer/make_column_selector/__call__": {},
  "sklearn/sklearn.compose._target/TransformedTargetRegressor/__init__": {},
  "sklearn/sklearn.compose._target/TransformedTargetRegressor/_fit_transformer": {},
  "sklearn/sklearn.compose._target/TransformedTargetRegressor/fit": {},
  "sklearn/sklearn.compose._target/TransformedTargetRegressor/predict": {},
  "sklearn/sklearn.compose._target/TransformedTargetRegressor/_more_tags": {},
  "sklearn/sklearn.compose._target/TransformedTargetRegressor/n_features_in_@getter": {},
  "sklearn/sklearn.covariance._elliptic_envelope/EllipticEnvelope/__init__": {},
  "sklearn/sklearn.covariance._elliptic_envelope/EllipticEnvelope/fit": {},
  "sklearn/sklearn.covariance._elliptic_envelope/EllipticEnvelope/decision_function": {},
  "sklearn/sklearn.covariance._elliptic_envelope/EllipticEnvelope/score_samples": {},
  "sklearn/sklearn.covariance._elliptic_envelope/EllipticEnvelope/predict": {},
  "sklearn/sklearn.covariance._elliptic_envelope/EllipticEnvelope/score": {},
  "sklearn/sklearn.covariance._empirical_covariance/log_likelihood": {},
  "sklearn/sklearn.covariance._empirical_covariance/empirical_covariance": {},
  "sklearn/sklearn.covariance._empirical_covariance/EmpiricalCovariance/__init__": {},
  "sklearn/sklearn.covariance._empirical_covariance/EmpiricalCovariance/_set_covariance": {},
  "sklearn/sklearn.covariance._empirical_covariance/EmpiricalCovariance/get_precision": {},
  "sklearn/sklearn.covariance._empirical_covariance/EmpiricalCovariance/fit": {},
  "sklearn/sklearn.covariance._empirical_covariance/EmpiricalCovariance/score": {},
  "sklearn/sklearn.covariance._empirical_covariance/EmpiricalCovariance/error_norm": {},
  "sklearn/sklearn.covariance._empirical_covariance/EmpiricalCovariance/mahalanobis": {},
  "sklearn/sklearn.covariance._graph_lasso/_objective": {},
  "sklearn/sklearn.covariance._graph_lasso/_dual_gap": {},
  "sklearn/sklearn.covariance._graph_lasso/alpha_max": {},
  "sklearn/sklearn.covariance._graph_lasso/graphical_lasso": {
    "verbose": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.covariance._graph_lasso/graphical_lasso/verbose",
          "name": "verbose",
          "qname": "sklearn.covariance._graph_lasso.graphical_lasso.verbose",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "If verbose is True, the objective function and dual gap are\nprinted at each iteration."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.covariance._graph_lasso/graphical_lasso/verbose",
          "name": "verbose",
          "qname": "sklearn.covariance._graph_lasso.graphical_lasso.verbose",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "If verbose is True, the objective function and dual gap are\nprinted at each iteration."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "If verbose is True"
        },
        "hasAction": {
          "action": ", the objective function and dual gap are printed at each iteration"
        }
      }
    ],
    "return_costs": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.covariance._graph_lasso/graphical_lasso/return_costs",
          "name": "return_costs",
          "qname": "sklearn.covariance._graph_lasso.graphical_lasso.return_costs",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "If return_costs is True, the objective function and dual gap\nat each iteration are returned."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.covariance._graph_lasso/graphical_lasso/return_costs",
          "name": "return_costs",
          "qname": "sklearn.covariance._graph_lasso.graphical_lasso.return_costs",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "If return_costs is True, the objective function and dual gap\nat each iteration are returned."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "If return_costs is True"
        },
        "hasAction": {
          "action": ", the objective function and dual gap at each iteration are returned"
        }
      }
    ]
  },
  "sklearn/sklearn.covariance._graph_lasso/BaseGraphicalLasso/__init__": {},
  "sklearn/sklearn.covariance._graph_lasso/GraphicalLasso/__init__": {
    "verbose": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.covariance._graph_lasso/GraphicalLasso/__init__/verbose",
          "name": "verbose",
          "qname": "sklearn.covariance._graph_lasso.GraphicalLasso.__init__.verbose",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "If verbose is True, the objective function and dual gap are\nplotted at each iteration."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.covariance._graph_lasso/GraphicalLasso/__init__/verbose",
          "name": "verbose",
          "qname": "sklearn.covariance._graph_lasso.GraphicalLasso.__init__.verbose",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "If verbose is True, the objective function and dual gap are\nplotted at each iteration."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "If verbose is True"
        },
        "hasAction": {
          "action": ", the objective function and dual gap are plotted at each iteration"
        }
      }
    ]
  },
  "sklearn/sklearn.covariance._graph_lasso/GraphicalLasso/fit": {},
  "sklearn/sklearn.covariance._graph_lasso/graphical_lasso_path": {},
  "sklearn/sklearn.covariance._graph_lasso/GraphicalLassoCV/__init__": {
    "verbose": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.covariance._graph_lasso/GraphicalLassoCV/__init__/verbose",
          "name": "verbose",
          "qname": "sklearn.covariance._graph_lasso.GraphicalLassoCV.__init__.verbose",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "If verbose is True, the objective function and duality gap are\nprinted at each iteration."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.covariance._graph_lasso/GraphicalLassoCV/__init__/verbose",
          "name": "verbose",
          "qname": "sklearn.covariance._graph_lasso.GraphicalLassoCV.__init__.verbose",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "If verbose is True, the objective function and duality gap are\nprinted at each iteration."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "If verbose is True"
        },
        "hasAction": {
          "action": ", the objective function and duality gap are printed at each iteration"
        }
      }
    ]
  },
  "sklearn/sklearn.covariance._graph_lasso/GraphicalLassoCV/fit": {},
  "sklearn/sklearn.covariance._robust_covariance/c_step": {},
  "sklearn/sklearn.covariance._robust_covariance/_c_step": {},
  "sklearn/sklearn.covariance._robust_covariance/select_candidates": {},
  "sklearn/sklearn.covariance._robust_covariance/fast_mcd": {},
  "sklearn/sklearn.covariance._robust_covariance/MinCovDet/__init__": {},
  "sklearn/sklearn.covariance._robust_covariance/MinCovDet/fit": {},
  "sklearn/sklearn.covariance._robust_covariance/MinCovDet/correct_covariance": {},
  "sklearn/sklearn.covariance._robust_covariance/MinCovDet/reweight_covariance": {},
  "sklearn/sklearn.covariance._shrunk_covariance/shrunk_covariance": {},
  "sklearn/sklearn.covariance._shrunk_covariance/ShrunkCovariance/__init__": {},
  "sklearn/sklearn.covariance._shrunk_covariance/ShrunkCovariance/fit": {},
  "sklearn/sklearn.covariance._shrunk_covariance/ledoit_wolf_shrinkage": {},
  "sklearn/sklearn.covariance._shrunk_covariance/ledoit_wolf": {},
  "sklearn/sklearn.covariance._shrunk_covariance/LedoitWolf/__init__": {},
  "sklearn/sklearn.covariance._shrunk_covariance/LedoitWolf/fit": {},
  "sklearn/sklearn.covariance._shrunk_covariance/oas": {},
  "sklearn/sklearn.covariance._shrunk_covariance/OAS/fit": {},
  "sklearn/sklearn.cross_decomposition._pls/_pinv2_old": {},
  "sklearn/sklearn.cross_decomposition._pls/_get_first_singular_vectors_power_method": {},
  "sklearn/sklearn.cross_decomposition._pls/_get_first_singular_vectors_svd": {},
  "sklearn/sklearn.cross_decomposition._pls/_center_scale_xy": {},
  "sklearn/sklearn.cross_decomposition._pls/_svd_flip_1d": {},
  "sklearn/sklearn.cross_decomposition._pls/_PLS/__init__": {},
  "sklearn/sklearn.cross_decomposition._pls/_PLS/fit": {},
  "sklearn/sklearn.cross_decomposition._pls/_PLS/transform": {},
  "sklearn/sklearn.cross_decomposition._pls/_PLS/inverse_transform": {},
  "sklearn/sklearn.cross_decomposition._pls/_PLS/predict": {},
  "sklearn/sklearn.cross_decomposition._pls/_PLS/fit_transform": {},
  "sklearn/sklearn.cross_decomposition._pls/_PLS/coef_@getter": {},
  "sklearn/sklearn.cross_decomposition._pls/_PLS/_more_tags": {},
  "sklearn/sklearn.cross_decomposition._pls/PLSRegression/__init__": {},
  "sklearn/sklearn.cross_decomposition._pls/PLSRegression/fit": {},
  "sklearn/sklearn.cross_decomposition._pls/PLSCanonical/__init__": {},
  "sklearn/sklearn.cross_decomposition._pls/CCA/__init__": {},
  "sklearn/sklearn.cross_decomposition._pls/PLSSVD/__init__": {},
  "sklearn/sklearn.cross_decomposition._pls/PLSSVD/fit": {},
  "sklearn/sklearn.cross_decomposition._pls/PLSSVD/transform": {},
  "sklearn/sklearn.cross_decomposition._pls/PLSSVD/fit_transform": {},
  "sklearn/sklearn.decomposition._base/_BasePCA/get_covariance": {},
  "sklearn/sklearn.decomposition._base/_BasePCA/get_precision": {},
  "sklearn/sklearn.decomposition._base/_BasePCA/fit": {},
  "sklearn/sklearn.decomposition._base/_BasePCA/transform": {},
  "sklearn/sklearn.decomposition._base/_BasePCA/inverse_transform": {},
  "sklearn/sklearn.decomposition._base/_BasePCA/_n_features_out@getter": {},
  "sklearn/sklearn.decomposition._dict_learning/_check_positive_coding": {},
  "sklearn/sklearn.decomposition._dict_learning/_sparse_encode": {
    "regularization": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._dict_learning/_sparse_encode/regularization",
          "name": "regularization",
          "qname": "sklearn.decomposition._dict_learning._sparse_encode.regularization",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "int or float",
            "default_value": "None",
            "description": "The regularization parameter. It corresponds to alpha when\nalgorithm is `'lasso_lars'`, `'lasso_cd'` or `'threshold'`.\nOtherwise it corresponds to `n_nonzero_coefs`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "float"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._dict_learning/_sparse_encode/algorithm",
          "name": "algorithm",
          "qname": "sklearn.decomposition._dict_learning._sparse_encode.algorithm",
          "default_value": "'lasso_lars'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "{'lasso_lars', 'lasso_cd', 'lars', 'omp', 'threshold'}",
            "default_value": "'lasso_lars'",
            "description": "The algorithm used:\n\n* `'lars'`: uses the least angle regression method\n  (`linear_model.lars_path`);\n* `'lasso_lars'`: uses Lars to compute the Lasso solution;\n* `'lasso_cd'`: uses the coordinate descent method to compute the\n  Lasso solution (`linear_model.Lasso`). lasso_lars will be faster if\n  the estimated components are sparse;\n* `'omp'`: uses orthogonal matching pursuit to estimate the sparse\n  solution;\n* `'threshold'`: squashes to zero all coefficients less than\n  regularization from the projection `dictionary * data'`."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "lars",
              "omp",
              "lasso_cd",
              "threshold",
              "lasso_lars"
            ]
          }
        },
        "hasCondition": {
          "condition": "when algorithm is lasso_lars , lasso_cd or threshold"
        },
        "hasAction": {
          "action": "It corresponds to alpha"
        }
      }
    ],
    "init": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._dict_learning/_sparse_encode/init",
          "name": "init",
          "qname": "sklearn.decomposition._dict_learning._sparse_encode.init",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "ndarray of shape (n_samples, n_components)",
            "default_value": "None",
            "description": "Initialization value of the sparse code. Only used if\n`algorithm='lasso_cd'`."
          },
          "type": {
            "kind": "NamedType",
            "name": "ndarray of shape (n_samples, n_components)"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._dict_learning/_sparse_encode/algorithm",
          "name": "algorithm",
          "qname": "sklearn.decomposition._dict_learning._sparse_encode.algorithm",
          "default_value": "'lasso_lars'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "{'lasso_lars', 'lasso_cd', 'lars', 'omp', 'threshold'}",
            "default_value": "'lasso_lars'",
            "description": "The algorithm used:\n\n* `'lars'`: uses the least angle regression method\n  (`linear_model.lars_path`);\n* `'lasso_lars'`: uses Lars to compute the Lasso solution;\n* `'lasso_cd'`: uses the coordinate descent method to compute the\n  Lasso solution (`linear_model.Lasso`). lasso_lars will be faster if\n  the estimated components are sparse;\n* `'omp'`: uses orthogonal matching pursuit to estimate the sparse\n  solution;\n* `'threshold'`: squashes to zero all coefficients less than\n  regularization from the projection `dictionary * data'`."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "lars",
              "omp",
              "lasso_cd",
              "threshold",
              "lasso_lars"
            ]
          }
        },
        "hasCondition": {
          "condition": "if algorithm equals lasso_cd"
        },
        "hasAction": {
          "action": "Only used"
        }
      }
    ],
    "max_iter": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._dict_learning/_sparse_encode/max_iter",
          "name": "max_iter",
          "qname": "sklearn.decomposition._dict_learning._sparse_encode.max_iter",
          "default_value": "1000",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "int",
            "default_value": "1000",
            "description": "Maximum number of iterations to perform if `algorithm='lasso_cd'` or\n`'lasso_lars'`."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._dict_learning/_sparse_encode/algorithm",
          "name": "algorithm",
          "qname": "sklearn.decomposition._dict_learning._sparse_encode.algorithm",
          "default_value": "'lasso_lars'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "{'lasso_lars', 'lasso_cd', 'lars', 'omp', 'threshold'}",
            "default_value": "'lasso_lars'",
            "description": "The algorithm used:\n\n* `'lars'`: uses the least angle regression method\n  (`linear_model.lars_path`);\n* `'lasso_lars'`: uses Lars to compute the Lasso solution;\n* `'lasso_cd'`: uses the coordinate descent method to compute the\n  Lasso solution (`linear_model.Lasso`). lasso_lars will be faster if\n  the estimated components are sparse;\n* `'omp'`: uses orthogonal matching pursuit to estimate the sparse\n  solution;\n* `'threshold'`: squashes to zero all coefficients less than\n  regularization from the projection `dictionary * data'`."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "lars",
              "omp",
              "lasso_cd",
              "threshold",
              "lasso_lars"
            ]
          }
        },
        "hasCondition": {
          "condition": "if algorithm equals lasso_cd or lasso_lars"
        },
        "hasAction": {
          "action": "to perform"
        }
      }
    ]
  },
  "sklearn/sklearn.decomposition._dict_learning/sparse_encode": {
    "alpha": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._dict_learning/sparse_encode/alpha",
          "name": "alpha",
          "qname": "sklearn.decomposition._dict_learning.sparse_encode.alpha",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "None",
            "description": "If `algorithm='lasso_lars'` or `algorithm='lasso_cd'`, `alpha` is the\npenalty applied to the L1 norm.\nIf `algorithm='threshold'`, `alpha` is the absolute value of the\nthreshold below which coefficients will be squashed to zero.\nIf `algorithm='omp'`, `alpha` is the tolerance parameter: the value of\nthe reconstruction error targeted. In this case, it overrides\n`n_nonzero_coefs`.\nIf `None`, default to 1."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._dict_learning/sparse_encode/algorithm",
          "name": "algorithm",
          "qname": "sklearn.decomposition._dict_learning.sparse_encode.algorithm",
          "default_value": "'lasso_lars'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'lasso_lars', 'lasso_cd', 'lars', 'omp', 'threshold'}",
            "default_value": "'lasso_lars'",
            "description": "The algorithm used:\n\n* `'lars'`: uses the least angle regression method\n  (`linear_model.lars_path`);\n* `'lasso_lars'`: uses Lars to compute the Lasso solution;\n* `'lasso_cd'`: uses the coordinate descent method to compute the\n  Lasso solution (`linear_model.Lasso`). lasso_lars will be faster if\n  the estimated components are sparse;\n* `'omp'`: uses orthogonal matching pursuit to estimate the sparse\n  solution;\n* `'threshold'`: squashes to zero all coefficients less than\n  regularization from the projection `dictionary * data'`."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "lars",
              "omp",
              "lasso_cd",
              "threshold",
              "lasso_lars"
            ]
          }
        },
        "hasCondition": {
          "condition": "If algorithm equals lasso_lars or algorithm"
        },
        "hasAction": {
          "action": "equals lasso_cd"
        }
      }
    ],
    "init": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._dict_learning/sparse_encode/init",
          "name": "init",
          "qname": "sklearn.decomposition._dict_learning.sparse_encode.init",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "ndarray of shape (n_samples, n_components)",
            "default_value": "None",
            "description": "Initialization value of the sparse codes. Only used if\n`algorithm='lasso_cd'`."
          },
          "type": {
            "kind": "NamedType",
            "name": "ndarray of shape (n_samples, n_components)"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._dict_learning/sparse_encode/algorithm",
          "name": "algorithm",
          "qname": "sklearn.decomposition._dict_learning.sparse_encode.algorithm",
          "default_value": "'lasso_lars'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'lasso_lars', 'lasso_cd', 'lars', 'omp', 'threshold'}",
            "default_value": "'lasso_lars'",
            "description": "The algorithm used:\n\n* `'lars'`: uses the least angle regression method\n  (`linear_model.lars_path`);\n* `'lasso_lars'`: uses Lars to compute the Lasso solution;\n* `'lasso_cd'`: uses the coordinate descent method to compute the\n  Lasso solution (`linear_model.Lasso`). lasso_lars will be faster if\n  the estimated components are sparse;\n* `'omp'`: uses orthogonal matching pursuit to estimate the sparse\n  solution;\n* `'threshold'`: squashes to zero all coefficients less than\n  regularization from the projection `dictionary * data'`."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "lars",
              "omp",
              "lasso_cd",
              "threshold",
              "lasso_lars"
            ]
          }
        },
        "hasCondition": {
          "condition": "if algorithm equals lasso_cd"
        },
        "hasAction": {
          "action": "Only used"
        }
      }
    ],
    "max_iter": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._dict_learning/sparse_encode/max_iter",
          "name": "max_iter",
          "qname": "sklearn.decomposition._dict_learning.sparse_encode.max_iter",
          "default_value": "1000",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "1000",
            "description": "Maximum number of iterations to perform if `algorithm='lasso_cd'` or\n`'lasso_lars'`."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._dict_learning/sparse_encode/algorithm",
          "name": "algorithm",
          "qname": "sklearn.decomposition._dict_learning.sparse_encode.algorithm",
          "default_value": "'lasso_lars'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'lasso_lars', 'lasso_cd', 'lars', 'omp', 'threshold'}",
            "default_value": "'lasso_lars'",
            "description": "The algorithm used:\n\n* `'lars'`: uses the least angle regression method\n  (`linear_model.lars_path`);\n* `'lasso_lars'`: uses Lars to compute the Lasso solution;\n* `'lasso_cd'`: uses the coordinate descent method to compute the\n  Lasso solution (`linear_model.Lasso`). lasso_lars will be faster if\n  the estimated components are sparse;\n* `'omp'`: uses orthogonal matching pursuit to estimate the sparse\n  solution;\n* `'threshold'`: squashes to zero all coefficients less than\n  regularization from the projection `dictionary * data'`."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "lars",
              "omp",
              "lasso_cd",
              "threshold",
              "lasso_lars"
            ]
          }
        },
        "hasCondition": {
          "condition": "if algorithm equals lasso_cd or lasso_lars"
        },
        "hasAction": {
          "action": "to perform"
        }
      }
    ]
  },
  "sklearn/sklearn.decomposition._dict_learning/_update_dict": {},
  "sklearn/sklearn.decomposition._dict_learning/dict_learning": {
    "dict_init": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._dict_learning/dict_learning/dict_init",
          "name": "dict_init",
          "qname": "sklearn.decomposition._dict_learning.dict_learning.dict_init",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "ndarray of shape (n_components, n_features)",
            "default_value": "None",
            "description": "Initial value for the dictionary for warm restart scenarios. Only used\nif `code_init` and `dict_init` are not None."
          },
          "type": {
            "kind": "NamedType",
            "name": "ndarray of shape (n_components, n_features)"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._dict_learning/dict_learning/code_init",
          "name": "code_init",
          "qname": "sklearn.decomposition._dict_learning.dict_learning.code_init",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "ndarray of shape (n_samples, n_components)",
            "default_value": "None",
            "description": "Initial value for the sparse code for warm restart scenarios. Only used\nif `code_init` and `dict_init` are not None."
          },
          "type": {
            "kind": "NamedType",
            "name": "ndarray of shape (n_samples, n_components)"
          }
        },
        "hasCondition": {
          "condition": "if code_init and dict_init are not None"
        },
        "hasAction": {
          "action": "Only used"
        }
      }
    ],
    "code_init": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._dict_learning/dict_learning/code_init",
          "name": "code_init",
          "qname": "sklearn.decomposition._dict_learning.dict_learning.code_init",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "ndarray of shape (n_samples, n_components)",
            "default_value": "None",
            "description": "Initial value for the sparse code for warm restart scenarios. Only used\nif `code_init` and `dict_init` are not None."
          },
          "type": {
            "kind": "NamedType",
            "name": "ndarray of shape (n_samples, n_components)"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._dict_learning/dict_learning/code_init",
          "name": "code_init",
          "qname": "sklearn.decomposition._dict_learning.dict_learning.code_init",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "ndarray of shape (n_samples, n_components)",
            "default_value": "None",
            "description": "Initial value for the sparse code for warm restart scenarios. Only used\nif `code_init` and `dict_init` are not None."
          },
          "type": {
            "kind": "NamedType",
            "name": "ndarray of shape (n_samples, n_components)"
          }
        },
        "hasCondition": {
          "condition": "if code_init and dict_init are not None"
        },
        "hasAction": {
          "action": "Only used"
        }
      }
    ]
  },
  "sklearn/sklearn.decomposition._dict_learning/_check_warn_deprecated": {},
  "sklearn/sklearn.decomposition._dict_learning/dict_learning_online": {
    "max_iter": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._dict_learning/dict_learning_online/max_iter",
          "name": "max_iter",
          "qname": "sklearn.decomposition._dict_learning.dict_learning_online.max_iter",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "None",
            "description": "Maximum number of iterations over the complete dataset before\nstopping independently of any early stopping criterion heuristics.\nIf ``max_iter`` is not None, ``n_iter`` is ignored.\n\n.. versionadded:: 1.1"
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._dict_learning/dict_learning_online/max_iter",
          "name": "max_iter",
          "qname": "sklearn.decomposition._dict_learning.dict_learning_online.max_iter",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "None",
            "description": "Maximum number of iterations over the complete dataset before\nstopping independently of any early stopping criterion heuristics.\nIf ``max_iter`` is not None, ``n_iter`` is ignored.\n\n.. versionadded:: 1.1"
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "hasCondition": {
          "condition": "If max_iter is not None"
        },
        "hasAction": {
          "action": ", n_iter is ignored . .."
        }
      }
    ],
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._dict_learning/dict_learning_online/random_state",
          "name": "random_state",
          "qname": "sklearn.decomposition._dict_learning.dict_learning_online.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance or None",
            "default_value": "None",
            "description": "Used for initializing the dictionary when ``dict_init`` is not\nspecified, randomly shuffling the data when ``shuffle`` is set to\n``True``, and updating the dictionary. Pass an int for reproducible\nresults across multiple function calls.\nSee :term:`Glossary <random_state>`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._dict_learning/dict_learning_online/dict_init",
          "name": "dict_init",
          "qname": "sklearn.decomposition._dict_learning.dict_learning_online.dict_init",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "ndarray of shape (n_components, n_features)",
            "default_value": "None",
            "description": "Initial values for the dictionary for warm restart scenarios.\nIf `None`, the initial values for the dictionary are created\nwith an SVD decomposition of the data via :func:`~sklearn.utils.randomized_svd`."
          },
          "type": {
            "kind": "NamedType",
            "name": "ndarray of shape (n_components, n_features)"
          }
        },
        "hasCondition": {
          "condition": "when dict_init is not specified"
        },
        "hasAction": {
          "action": "initializing the dictionary"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._dict_learning/dict_learning_online/random_state",
          "name": "random_state",
          "qname": "sklearn.decomposition._dict_learning.dict_learning_online.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance or None",
            "default_value": "None",
            "description": "Used for initializing the dictionary when ``dict_init`` is not\nspecified, randomly shuffling the data when ``shuffle`` is set to\n``True``, and updating the dictionary. Pass an int for reproducible\nresults across multiple function calls.\nSee :term:`Glossary <random_state>`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._dict_learning/dict_learning_online/shuffle",
          "name": "shuffle",
          "qname": "sklearn.decomposition._dict_learning.dict_learning_online.shuffle",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Whether to shuffle the data before splitting it in batches."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "when shuffle is set to True"
        },
        "hasAction": {
          "action": "randomly shuffling the data , and updating the dictionary"
        }
      }
    ],
    "return_inner_stats": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._dict_learning/dict_learning_online/return_inner_stats",
          "name": "return_inner_stats",
          "qname": "sklearn.decomposition._dict_learning.dict_learning_online.return_inner_stats",
          "default_value": "'deprecated'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "Return the inner statistics A (dictionary covariance) and B\n(data approximation). Useful to restart the algorithm in an\nonline setting. If `return_inner_stats` is `True`, `return_code` is\nignored.\n\n.. deprecated:: 1.1\n   `return_inner_stats` serves internal purpose only and will be removed in 1.3."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._dict_learning/dict_learning_online/return_inner_stats",
          "name": "return_inner_stats",
          "qname": "sklearn.decomposition._dict_learning.dict_learning_online.return_inner_stats",
          "default_value": "'deprecated'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "Return the inner statistics A (dictionary covariance) and B\n(data approximation). Useful to restart the algorithm in an\nonline setting. If `return_inner_stats` is `True`, `return_code` is\nignored.\n\n.. deprecated:: 1.1\n   `return_inner_stats` serves internal purpose only and will be removed in 1.3."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "If return_inner_stats is True"
        },
        "hasAction": {
          "action": ", return_code is ignored"
        }
      }
    ],
    "tol": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._dict_learning/dict_learning_online/tol",
          "name": "tol",
          "qname": "sklearn.decomposition._dict_learning.dict_learning_online.tol",
          "default_value": "0.001",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "1e-3",
            "description": "Control early stopping based on the norm of the differences in the\ndictionary between 2 steps. Used only if `max_iter` is not None.\n\nTo disable early stopping based on changes in the dictionary, set\n`tol` to 0.0.\n\n.. versionadded:: 1.1"
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._dict_learning/dict_learning_online/max_iter",
          "name": "max_iter",
          "qname": "sklearn.decomposition._dict_learning.dict_learning_online.max_iter",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "None",
            "description": "Maximum number of iterations over the complete dataset before\nstopping independently of any early stopping criterion heuristics.\nIf ``max_iter`` is not None, ``n_iter`` is ignored.\n\n.. versionadded:: 1.1"
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "hasCondition": {
          "condition": "only if max_iter is not None"
        },
        "hasAction": {
          "action": "Used"
        }
      }
    ],
    "max_no_improvement": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._dict_learning/dict_learning_online/max_no_improvement",
          "name": "max_no_improvement",
          "qname": "sklearn.decomposition._dict_learning.dict_learning_online.max_no_improvement",
          "default_value": "10",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "10",
            "description": "Control early stopping based on the consecutive number of mini batches\nthat does not yield an improvement on the smoothed cost function. Used only if\n`max_iter` is not None.\n\nTo disable convergence detection based on cost function, set\n`max_no_improvement` to None.\n\n.. versionadded:: 1.1"
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._dict_learning/dict_learning_online/max_iter",
          "name": "max_iter",
          "qname": "sklearn.decomposition._dict_learning.dict_learning_online.max_iter",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "None",
            "description": "Maximum number of iterations over the complete dataset before\nstopping independently of any early stopping criterion heuristics.\nIf ``max_iter`` is not None, ``n_iter`` is ignored.\n\n.. versionadded:: 1.1"
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "hasCondition": {
          "condition": "only if max_iter is not None"
        },
        "hasAction": {
          "action": "Used"
        }
      }
    ]
  },
  "sklearn/sklearn.decomposition._dict_learning/_BaseSparseCoding/__init__": {},
  "sklearn/sklearn.decomposition._dict_learning/_BaseSparseCoding/_transform": {},
  "sklearn/sklearn.decomposition._dict_learning/_BaseSparseCoding/transform": {},
  "sklearn/sklearn.decomposition._dict_learning/SparseCoder/__init__": {},
  "sklearn/sklearn.decomposition._dict_learning/SparseCoder/fit": {},
  "sklearn/sklearn.decomposition._dict_learning/SparseCoder/transform": {},
  "sklearn/sklearn.decomposition._dict_learning/SparseCoder/_more_tags": {},
  "sklearn/sklearn.decomposition._dict_learning/SparseCoder/n_components_@getter": {},
  "sklearn/sklearn.decomposition._dict_learning/SparseCoder/n_features_in_@getter": {},
  "sklearn/sklearn.decomposition._dict_learning/SparseCoder/_n_features_out@getter": {},
  "sklearn/sklearn.decomposition._dict_learning/DictionaryLearning/__init__": {
    "code_init": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._dict_learning/DictionaryLearning/__init__/code_init",
          "name": "code_init",
          "qname": "sklearn.decomposition._dict_learning.DictionaryLearning.__init__.code_init",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "ndarray of shape (n_samples, n_components)",
            "default_value": "None",
            "description": "Initial value for the code, for warm restart. Only used if `code_init`\nand `dict_init` are not None."
          },
          "type": {
            "kind": "NamedType",
            "name": "ndarray of shape (n_samples, n_components)"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._dict_learning/DictionaryLearning/__init__/code_init",
          "name": "code_init",
          "qname": "sklearn.decomposition._dict_learning.DictionaryLearning.__init__.code_init",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "ndarray of shape (n_samples, n_components)",
            "default_value": "None",
            "description": "Initial value for the code, for warm restart. Only used if `code_init`\nand `dict_init` are not None."
          },
          "type": {
            "kind": "NamedType",
            "name": "ndarray of shape (n_samples, n_components)"
          }
        },
        "hasCondition": {
          "condition": "if code_init and dict_init are not None"
        },
        "hasAction": {
          "action": "Only used"
        }
      }
    ],
    "dict_init": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._dict_learning/DictionaryLearning/__init__/dict_init",
          "name": "dict_init",
          "qname": "sklearn.decomposition._dict_learning.DictionaryLearning.__init__.dict_init",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "ndarray of shape (n_components, n_features)",
            "default_value": "None",
            "description": "Initial values for the dictionary, for warm restart. Only used if\n`code_init` and `dict_init` are not None."
          },
          "type": {
            "kind": "NamedType",
            "name": "ndarray of shape (n_components, n_features)"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._dict_learning/DictionaryLearning/__init__/code_init",
          "name": "code_init",
          "qname": "sklearn.decomposition._dict_learning.DictionaryLearning.__init__.code_init",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "ndarray of shape (n_samples, n_components)",
            "default_value": "None",
            "description": "Initial value for the code, for warm restart. Only used if `code_init`\nand `dict_init` are not None."
          },
          "type": {
            "kind": "NamedType",
            "name": "ndarray of shape (n_samples, n_components)"
          }
        },
        "hasCondition": {
          "condition": "if code_init and dict_init are not None"
        },
        "hasAction": {
          "action": "Only used"
        }
      }
    ],
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._dict_learning/DictionaryLearning/__init__/random_state",
          "name": "random_state",
          "qname": "sklearn.decomposition._dict_learning.DictionaryLearning.__init__.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance or None",
            "default_value": "None",
            "description": "Used for initializing the dictionary when ``dict_init`` is not\nspecified, randomly shuffling the data when ``shuffle`` is set to\n``True``, and updating the dictionary. Pass an int for reproducible\nresults across multiple function calls.\nSee :term:`Glossary <random_state>`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._dict_learning/DictionaryLearning/__init__/dict_init",
          "name": "dict_init",
          "qname": "sklearn.decomposition._dict_learning.DictionaryLearning.__init__.dict_init",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "ndarray of shape (n_components, n_features)",
            "default_value": "None",
            "description": "Initial values for the dictionary, for warm restart. Only used if\n`code_init` and `dict_init` are not None."
          },
          "type": {
            "kind": "NamedType",
            "name": "ndarray of shape (n_components, n_features)"
          }
        },
        "hasCondition": {
          "condition": "when dict_init is not specified"
        },
        "hasAction": {
          "action": "initializing the dictionary"
        }
      }
    ]
  },
  "sklearn/sklearn.decomposition._dict_learning/DictionaryLearning/fit": {},
  "sklearn/sklearn.decomposition._dict_learning/DictionaryLearning/_n_features_out@getter": {},
  "sklearn/sklearn.decomposition._dict_learning/DictionaryLearning/_more_tags": {},
  "sklearn/sklearn.decomposition._dict_learning/MiniBatchDictionaryLearning/__init__": {
    "max_iter": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._dict_learning/MiniBatchDictionaryLearning/__init__/max_iter",
          "name": "max_iter",
          "qname": "sklearn.decomposition._dict_learning.MiniBatchDictionaryLearning.__init__.max_iter",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "None",
            "description": "Maximum number of iterations over the complete dataset before\nstopping independently of any early stopping criterion heuristics.\nIf ``max_iter`` is not None, ``n_iter`` is ignored.\n\n.. versionadded:: 1.1"
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._dict_learning/MiniBatchDictionaryLearning/__init__/max_iter",
          "name": "max_iter",
          "qname": "sklearn.decomposition._dict_learning.MiniBatchDictionaryLearning.__init__.max_iter",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "None",
            "description": "Maximum number of iterations over the complete dataset before\nstopping independently of any early stopping criterion heuristics.\nIf ``max_iter`` is not None, ``n_iter`` is ignored.\n\n.. versionadded:: 1.1"
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "hasCondition": {
          "condition": "If max_iter is not None"
        },
        "hasAction": {
          "action": ", n_iter is ignored . .."
        }
      }
    ],
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._dict_learning/MiniBatchDictionaryLearning/__init__/random_state",
          "name": "random_state",
          "qname": "sklearn.decomposition._dict_learning.MiniBatchDictionaryLearning.__init__.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance or None",
            "default_value": "None",
            "description": "Used for initializing the dictionary when ``dict_init`` is not\nspecified, randomly shuffling the data when ``shuffle`` is set to\n``True``, and updating the dictionary. Pass an int for reproducible\nresults across multiple function calls.\nSee :term:`Glossary <random_state>`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._dict_learning/MiniBatchDictionaryLearning/__init__/dict_init",
          "name": "dict_init",
          "qname": "sklearn.decomposition._dict_learning.MiniBatchDictionaryLearning.__init__.dict_init",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "ndarray of shape (n_components, n_features)",
            "default_value": "None",
            "description": "Initial value of the dictionary for warm restart scenarios."
          },
          "type": {
            "kind": "NamedType",
            "name": "ndarray of shape (n_components, n_features)"
          }
        },
        "hasCondition": {
          "condition": "when dict_init is not specified"
        },
        "hasAction": {
          "action": "initializing the dictionary"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._dict_learning/MiniBatchDictionaryLearning/__init__/random_state",
          "name": "random_state",
          "qname": "sklearn.decomposition._dict_learning.MiniBatchDictionaryLearning.__init__.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance or None",
            "default_value": "None",
            "description": "Used for initializing the dictionary when ``dict_init`` is not\nspecified, randomly shuffling the data when ``shuffle`` is set to\n``True``, and updating the dictionary. Pass an int for reproducible\nresults across multiple function calls.\nSee :term:`Glossary <random_state>`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._dict_learning/MiniBatchDictionaryLearning/__init__/shuffle",
          "name": "shuffle",
          "qname": "sklearn.decomposition._dict_learning.MiniBatchDictionaryLearning.__init__.shuffle",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Whether to shuffle the samples before forming batches."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "when shuffle is set to True"
        },
        "hasAction": {
          "action": "randomly shuffling the data , and updating the dictionary"
        }
      }
    ],
    "tol": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._dict_learning/MiniBatchDictionaryLearning/__init__/tol",
          "name": "tol",
          "qname": "sklearn.decomposition._dict_learning.MiniBatchDictionaryLearning.__init__.tol",
          "default_value": "0.001",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "1e-3",
            "description": "Control early stopping based on the norm of the differences in the\ndictionary between 2 steps. Used only if `max_iter` is not None.\n\nTo disable early stopping based on changes in the dictionary, set\n`tol` to 0.0.\n\n.. versionadded:: 1.1"
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._dict_learning/MiniBatchDictionaryLearning/__init__/max_iter",
          "name": "max_iter",
          "qname": "sklearn.decomposition._dict_learning.MiniBatchDictionaryLearning.__init__.max_iter",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "None",
            "description": "Maximum number of iterations over the complete dataset before\nstopping independently of any early stopping criterion heuristics.\nIf ``max_iter`` is not None, ``n_iter`` is ignored.\n\n.. versionadded:: 1.1"
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "hasCondition": {
          "condition": "only if max_iter is not None"
        },
        "hasAction": {
          "action": "Used"
        }
      }
    ],
    "max_no_improvement": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._dict_learning/MiniBatchDictionaryLearning/__init__/max_no_improvement",
          "name": "max_no_improvement",
          "qname": "sklearn.decomposition._dict_learning.MiniBatchDictionaryLearning.__init__.max_no_improvement",
          "default_value": "10",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "10",
            "description": "Control early stopping based on the consecutive number of mini batches\nthat does not yield an improvement on the smoothed cost function. Used only if\n`max_iter` is not None.\n\nTo disable convergence detection based on cost function, set\n`max_no_improvement` to None.\n\n.. versionadded:: 1.1"
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._dict_learning/MiniBatchDictionaryLearning/__init__/max_iter",
          "name": "max_iter",
          "qname": "sklearn.decomposition._dict_learning.MiniBatchDictionaryLearning.__init__.max_iter",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "None",
            "description": "Maximum number of iterations over the complete dataset before\nstopping independently of any early stopping criterion heuristics.\nIf ``max_iter`` is not None, ``n_iter`` is ignored.\n\n.. versionadded:: 1.1"
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "hasCondition": {
          "condition": "only if max_iter is not None"
        },
        "hasAction": {
          "action": "Used"
        }
      }
    ]
  },
  "sklearn/sklearn.decomposition._dict_learning/MiniBatchDictionaryLearning/iter_offset_@getter": {},
  "sklearn/sklearn.decomposition._dict_learning/MiniBatchDictionaryLearning/random_state_@getter": {},
  "sklearn/sklearn.decomposition._dict_learning/MiniBatchDictionaryLearning/inner_stats_@getter": {},
  "sklearn/sklearn.decomposition._dict_learning/MiniBatchDictionaryLearning/_check_params": {},
  "sklearn/sklearn.decomposition._dict_learning/MiniBatchDictionaryLearning/_initialize_dict": {},
  "sklearn/sklearn.decomposition._dict_learning/MiniBatchDictionaryLearning/_update_inner_stats": {},
  "sklearn/sklearn.decomposition._dict_learning/MiniBatchDictionaryLearning/_minibatch_step": {},
  "sklearn/sklearn.decomposition._dict_learning/MiniBatchDictionaryLearning/_check_convergence": {},
  "sklearn/sklearn.decomposition._dict_learning/MiniBatchDictionaryLearning/fit": {},
  "sklearn/sklearn.decomposition._dict_learning/MiniBatchDictionaryLearning/partial_fit": {},
  "sklearn/sklearn.decomposition._dict_learning/MiniBatchDictionaryLearning/_n_features_out@getter": {},
  "sklearn/sklearn.decomposition._dict_learning/MiniBatchDictionaryLearning/_more_tags": {},
  "sklearn/sklearn.decomposition._factor_analysis/FactorAnalysis/__init__": {},
  "sklearn/sklearn.decomposition._factor_analysis/FactorAnalysis/fit": {},
  "sklearn/sklearn.decomposition._factor_analysis/FactorAnalysis/transform": {},
  "sklearn/sklearn.decomposition._factor_analysis/FactorAnalysis/get_covariance": {},
  "sklearn/sklearn.decomposition._factor_analysis/FactorAnalysis/get_precision": {},
  "sklearn/sklearn.decomposition._factor_analysis/FactorAnalysis/score_samples": {},
  "sklearn/sklearn.decomposition._factor_analysis/FactorAnalysis/score": {},
  "sklearn/sklearn.decomposition._factor_analysis/FactorAnalysis/_rotate": {},
  "sklearn/sklearn.decomposition._factor_analysis/FactorAnalysis/_n_features_out@getter": {},
  "sklearn/sklearn.decomposition._factor_analysis/_ortho_rotation": {},
  "sklearn/sklearn.decomposition._fastica/_gs_decorrelation": {},
  "sklearn/sklearn.decomposition._fastica/_sym_decorrelation": {},
  "sklearn/sklearn.decomposition._fastica/_ica_def": {},
  "sklearn/sklearn.decomposition._fastica/_ica_par": {},
  "sklearn/sklearn.decomposition._fastica/_logcosh": {},
  "sklearn/sklearn.decomposition._fastica/_exp": {},
  "sklearn/sklearn.decomposition._fastica/_cube": {},
  "sklearn/sklearn.decomposition._fastica/fastica": {
    "w_init": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._fastica/fastica/w_init",
          "name": "w_init",
          "qname": "sklearn.decomposition._fastica.fastica.w_init",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "ndarray of shape (n_components, n_components)",
            "default_value": "None",
            "description": "Initial un-mixing array. If `w_init=None`, then an array of values\ndrawn from a normal distribution is used."
          },
          "type": {
            "kind": "NamedType",
            "name": "ndarray of shape (n_components, n_components)"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._fastica/fastica/w_init",
          "name": "w_init",
          "qname": "sklearn.decomposition._fastica.fastica.w_init",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "ndarray of shape (n_components, n_components)",
            "default_value": "None",
            "description": "Initial un-mixing array. If `w_init=None`, then an array of values\ndrawn from a normal distribution is used."
          },
          "type": {
            "kind": "NamedType",
            "name": "ndarray of shape (n_components, n_components)"
          }
        },
        "hasCondition": {
          "condition": "If w_init equals None , then an array of values drawn from a normal distribution"
        },
        "hasAction": {
          "action": "is used"
        }
      }
    ]
  },
  "sklearn/sklearn.decomposition._fastica/FastICA/__init__": {
    "w_init": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._fastica/FastICA/__init__/w_init",
          "name": "w_init",
          "qname": "sklearn.decomposition._fastica.FastICA.__init__.w_init",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "array-like of shape (n_components, n_components)",
            "default_value": "None",
            "description": "Initial un-mixing array. If `w_init=None`, then an array of values\ndrawn from a normal distribution is used."
          },
          "type": {
            "kind": "NamedType",
            "name": "array-like of shape (n_components, n_components)"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._fastica/FastICA/__init__/w_init",
          "name": "w_init",
          "qname": "sklearn.decomposition._fastica.FastICA.__init__.w_init",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "array-like of shape (n_components, n_components)",
            "default_value": "None",
            "description": "Initial un-mixing array. If `w_init=None`, then an array of values\ndrawn from a normal distribution is used."
          },
          "type": {
            "kind": "NamedType",
            "name": "array-like of shape (n_components, n_components)"
          }
        },
        "hasCondition": {
          "condition": "If w_init equals None , then an array of values drawn from a normal distribution"
        },
        "hasAction": {
          "action": "is used"
        }
      }
    ]
  },
  "sklearn/sklearn.decomposition._fastica/FastICA/_fit_transform": {},
  "sklearn/sklearn.decomposition._fastica/FastICA/fit_transform": {},
  "sklearn/sklearn.decomposition._fastica/FastICA/fit": {},
  "sklearn/sklearn.decomposition._fastica/FastICA/transform": {},
  "sklearn/sklearn.decomposition._fastica/FastICA/inverse_transform": {},
  "sklearn/sklearn.decomposition._fastica/FastICA/_n_features_out@getter": {},
  "sklearn/sklearn.decomposition._fastica/FastICA/_more_tags": {},
  "sklearn/sklearn.decomposition._incremental_pca/IncrementalPCA/__init__": {
    "n_components": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._incremental_pca/IncrementalPCA/__init__/n_components",
          "name": "n_components",
          "qname": "sklearn.decomposition._incremental_pca.IncrementalPCA.__init__.n_components",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "None",
            "description": "Number of components to keep. If ``n_components`` is ``None``,\nthen ``n_components`` is set to ``min(n_samples, n_features)``."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._incremental_pca/IncrementalPCA/__init__/n_components",
          "name": "n_components",
          "qname": "sklearn.decomposition._incremental_pca.IncrementalPCA.__init__.n_components",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "None",
            "description": "Number of components to keep. If ``n_components`` is ``None``,\nthen ``n_components`` is set to ``min(n_samples, n_features)``."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "hasCondition": {
          "condition": "If n_components is None"
        },
        "hasAction": {
          "action": ", then n_components is set to min(n_samples , n_features )"
        }
      }
    ],
    "batch_size": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._incremental_pca/IncrementalPCA/__init__/batch_size",
          "name": "batch_size",
          "qname": "sklearn.decomposition._incremental_pca.IncrementalPCA.__init__.batch_size",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "None",
            "description": "The number of samples to use for each batch. Only used when calling\n``fit``. If ``batch_size`` is ``None``, then ``batch_size``\nis inferred from the data and set to ``5 * n_features``, to provide a\nbalance between approximation accuracy and memory consumption."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._incremental_pca/IncrementalPCA/__init__/batch_size",
          "name": "batch_size",
          "qname": "sklearn.decomposition._incremental_pca.IncrementalPCA.__init__.batch_size",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "None",
            "description": "The number of samples to use for each batch. Only used when calling\n``fit``. If ``batch_size`` is ``None``, then ``batch_size``\nis inferred from the data and set to ``5 * n_features``, to provide a\nbalance between approximation accuracy and memory consumption."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "hasCondition": {
          "condition": "If batch_size is None , then batch_size"
        },
        "hasAction": {
          "action": "is inferred from the data and set to 5 * n_features , to provide a balance between approximation accuracy and memory consumption"
        }
      }
    ]
  },
  "sklearn/sklearn.decomposition._incremental_pca/IncrementalPCA/fit": {},
  "sklearn/sklearn.decomposition._incremental_pca/IncrementalPCA/partial_fit": {},
  "sklearn/sklearn.decomposition._incremental_pca/IncrementalPCA/transform": {},
  "sklearn/sklearn.decomposition._kernel_pca/KernelPCA/__init__": {
    "gamma": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._kernel_pca/KernelPCA/__init__/gamma",
          "name": "gamma",
          "qname": "sklearn.decomposition._kernel_pca.KernelPCA.__init__.gamma",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "None",
            "description": "Kernel coefficient for rbf, poly and sigmoid kernels. Ignored by other\nkernels. If ``gamma`` is ``None``, then it is set to ``1/n_features``."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._kernel_pca/KernelPCA/__init__/gamma",
          "name": "gamma",
          "qname": "sklearn.decomposition._kernel_pca.KernelPCA.__init__.gamma",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "None",
            "description": "Kernel coefficient for rbf, poly and sigmoid kernels. Ignored by other\nkernels. If ``gamma`` is ``None``, then it is set to ``1/n_features``."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "hasCondition": {
          "condition": "If gamma is None"
        },
        "hasAction": {
          "action": ", then it is set to 1 / n_features"
        }
      }
    ],
    "eigen_solver": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._kernel_pca/KernelPCA/__init__/eigen_solver",
          "name": "eigen_solver",
          "qname": "sklearn.decomposition._kernel_pca.KernelPCA.__init__.eigen_solver",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'auto', 'dense', 'arpack', 'randomized'}",
            "default_value": "'auto'",
            "description": "Select eigensolver to use. If `n_components` is much\nless than the number of training samples, randomized (or arpack to a\nsmaller extent) may be more efficient than the dense eigensolver.\nRandomized SVD is performed according to the method of Halko et al\n[3]_.\n\nauto :\n    the solver is selected by a default policy based on n_samples\n    (the number of training samples) and `n_components`:\n    if the number of components to extract is less than 10 (strict) and\n    the number of samples is more than 200 (strict), the 'arpack'\n    method is enabled. Otherwise the exact full eigenvalue\n    decomposition is computed and optionally truncated afterwards\n    ('dense' method).\ndense :\n    run exact full eigenvalue decomposition calling the standard\n    LAPACK solver via `scipy.linalg.eigh`, and select the components\n    by postprocessing\narpack :\n    run SVD truncated to n_components calling ARPACK solver using\n    `scipy.sparse.linalg.eigsh`. It requires strictly\n    0 < n_components < n_samples\nrandomized :\n    run randomized SVD by the method of Halko et al. [3]_. The current\n    implementation selects eigenvalues based on their module; therefore\n    using this method can lead to unexpected results if the kernel is\n    not positive semi-definite. See also [4]_.\n\n.. versionchanged:: 1.0\n   `'randomized'` was added."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "randomized",
              "arpack",
              "auto",
              "dense"
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._kernel_pca/KernelPCA/__init__/kernel",
          "name": "kernel",
          "qname": "sklearn.decomposition._kernel_pca.KernelPCA.__init__.kernel",
          "default_value": "'linear'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'linear', 'poly', 'rbf', 'sigmoid', 'cosine', 'precomputed'}             or callable",
            "default_value": "'linear'",
            "description": "Kernel used for PCA."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "EnumType",
                "values": [
                  "precomputed",
                  "sigmoid",
                  "cosine",
                  "rbf",
                  "linear",
                  "poly"
                ]
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "if the kernel is not positive semi - definite"
        },
        "hasAction": {
          "action": "The current implementation selects eigenvalues based on their module ; therefore using this method can lead to unexpected results"
        }
      }
    ],
    "remove_zero_eig": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._kernel_pca/KernelPCA/__init__/remove_zero_eig",
          "name": "remove_zero_eig",
          "qname": "sklearn.decomposition._kernel_pca.KernelPCA.__init__.remove_zero_eig",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "If True, then all components with zero eigenvalues are removed, so\nthat the number of components in the output may be < n_components\n(and sometimes even zero due to numerical instability).\nWhen n_components is None, this parameter is ignored and components\nwith zero eigenvalues are removed regardless."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._kernel_pca/KernelPCA/__init__/n_components",
          "name": "n_components",
          "qname": "sklearn.decomposition._kernel_pca.KernelPCA.__init__.n_components",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "None",
            "description": "Number of components. If None, all non-zero components are kept."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "hasCondition": {
          "condition": "When n_components is None"
        },
        "hasAction": {
          "action": ", this parameter is ignored and components with zero eigenvalues are removed regardless"
        }
      }
    ],
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._kernel_pca/KernelPCA/__init__/random_state",
          "name": "random_state",
          "qname": "sklearn.decomposition._kernel_pca.KernelPCA.__init__.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance or None",
            "default_value": "None",
            "description": "Used when ``eigen_solver`` == 'arpack' or 'randomized'. Pass an int\nfor reproducible results across multiple function calls.\nSee :term:`Glossary <random_state>`.\n\n.. versionadded:: 0.18"
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._kernel_pca/KernelPCA/__init__/eigen_solver",
          "name": "eigen_solver",
          "qname": "sklearn.decomposition._kernel_pca.KernelPCA.__init__.eigen_solver",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'auto', 'dense', 'arpack', 'randomized'}",
            "default_value": "'auto'",
            "description": "Select eigensolver to use. If `n_components` is much\nless than the number of training samples, randomized (or arpack to a\nsmaller extent) may be more efficient than the dense eigensolver.\nRandomized SVD is performed according to the method of Halko et al\n[3]_.\n\nauto :\n    the solver is selected by a default policy based on n_samples\n    (the number of training samples) and `n_components`:\n    if the number of components to extract is less than 10 (strict) and\n    the number of samples is more than 200 (strict), the 'arpack'\n    method is enabled. Otherwise the exact full eigenvalue\n    decomposition is computed and optionally truncated afterwards\n    ('dense' method).\ndense :\n    run exact full eigenvalue decomposition calling the standard\n    LAPACK solver via `scipy.linalg.eigh`, and select the components\n    by postprocessing\narpack :\n    run SVD truncated to n_components calling ARPACK solver using\n    `scipy.sparse.linalg.eigsh`. It requires strictly\n    0 < n_components < n_samples\nrandomized :\n    run randomized SVD by the method of Halko et al. [3]_. The current\n    implementation selects eigenvalues based on their module; therefore\n    using this method can lead to unexpected results if the kernel is\n    not positive semi-definite. See also [4]_.\n\n.. versionchanged:: 1.0\n   `'randomized'` was added."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "randomized",
              "arpack",
              "auto",
              "dense"
            ]
          }
        },
        "hasCondition": {
          "condition": "when eigen_solver equals arpack or randomized"
        },
        "hasAction": {
          "action": "Used"
        }
      }
    ]
  },
  "sklearn/sklearn.decomposition._kernel_pca/KernelPCA/_get_kernel": {},
  "sklearn/sklearn.decomposition._kernel_pca/KernelPCA/_fit_transform": {},
  "sklearn/sklearn.decomposition._kernel_pca/KernelPCA/_fit_inverse_transform": {},
  "sklearn/sklearn.decomposition._kernel_pca/KernelPCA/fit": {},
  "sklearn/sklearn.decomposition._kernel_pca/KernelPCA/fit_transform": {},
  "sklearn/sklearn.decomposition._kernel_pca/KernelPCA/transform": {},
  "sklearn/sklearn.decomposition._kernel_pca/KernelPCA/inverse_transform": {},
  "sklearn/sklearn.decomposition._kernel_pca/KernelPCA/_more_tags": {},
  "sklearn/sklearn.decomposition._kernel_pca/KernelPCA/_n_features_out@getter": {},
  "sklearn/sklearn.decomposition._lda/_update_doc_distribution": {},
  "sklearn/sklearn.decomposition._lda/LatentDirichletAllocation/__init__": {
    "perp_tol": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._lda/LatentDirichletAllocation/__init__/perp_tol",
          "name": "perp_tol",
          "qname": "sklearn.decomposition._lda.LatentDirichletAllocation.__init__.perp_tol",
          "default_value": "0.1",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "1e-1",
            "description": "Perplexity tolerance in batch learning. Only used when\n``evaluate_every`` is greater than 0."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._lda/LatentDirichletAllocation/__init__/evaluate_every",
          "name": "evaluate_every",
          "qname": "sklearn.decomposition._lda.LatentDirichletAllocation.__init__.evaluate_every",
          "default_value": "-1",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "-1",
            "description": "How often to evaluate perplexity. Only used in `fit` method.\nset it to 0 or negative number to not evaluate perplexity in\ntraining at all. Evaluating perplexity can help you check convergence\nin training process, but it will also increase total training time.\nEvaluating perplexity in every iteration might increase training time\nup to two-fold."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "hasCondition": {
          "condition": "when evaluate_every is greater than 0"
        },
        "hasAction": {
          "action": "Only used"
        }
      }
    ]
  },
  "sklearn/sklearn.decomposition._lda/LatentDirichletAllocation/_init_latent_vars": {},
  "sklearn/sklearn.decomposition._lda/LatentDirichletAllocation/_e_step": {},
  "sklearn/sklearn.decomposition._lda/LatentDirichletAllocation/_em_step": {
    "total_samples": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._lda/LatentDirichletAllocation/_em_step/total_samples",
          "name": "total_samples",
          "qname": "sklearn.decomposition._lda.LatentDirichletAllocation._em_step.total_samples",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "int",
            "default_value": "",
            "description": "Total number of documents. It is only used when\nbatch_update is `False`."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._lda/LatentDirichletAllocation/_em_step/batch_update",
          "name": "batch_update",
          "qname": "sklearn.decomposition._lda.LatentDirichletAllocation._em_step.batch_update",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "bool",
            "default_value": "",
            "description": "Parameter that controls updating method.\n`True` for batch learning, `False` for online learning."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "when batch_update is False"
        },
        "hasAction": {
          "action": "It is only used"
        }
      }
    ]
  },
  "sklearn/sklearn.decomposition._lda/LatentDirichletAllocation/_more_tags": {},
  "sklearn/sklearn.decomposition._lda/LatentDirichletAllocation/_check_non_neg_array": {},
  "sklearn/sklearn.decomposition._lda/LatentDirichletAllocation/partial_fit": {},
  "sklearn/sklearn.decomposition._lda/LatentDirichletAllocation/fit": {},
  "sklearn/sklearn.decomposition._lda/LatentDirichletAllocation/_unnormalized_transform": {},
  "sklearn/sklearn.decomposition._lda/LatentDirichletAllocation/transform": {},
  "sklearn/sklearn.decomposition._lda/LatentDirichletAllocation/_approx_bound": {},
  "sklearn/sklearn.decomposition._lda/LatentDirichletAllocation/score": {},
  "sklearn/sklearn.decomposition._lda/LatentDirichletAllocation/_perplexity_precomp_distr": {},
  "sklearn/sklearn.decomposition._lda/LatentDirichletAllocation/perplexity": {},
  "sklearn/sklearn.decomposition._lda/LatentDirichletAllocation/_n_features_out@getter": {},
  "sklearn/sklearn.decomposition._nmf/norm": {},
  "sklearn/sklearn.decomposition._nmf/trace_dot": {},
  "sklearn/sklearn.decomposition._nmf/_check_init": {},
  "sklearn/sklearn.decomposition._nmf/_beta_divergence": {},
  "sklearn/sklearn.decomposition._nmf/_special_sparse_dot": {},
  "sklearn/sklearn.decomposition._nmf/_beta_loss_to_float": {},
  "sklearn/sklearn.decomposition._nmf/_initialize_nmf": {
    "init": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._nmf/_initialize_nmf/init",
          "name": "init",
          "qname": "sklearn.decomposition._nmf._initialize_nmf.init",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "{'random', 'nndsvd', 'nndsvda', 'nndsvdar'}",
            "default_value": "None",
            "description": "Method used to initialize the procedure.\nValid options:\n\n- None: 'nndsvda' if n_components <= min(n_samples, n_features),\n    otherwise 'random'.\n\n- 'random': non-negative random matrices, scaled with:\n    sqrt(X.mean() / n_components)\n\n- 'nndsvd': Nonnegative Double Singular Value Decomposition (NNDSVD)\n    initialization (better for sparseness)\n\n- 'nndsvda': NNDSVD with zeros filled with the average of X\n    (better when sparsity is not desired)\n\n- 'nndsvdar': NNDSVD with zeros filled with small random values\n    (generally faster, less accurate alternative to NNDSVDa\n    for when sparsity is not desired)\n\n- 'custom': use custom matrices W and H\n\n.. versionchanged:: 1.1\n    When `init=None` and n_components is less than n_samples and n_features\n    defaults to `nndsvda` instead of `nndsvd`."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "nndsvd",
              "random",
              "nndsvdar",
              "nndsvda"
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._nmf/_initialize_nmf/init",
          "name": "init",
          "qname": "sklearn.decomposition._nmf._initialize_nmf.init",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "{'random', 'nndsvd', 'nndsvda', 'nndsvdar'}",
            "default_value": "None",
            "description": "Method used to initialize the procedure.\nValid options:\n\n- None: 'nndsvda' if n_components <= min(n_samples, n_features),\n    otherwise 'random'.\n\n- 'random': non-negative random matrices, scaled with:\n    sqrt(X.mean() / n_components)\n\n- 'nndsvd': Nonnegative Double Singular Value Decomposition (NNDSVD)\n    initialization (better for sparseness)\n\n- 'nndsvda': NNDSVD with zeros filled with the average of X\n    (better when sparsity is not desired)\n\n- 'nndsvdar': NNDSVD with zeros filled with small random values\n    (generally faster, less accurate alternative to NNDSVDa\n    for when sparsity is not desired)\n\n- 'custom': use custom matrices W and H\n\n.. versionchanged:: 1.1\n    When `init=None` and n_components is less than n_samples and n_features\n    defaults to `nndsvda` instead of `nndsvd`."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "nndsvd",
              "random",
              "nndsvdar",
              "nndsvda"
            ]
          }
        },
        "hasCondition": {
          "condition": "When init equals None and n_components is less than n_samples and n_features defaults to nndsvda instead of nndsvd"
        },
        "hasAction": {
          "action": "custom : use custom matrices W and H .. versionchanged : : 1.1"
        }
      }
    ],
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._nmf/_initialize_nmf/random_state",
          "name": "random_state",
          "qname": "sklearn.decomposition._nmf._initialize_nmf.random_state",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "int, RandomState instance or None",
            "default_value": "None",
            "description": "Used when ``init`` == 'nndsvdar' or 'random'. Pass an int for\nreproducible results across multiple function calls.\nSee :term:`Glossary <random_state>`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._nmf/_initialize_nmf/init",
          "name": "init",
          "qname": "sklearn.decomposition._nmf._initialize_nmf.init",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "{'random', 'nndsvd', 'nndsvda', 'nndsvdar'}",
            "default_value": "None",
            "description": "Method used to initialize the procedure.\nValid options:\n\n- None: 'nndsvda' if n_components <= min(n_samples, n_features),\n    otherwise 'random'.\n\n- 'random': non-negative random matrices, scaled with:\n    sqrt(X.mean() / n_components)\n\n- 'nndsvd': Nonnegative Double Singular Value Decomposition (NNDSVD)\n    initialization (better for sparseness)\n\n- 'nndsvda': NNDSVD with zeros filled with the average of X\n    (better when sparsity is not desired)\n\n- 'nndsvdar': NNDSVD with zeros filled with small random values\n    (generally faster, less accurate alternative to NNDSVDa\n    for when sparsity is not desired)\n\n- 'custom': use custom matrices W and H\n\n.. versionchanged:: 1.1\n    When `init=None` and n_components is less than n_samples and n_features\n    defaults to `nndsvda` instead of `nndsvd`."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "nndsvd",
              "random",
              "nndsvdar",
              "nndsvda"
            ]
          }
        },
        "hasCondition": {
          "condition": "when init equals nndsvdar or random"
        },
        "hasAction": {
          "action": "Used"
        }
      }
    ]
  },
  "sklearn/sklearn.decomposition._nmf/_update_coordinate_descent": {},
  "sklearn/sklearn.decomposition._nmf/_fit_coordinate_descent": {
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._nmf/_fit_coordinate_descent/random_state",
          "name": "random_state",
          "qname": "sklearn.decomposition._nmf._fit_coordinate_descent.random_state",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "int, RandomState instance or None",
            "default_value": "None",
            "description": "Used to randomize the coordinates in the CD solver, when\n``shuffle`` is set to ``True``. Pass an int for reproducible\nresults across multiple function calls.\nSee :term:`Glossary <random_state>`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._nmf/_fit_coordinate_descent/shuffle",
          "name": "shuffle",
          "qname": "sklearn.decomposition._nmf._fit_coordinate_descent.shuffle",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "If true, randomize the order of coordinates in the CD solver."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "when shuffle is set to True"
        },
        "hasAction": {
          "action": "Used to randomize the coordinates in the CD solver ,"
        }
      }
    ]
  },
  "sklearn/sklearn.decomposition._nmf/_multiplicative_update_w": {},
  "sklearn/sklearn.decomposition._nmf/_multiplicative_update_h": {},
  "sklearn/sklearn.decomposition._nmf/_fit_multiplicative_update": {},
  "sklearn/sklearn.decomposition._nmf/non_negative_factorization": {
    "W": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._nmf/non_negative_factorization/W",
          "name": "W",
          "qname": "sklearn.decomposition._nmf.non_negative_factorization.W",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of shape (n_samples, n_components)",
            "default_value": "None",
            "description": "If init='custom', it is used as initial guess for the solution."
          },
          "type": {
            "kind": "NamedType",
            "name": "array-like of shape (n_samples, n_components)"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._nmf/non_negative_factorization/init",
          "name": "init",
          "qname": "sklearn.decomposition._nmf.non_negative_factorization.init",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'random', 'nndsvd', 'nndsvda', 'nndsvdar', 'custom'}",
            "default_value": "None",
            "description": "Method used to initialize the procedure.\n\nValid options:\n\n- None: 'nndsvda' if n_components < n_features, otherwise 'random'.\n- 'random': non-negative random matrices, scaled with:\n  `sqrt(X.mean() / n_components)`\n- 'nndsvd': Nonnegative Double Singular Value Decomposition (NNDSVD)\n  initialization (better for sparseness)\n- 'nndsvda': NNDSVD with zeros filled with the average of X\n  (better when sparsity is not desired)\n- 'nndsvdar': NNDSVD with zeros filled with small random values\n  (generally faster, less accurate alternative to NNDSVDa\n  for when sparsity is not desired)\n- 'custom': use custom matrices W and H if `update_H=True`. If\n  `update_H=False`, then only custom matrix H is used.\n\n.. versionchanged:: 0.23\n    The default value of `init` changed from 'random' to None in 0.23.\n\n.. versionchanged:: 1.1\n    When `init=None` and n_components is less than n_samples and n_features\n    defaults to `nndsvda` instead of `nndsvd`."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "nndsvda",
              "custom",
              "nndsvd",
              "nndsvdar",
              "random"
            ]
          }
        },
        "hasCondition": {
          "condition": "If init equals custom"
        },
        "hasAction": {
          "action": ", it is used as initial guess for the solution"
        }
      }
    ],
    "H": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._nmf/non_negative_factorization/H",
          "name": "H",
          "qname": "sklearn.decomposition._nmf.non_negative_factorization.H",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of shape (n_components, n_features)",
            "default_value": "None",
            "description": "If init='custom', it is used as initial guess for the solution.\nIf update_H=False, it is used as a constant, to solve for W only."
          },
          "type": {
            "kind": "NamedType",
            "name": "array-like of shape (n_components, n_features)"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._nmf/non_negative_factorization/init",
          "name": "init",
          "qname": "sklearn.decomposition._nmf.non_negative_factorization.init",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'random', 'nndsvd', 'nndsvda', 'nndsvdar', 'custom'}",
            "default_value": "None",
            "description": "Method used to initialize the procedure.\n\nValid options:\n\n- None: 'nndsvda' if n_components < n_features, otherwise 'random'.\n- 'random': non-negative random matrices, scaled with:\n  `sqrt(X.mean() / n_components)`\n- 'nndsvd': Nonnegative Double Singular Value Decomposition (NNDSVD)\n  initialization (better for sparseness)\n- 'nndsvda': NNDSVD with zeros filled with the average of X\n  (better when sparsity is not desired)\n- 'nndsvdar': NNDSVD with zeros filled with small random values\n  (generally faster, less accurate alternative to NNDSVDa\n  for when sparsity is not desired)\n- 'custom': use custom matrices W and H if `update_H=True`. If\n  `update_H=False`, then only custom matrix H is used.\n\n.. versionchanged:: 0.23\n    The default value of `init` changed from 'random' to None in 0.23.\n\n.. versionchanged:: 1.1\n    When `init=None` and n_components is less than n_samples and n_features\n    defaults to `nndsvda` instead of `nndsvd`."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "nndsvda",
              "custom",
              "nndsvd",
              "nndsvdar",
              "random"
            ]
          }
        },
        "hasCondition": {
          "condition": "If init equals custom"
        },
        "hasAction": {
          "action": ", it is used as initial guess for the solution"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._nmf/non_negative_factorization/H",
          "name": "H",
          "qname": "sklearn.decomposition._nmf.non_negative_factorization.H",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of shape (n_components, n_features)",
            "default_value": "None",
            "description": "If init='custom', it is used as initial guess for the solution.\nIf update_H=False, it is used as a constant, to solve for W only."
          },
          "type": {
            "kind": "NamedType",
            "name": "array-like of shape (n_components, n_features)"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._nmf/non_negative_factorization/update_H",
          "name": "update_H",
          "qname": "sklearn.decomposition._nmf.non_negative_factorization.update_H",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Set to True, both W and H will be estimated from initial guesses.\nSet to False, only W will be estimated."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "If update_H equals False"
        },
        "hasAction": {
          "action": ", it is used as a constant , to solve for W only"
        }
      }
    ],
    "init": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._nmf/non_negative_factorization/init",
          "name": "init",
          "qname": "sklearn.decomposition._nmf.non_negative_factorization.init",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'random', 'nndsvd', 'nndsvda', 'nndsvdar', 'custom'}",
            "default_value": "None",
            "description": "Method used to initialize the procedure.\n\nValid options:\n\n- None: 'nndsvda' if n_components < n_features, otherwise 'random'.\n- 'random': non-negative random matrices, scaled with:\n  `sqrt(X.mean() / n_components)`\n- 'nndsvd': Nonnegative Double Singular Value Decomposition (NNDSVD)\n  initialization (better for sparseness)\n- 'nndsvda': NNDSVD with zeros filled with the average of X\n  (better when sparsity is not desired)\n- 'nndsvdar': NNDSVD with zeros filled with small random values\n  (generally faster, less accurate alternative to NNDSVDa\n  for when sparsity is not desired)\n- 'custom': use custom matrices W and H if `update_H=True`. If\n  `update_H=False`, then only custom matrix H is used.\n\n.. versionchanged:: 0.23\n    The default value of `init` changed from 'random' to None in 0.23.\n\n.. versionchanged:: 1.1\n    When `init=None` and n_components is less than n_samples and n_features\n    defaults to `nndsvda` instead of `nndsvd`."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "nndsvda",
              "custom",
              "nndsvd",
              "nndsvdar",
              "random"
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._nmf/non_negative_factorization/update_H",
          "name": "update_H",
          "qname": "sklearn.decomposition._nmf.non_negative_factorization.update_H",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Set to True, both W and H will be estimated from initial guesses.\nSet to False, only W will be estimated."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "if update_H equals True"
        },
        "hasAction": {
          "action": "custom : use custom matrices W and H"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._nmf/non_negative_factorization/init",
          "name": "init",
          "qname": "sklearn.decomposition._nmf.non_negative_factorization.init",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'random', 'nndsvd', 'nndsvda', 'nndsvdar', 'custom'}",
            "default_value": "None",
            "description": "Method used to initialize the procedure.\n\nValid options:\n\n- None: 'nndsvda' if n_components < n_features, otherwise 'random'.\n- 'random': non-negative random matrices, scaled with:\n  `sqrt(X.mean() / n_components)`\n- 'nndsvd': Nonnegative Double Singular Value Decomposition (NNDSVD)\n  initialization (better for sparseness)\n- 'nndsvda': NNDSVD with zeros filled with the average of X\n  (better when sparsity is not desired)\n- 'nndsvdar': NNDSVD with zeros filled with small random values\n  (generally faster, less accurate alternative to NNDSVDa\n  for when sparsity is not desired)\n- 'custom': use custom matrices W and H if `update_H=True`. If\n  `update_H=False`, then only custom matrix H is used.\n\n.. versionchanged:: 0.23\n    The default value of `init` changed from 'random' to None in 0.23.\n\n.. versionchanged:: 1.1\n    When `init=None` and n_components is less than n_samples and n_features\n    defaults to `nndsvda` instead of `nndsvd`."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "nndsvda",
              "custom",
              "nndsvd",
              "nndsvdar",
              "random"
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._nmf/non_negative_factorization/update_H",
          "name": "update_H",
          "qname": "sklearn.decomposition._nmf.non_negative_factorization.update_H",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Set to True, both W and H will be estimated from initial guesses.\nSet to False, only W will be estimated."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "If update_H equals False"
        },
        "hasAction": {
          "action": ", then only custom matrix H is used"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._nmf/non_negative_factorization/init",
          "name": "init",
          "qname": "sklearn.decomposition._nmf.non_negative_factorization.init",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'random', 'nndsvd', 'nndsvda', 'nndsvdar', 'custom'}",
            "default_value": "None",
            "description": "Method used to initialize the procedure.\n\nValid options:\n\n- None: 'nndsvda' if n_components < n_features, otherwise 'random'.\n- 'random': non-negative random matrices, scaled with:\n  `sqrt(X.mean() / n_components)`\n- 'nndsvd': Nonnegative Double Singular Value Decomposition (NNDSVD)\n  initialization (better for sparseness)\n- 'nndsvda': NNDSVD with zeros filled with the average of X\n  (better when sparsity is not desired)\n- 'nndsvdar': NNDSVD with zeros filled with small random values\n  (generally faster, less accurate alternative to NNDSVDa\n  for when sparsity is not desired)\n- 'custom': use custom matrices W and H if `update_H=True`. If\n  `update_H=False`, then only custom matrix H is used.\n\n.. versionchanged:: 0.23\n    The default value of `init` changed from 'random' to None in 0.23.\n\n.. versionchanged:: 1.1\n    When `init=None` and n_components is less than n_samples and n_features\n    defaults to `nndsvda` instead of `nndsvd`."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "nndsvda",
              "custom",
              "nndsvd",
              "nndsvdar",
              "random"
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._nmf/non_negative_factorization/init",
          "name": "init",
          "qname": "sklearn.decomposition._nmf.non_negative_factorization.init",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'random', 'nndsvd', 'nndsvda', 'nndsvdar', 'custom'}",
            "default_value": "None",
            "description": "Method used to initialize the procedure.\n\nValid options:\n\n- None: 'nndsvda' if n_components < n_features, otherwise 'random'.\n- 'random': non-negative random matrices, scaled with:\n  `sqrt(X.mean() / n_components)`\n- 'nndsvd': Nonnegative Double Singular Value Decomposition (NNDSVD)\n  initialization (better for sparseness)\n- 'nndsvda': NNDSVD with zeros filled with the average of X\n  (better when sparsity is not desired)\n- 'nndsvdar': NNDSVD with zeros filled with small random values\n  (generally faster, less accurate alternative to NNDSVDa\n  for when sparsity is not desired)\n- 'custom': use custom matrices W and H if `update_H=True`. If\n  `update_H=False`, then only custom matrix H is used.\n\n.. versionchanged:: 0.23\n    The default value of `init` changed from 'random' to None in 0.23.\n\n.. versionchanged:: 1.1\n    When `init=None` and n_components is less than n_samples and n_features\n    defaults to `nndsvda` instead of `nndsvd`."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "nndsvda",
              "custom",
              "nndsvd",
              "nndsvdar",
              "random"
            ]
          }
        },
        "hasCondition": {
          "condition": "When init equals None and n_components is less than n_samples and n_features defaults to nndsvda instead of nndsvd"
        },
        "hasAction": {
          "action": ".. versionchanged : : 1.1"
        }
      }
    ],
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._nmf/non_negative_factorization/random_state",
          "name": "random_state",
          "qname": "sklearn.decomposition._nmf.non_negative_factorization.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance or None",
            "default_value": "None",
            "description": "Used for NMF initialisation (when ``init`` == 'nndsvdar' or\n'random'), and in Coordinate Descent. Pass an int for reproducible\nresults across multiple function calls.\nSee :term:`Glossary <random_state>`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._nmf/non_negative_factorization/init",
          "name": "init",
          "qname": "sklearn.decomposition._nmf.non_negative_factorization.init",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'random', 'nndsvd', 'nndsvda', 'nndsvdar', 'custom'}",
            "default_value": "None",
            "description": "Method used to initialize the procedure.\n\nValid options:\n\n- None: 'nndsvda' if n_components < n_features, otherwise 'random'.\n- 'random': non-negative random matrices, scaled with:\n  `sqrt(X.mean() / n_components)`\n- 'nndsvd': Nonnegative Double Singular Value Decomposition (NNDSVD)\n  initialization (better for sparseness)\n- 'nndsvda': NNDSVD with zeros filled with the average of X\n  (better when sparsity is not desired)\n- 'nndsvdar': NNDSVD with zeros filled with small random values\n  (generally faster, less accurate alternative to NNDSVDa\n  for when sparsity is not desired)\n- 'custom': use custom matrices W and H if `update_H=True`. If\n  `update_H=False`, then only custom matrix H is used.\n\n.. versionchanged:: 0.23\n    The default value of `init` changed from 'random' to None in 0.23.\n\n.. versionchanged:: 1.1\n    When `init=None` and n_components is less than n_samples and n_features\n    defaults to `nndsvda` instead of `nndsvd`."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "nndsvda",
              "custom",
              "nndsvd",
              "nndsvdar",
              "random"
            ]
          }
        },
        "hasCondition": {
          "condition": "when init equals nndsvdar or random"
        },
        "hasAction": {
          "action": "Used for NMF initialisation ( ) , and in Coordinate Descent"
        }
      }
    ]
  },
  "sklearn/sklearn.decomposition._nmf/_BaseNMF/__init__": {},
  "sklearn/sklearn.decomposition._nmf/_BaseNMF/_check_params": {},
  "sklearn/sklearn.decomposition._nmf/_BaseNMF/_check_w_h": {},
  "sklearn/sklearn.decomposition._nmf/_BaseNMF/_compute_regularization": {},
  "sklearn/sklearn.decomposition._nmf/_BaseNMF/fit": {},
  "sklearn/sklearn.decomposition._nmf/_BaseNMF/inverse_transform": {},
  "sklearn/sklearn.decomposition._nmf/_BaseNMF/_n_features_out@getter": {},
  "sklearn/sklearn.decomposition._nmf/_BaseNMF/_more_tags": {},
  "sklearn/sklearn.decomposition._nmf/NMF/__init__": {
    "init": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._nmf/NMF/__init__/init",
          "name": "init",
          "qname": "sklearn.decomposition._nmf.NMF.__init__.init",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'random', 'nndsvd', 'nndsvda', 'nndsvdar', 'custom'}",
            "default_value": "None",
            "description": "Method used to initialize the procedure.\nValid options:\n\n- `None`: 'nndsvda' if n_components <= min(n_samples, n_features),\n  otherwise random.\n\n- `'random'`: non-negative random matrices, scaled with:\n  sqrt(X.mean() / n_components)\n\n- `'nndsvd'`: Nonnegative Double Singular Value Decomposition (NNDSVD)\n  initialization (better for sparseness)\n\n- `'nndsvda'`: NNDSVD with zeros filled with the average of X\n  (better when sparsity is not desired)\n\n- `'nndsvdar'` NNDSVD with zeros filled with small random values\n  (generally faster, less accurate alternative to NNDSVDa\n  for when sparsity is not desired)\n\n- `'custom'`: use custom matrices W and H\n\n.. versionchanged:: 1.1\n    When `init=None` and n_components is less than n_samples and n_features\n    defaults to `nndsvda` instead of `nndsvd`."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "nndsvda",
              "custom",
              "nndsvd",
              "nndsvdar",
              "random"
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._nmf/NMF/__init__/init",
          "name": "init",
          "qname": "sklearn.decomposition._nmf.NMF.__init__.init",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'random', 'nndsvd', 'nndsvda', 'nndsvdar', 'custom'}",
            "default_value": "None",
            "description": "Method used to initialize the procedure.\nValid options:\n\n- `None`: 'nndsvda' if n_components <= min(n_samples, n_features),\n  otherwise random.\n\n- `'random'`: non-negative random matrices, scaled with:\n  sqrt(X.mean() / n_components)\n\n- `'nndsvd'`: Nonnegative Double Singular Value Decomposition (NNDSVD)\n  initialization (better for sparseness)\n\n- `'nndsvda'`: NNDSVD with zeros filled with the average of X\n  (better when sparsity is not desired)\n\n- `'nndsvdar'` NNDSVD with zeros filled with small random values\n  (generally faster, less accurate alternative to NNDSVDa\n  for when sparsity is not desired)\n\n- `'custom'`: use custom matrices W and H\n\n.. versionchanged:: 1.1\n    When `init=None` and n_components is less than n_samples and n_features\n    defaults to `nndsvda` instead of `nndsvd`."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "nndsvda",
              "custom",
              "nndsvd",
              "nndsvdar",
              "random"
            ]
          }
        },
        "hasCondition": {
          "condition": "When init equals None and n_components is less than n_samples and n_features defaults to nndsvda instead of nndsvd"
        },
        "hasAction": {
          "action": "custom : use custom matrices W and H .. versionchanged : : 1.1"
        }
      }
    ],
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._nmf/NMF/__init__/random_state",
          "name": "random_state",
          "qname": "sklearn.decomposition._nmf.NMF.__init__.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance or None",
            "default_value": "None",
            "description": "Used for initialisation (when ``init`` == 'nndsvdar' or\n'random'), and in Coordinate Descent. Pass an int for reproducible\nresults across multiple function calls.\nSee :term:`Glossary <random_state>`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._nmf/NMF/__init__/init",
          "name": "init",
          "qname": "sklearn.decomposition._nmf.NMF.__init__.init",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'random', 'nndsvd', 'nndsvda', 'nndsvdar', 'custom'}",
            "default_value": "None",
            "description": "Method used to initialize the procedure.\nValid options:\n\n- `None`: 'nndsvda' if n_components <= min(n_samples, n_features),\n  otherwise random.\n\n- `'random'`: non-negative random matrices, scaled with:\n  sqrt(X.mean() / n_components)\n\n- `'nndsvd'`: Nonnegative Double Singular Value Decomposition (NNDSVD)\n  initialization (better for sparseness)\n\n- `'nndsvda'`: NNDSVD with zeros filled with the average of X\n  (better when sparsity is not desired)\n\n- `'nndsvdar'` NNDSVD with zeros filled with small random values\n  (generally faster, less accurate alternative to NNDSVDa\n  for when sparsity is not desired)\n\n- `'custom'`: use custom matrices W and H\n\n.. versionchanged:: 1.1\n    When `init=None` and n_components is less than n_samples and n_features\n    defaults to `nndsvda` instead of `nndsvd`."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "nndsvda",
              "custom",
              "nndsvd",
              "nndsvdar",
              "random"
            ]
          }
        },
        "hasCondition": {
          "condition": "when init equals nndsvdar or random"
        },
        "hasAction": {
          "action": "Used for initialisation ( ) , and in Coordinate Descent"
        }
      }
    ]
  },
  "sklearn/sklearn.decomposition._nmf/NMF/_check_params": {},
  "sklearn/sklearn.decomposition._nmf/NMF/fit_transform": {},
  "sklearn/sklearn.decomposition._nmf/NMF/_fit_transform": {
    "H": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._nmf/NMF/_fit_transform/H",
          "name": "H",
          "qname": "sklearn.decomposition._nmf.NMF._fit_transform.H",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "array-like of shape (n_components, n_features)",
            "default_value": "",
            "description": "If init='custom', it is used as initial guess for the solution.\nIf update_H=False, it is used as a constant, to solve for W only."
          },
          "type": {
            "kind": "NamedType",
            "name": "array-like of shape (n_components, n_features)"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._nmf/NMF/_fit_transform/update_H",
          "name": "update_H",
          "qname": "sklearn.decomposition._nmf.NMF._fit_transform.update_H",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "If True, both W and H will be estimated from initial guesses,\nthis corresponds to a call to the 'fit_transform' method.\nIf False, only W will be estimated, this corresponds to a call\nto the 'transform' method."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "If update_H equals False"
        },
        "hasAction": {
          "action": ", it is used as a constant , to solve for W only"
        }
      }
    ]
  },
  "sklearn/sklearn.decomposition._nmf/NMF/transform": {},
  "sklearn/sklearn.decomposition._nmf/MiniBatchNMF/__init__": {
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._nmf/MiniBatchNMF/__init__/random_state",
          "name": "random_state",
          "qname": "sklearn.decomposition._nmf.MiniBatchNMF.__init__.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance or None",
            "default_value": "None",
            "description": "Used for initialisation (when ``init`` == 'nndsvdar' or\n'random'), and in Coordinate Descent. Pass an int for reproducible\nresults across multiple function calls.\nSee :term:`Glossary <random_state>`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._nmf/MiniBatchNMF/__init__/init",
          "name": "init",
          "qname": "sklearn.decomposition._nmf.MiniBatchNMF.__init__.init",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'random', 'nndsvd', 'nndsvda', 'nndsvdar', 'custom'}",
            "default_value": "None",
            "description": "Method used to initialize the procedure.\nValid options:\n\n- `None`: 'nndsvda' if `n_components <= min(n_samples, n_features)`,\n  otherwise random.\n\n- `'random'`: non-negative random matrices, scaled with:\n  `sqrt(X.mean() / n_components)`\n\n- `'nndsvd'`: Nonnegative Double Singular Value Decomposition (NNDSVD)\n  initialization (better for sparseness).\n\n- `'nndsvda'`: NNDSVD with zeros filled with the average of X\n  (better when sparsity is not desired).\n\n- `'nndsvdar'` NNDSVD with zeros filled with small random values\n  (generally faster, less accurate alternative to NNDSVDa\n  for when sparsity is not desired).\n\n- `'custom'`: use custom matrices `W` and `H`"
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "nndsvda",
              "custom",
              "nndsvd",
              "nndsvdar",
              "random"
            ]
          }
        },
        "hasCondition": {
          "condition": "when init equals nndsvdar or random"
        },
        "hasAction": {
          "action": "Used for initialisation ( ) , and in Coordinate Descent"
        }
      }
    ]
  },
  "sklearn/sklearn.decomposition._nmf/MiniBatchNMF/_check_params": {},
  "sklearn/sklearn.decomposition._nmf/MiniBatchNMF/_solve_W": {},
  "sklearn/sklearn.decomposition._nmf/MiniBatchNMF/_minibatch_step": {},
  "sklearn/sklearn.decomposition._nmf/MiniBatchNMF/_minibatch_convergence": {},
  "sklearn/sklearn.decomposition._nmf/MiniBatchNMF/fit_transform": {},
  "sklearn/sklearn.decomposition._nmf/MiniBatchNMF/_fit_transform": {
    "H": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._nmf/MiniBatchNMF/_fit_transform/H",
          "name": "H",
          "qname": "sklearn.decomposition._nmf.MiniBatchNMF._fit_transform.H",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "array-like of shape (n_components, n_features)",
            "default_value": "None",
            "description": "If init='custom', it is used as initial guess for the solution.\nIf update_H=False, it is used as a constant, to solve for W only."
          },
          "type": {
            "kind": "NamedType",
            "name": "array-like of shape (n_components, n_features)"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._nmf/MiniBatchNMF/_fit_transform/update_H",
          "name": "update_H",
          "qname": "sklearn.decomposition._nmf.MiniBatchNMF._fit_transform.update_H",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "If True, both W and H will be estimated from initial guesses,\nthis corresponds to a call to the `fit_transform` method.\nIf False, only W will be estimated, this corresponds to a call\nto the `transform` method."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "If update_H equals False"
        },
        "hasAction": {
          "action": ", it is used as a constant , to solve for W only"
        }
      }
    ]
  },
  "sklearn/sklearn.decomposition._nmf/MiniBatchNMF/transform": {},
  "sklearn/sklearn.decomposition._nmf/MiniBatchNMF/partial_fit": {},
  "sklearn/sklearn.decomposition._pca/_assess_dimension": {},
  "sklearn/sklearn.decomposition._pca/_infer_dimension": {},
  "sklearn/sklearn.decomposition._pca/PCA/__init__": {
    "n_components": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._pca/PCA/__init__/n_components",
          "name": "n_components",
          "qname": "sklearn.decomposition._pca.PCA.__init__.n_components",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "int, float or 'mle'",
            "default_value": "None",
            "description": "Number of components to keep.\nif n_components is not set all components are kept::\n\n    n_components == min(n_samples, n_features)\n\nIf ``n_components == 'mle'`` and ``svd_solver == 'full'``, Minka's\nMLE is used to guess the dimension. Use of ``n_components == 'mle'``\nwill interpret ``svd_solver == 'auto'`` as ``svd_solver == 'full'``.\n\nIf ``0 < n_components < 1`` and ``svd_solver == 'full'``, select the\nnumber of components such that the amount of variance that needs to be\nexplained is greater than the percentage specified by n_components.\n\nIf ``svd_solver == 'arpack'``, the number of components must be\nstrictly less than the minimum of n_features and n_samples.\n\nHence, the None case results in::\n\n    n_components == min(n_samples, n_features) - 1"
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "float"
              },
              {
                "kind": "NamedType",
                "name": "'mle'"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._pca/PCA/__init__/n_components",
          "name": "n_components",
          "qname": "sklearn.decomposition._pca.PCA.__init__.n_components",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "int, float or 'mle'",
            "default_value": "None",
            "description": "Number of components to keep.\nif n_components is not set all components are kept::\n\n    n_components == min(n_samples, n_features)\n\nIf ``n_components == 'mle'`` and ``svd_solver == 'full'``, Minka's\nMLE is used to guess the dimension. Use of ``n_components == 'mle'``\nwill interpret ``svd_solver == 'auto'`` as ``svd_solver == 'full'``.\n\nIf ``0 < n_components < 1`` and ``svd_solver == 'full'``, select the\nnumber of components such that the amount of variance that needs to be\nexplained is greater than the percentage specified by n_components.\n\nIf ``svd_solver == 'arpack'``, the number of components must be\nstrictly less than the minimum of n_features and n_samples.\n\nHence, the None case results in::\n\n    n_components == min(n_samples, n_features) - 1"
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "float"
              },
              {
                "kind": "NamedType",
                "name": "'mle'"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "if n_components is not set all components are kept :"
        },
        "hasAction": {
          "action": ": n_components equals min(n_samples , n_features )"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._pca/PCA/__init__/n_components",
          "name": "n_components",
          "qname": "sklearn.decomposition._pca.PCA.__init__.n_components",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "int, float or 'mle'",
            "default_value": "None",
            "description": "Number of components to keep.\nif n_components is not set all components are kept::\n\n    n_components == min(n_samples, n_features)\n\nIf ``n_components == 'mle'`` and ``svd_solver == 'full'``, Minka's\nMLE is used to guess the dimension. Use of ``n_components == 'mle'``\nwill interpret ``svd_solver == 'auto'`` as ``svd_solver == 'full'``.\n\nIf ``0 < n_components < 1`` and ``svd_solver == 'full'``, select the\nnumber of components such that the amount of variance that needs to be\nexplained is greater than the percentage specified by n_components.\n\nIf ``svd_solver == 'arpack'``, the number of components must be\nstrictly less than the minimum of n_features and n_samples.\n\nHence, the None case results in::\n\n    n_components == min(n_samples, n_features) - 1"
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "float"
              },
              {
                "kind": "NamedType",
                "name": "'mle'"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._pca/PCA/__init__/n_components",
          "name": "n_components",
          "qname": "sklearn.decomposition._pca.PCA.__init__.n_components",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "int, float or 'mle'",
            "default_value": "None",
            "description": "Number of components to keep.\nif n_components is not set all components are kept::\n\n    n_components == min(n_samples, n_features)\n\nIf ``n_components == 'mle'`` and ``svd_solver == 'full'``, Minka's\nMLE is used to guess the dimension. Use of ``n_components == 'mle'``\nwill interpret ``svd_solver == 'auto'`` as ``svd_solver == 'full'``.\n\nIf ``0 < n_components < 1`` and ``svd_solver == 'full'``, select the\nnumber of components such that the amount of variance that needs to be\nexplained is greater than the percentage specified by n_components.\n\nIf ``svd_solver == 'arpack'``, the number of components must be\nstrictly less than the minimum of n_features and n_samples.\n\nHence, the None case results in::\n\n    n_components == min(n_samples, n_features) - 1"
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "float"
              },
              {
                "kind": "NamedType",
                "name": "'mle'"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If n_components equals mle and svd_solver equals full"
        },
        "hasAction": {
          "action": ", Minkas MLE is used to guess the dimension"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._pca/PCA/__init__/n_components",
          "name": "n_components",
          "qname": "sklearn.decomposition._pca.PCA.__init__.n_components",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "int, float or 'mle'",
            "default_value": "None",
            "description": "Number of components to keep.\nif n_components is not set all components are kept::\n\n    n_components == min(n_samples, n_features)\n\nIf ``n_components == 'mle'`` and ``svd_solver == 'full'``, Minka's\nMLE is used to guess the dimension. Use of ``n_components == 'mle'``\nwill interpret ``svd_solver == 'auto'`` as ``svd_solver == 'full'``.\n\nIf ``0 < n_components < 1`` and ``svd_solver == 'full'``, select the\nnumber of components such that the amount of variance that needs to be\nexplained is greater than the percentage specified by n_components.\n\nIf ``svd_solver == 'arpack'``, the number of components must be\nstrictly less than the minimum of n_features and n_samples.\n\nHence, the None case results in::\n\n    n_components == min(n_samples, n_features) - 1"
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "float"
              },
              {
                "kind": "NamedType",
                "name": "'mle'"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._pca/PCA/__init__/svd_solver",
          "name": "svd_solver",
          "qname": "sklearn.decomposition._pca.PCA.__init__.svd_solver",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'auto', 'full', 'arpack', 'randomized'}",
            "default_value": "'auto'",
            "description": "If auto :\n    The solver is selected by a default policy based on `X.shape` and\n    `n_components`: if the input data is larger than 500x500 and the\n    number of components to extract is lower than 80% of the smallest\n    dimension of the data, then the more efficient 'randomized'\n    method is enabled. Otherwise the exact full SVD is computed and\n    optionally truncated afterwards.\nIf full :\n    run exact full SVD calling the standard LAPACK solver via\n    `scipy.linalg.svd` and select the components by postprocessing\nIf arpack :\n    run SVD truncated to n_components calling ARPACK solver via\n    `scipy.sparse.linalg.svds`. It requires strictly\n    0 < n_components < min(X.shape)\nIf randomized :\n    run randomized SVD by the method of Halko et al.\n\n.. versionadded:: 0.18.0"
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "randomized",
              "full",
              "auto",
              "arpack"
            ]
          }
        },
        "hasCondition": {
          "condition": "as svd_solver equals full"
        },
        "hasAction": {
          "action": "svd_solver equals auto"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._pca/PCA/__init__/n_components",
          "name": "n_components",
          "qname": "sklearn.decomposition._pca.PCA.__init__.n_components",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "int, float or 'mle'",
            "default_value": "None",
            "description": "Number of components to keep.\nif n_components is not set all components are kept::\n\n    n_components == min(n_samples, n_features)\n\nIf ``n_components == 'mle'`` and ``svd_solver == 'full'``, Minka's\nMLE is used to guess the dimension. Use of ``n_components == 'mle'``\nwill interpret ``svd_solver == 'auto'`` as ``svd_solver == 'full'``.\n\nIf ``0 < n_components < 1`` and ``svd_solver == 'full'``, select the\nnumber of components such that the amount of variance that needs to be\nexplained is greater than the percentage specified by n_components.\n\nIf ``svd_solver == 'arpack'``, the number of components must be\nstrictly less than the minimum of n_features and n_samples.\n\nHence, the None case results in::\n\n    n_components == min(n_samples, n_features) - 1"
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "float"
              },
              {
                "kind": "NamedType",
                "name": "'mle'"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._pca/PCA/__init__/n_components",
          "name": "n_components",
          "qname": "sklearn.decomposition._pca.PCA.__init__.n_components",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "int, float or 'mle'",
            "default_value": "None",
            "description": "Number of components to keep.\nif n_components is not set all components are kept::\n\n    n_components == min(n_samples, n_features)\n\nIf ``n_components == 'mle'`` and ``svd_solver == 'full'``, Minka's\nMLE is used to guess the dimension. Use of ``n_components == 'mle'``\nwill interpret ``svd_solver == 'auto'`` as ``svd_solver == 'full'``.\n\nIf ``0 < n_components < 1`` and ``svd_solver == 'full'``, select the\nnumber of components such that the amount of variance that needs to be\nexplained is greater than the percentage specified by n_components.\n\nIf ``svd_solver == 'arpack'``, the number of components must be\nstrictly less than the minimum of n_features and n_samples.\n\nHence, the None case results in::\n\n    n_components == min(n_samples, n_features) - 1"
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "float"
              },
              {
                "kind": "NamedType",
                "name": "'mle'"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If 0 < n_components < 1 and svd_solver equals full"
        },
        "hasAction": {
          "action": ", select the number of components such that the amount of variance that needs to be explained is greater than the percentage specified by n_components"
        }
      }
    ]
  },
  "sklearn/sklearn.decomposition._pca/PCA/n_features_@getter": {},
  "sklearn/sklearn.decomposition._pca/PCA/fit": {},
  "sklearn/sklearn.decomposition._pca/PCA/fit_transform": {},
  "sklearn/sklearn.decomposition._pca/PCA/_fit": {},
  "sklearn/sklearn.decomposition._pca/PCA/_fit_full": {},
  "sklearn/sklearn.decomposition._pca/PCA/_fit_truncated": {},
  "sklearn/sklearn.decomposition._pca/PCA/score_samples": {},
  "sklearn/sklearn.decomposition._pca/PCA/score": {},
  "sklearn/sklearn.decomposition._pca/PCA/_more_tags": {},
  "sklearn/sklearn.decomposition._sparse_pca/_BaseSparsePCA/__init__": {},
  "sklearn/sklearn.decomposition._sparse_pca/_BaseSparsePCA/fit": {},
  "sklearn/sklearn.decomposition._sparse_pca/_BaseSparsePCA/transform": {},
  "sklearn/sklearn.decomposition._sparse_pca/_BaseSparsePCA/inverse_transform": {},
  "sklearn/sklearn.decomposition._sparse_pca/_BaseSparsePCA/_n_features_out@getter": {},
  "sklearn/sklearn.decomposition._sparse_pca/_BaseSparsePCA/_more_tags": {},
  "sklearn/sklearn.decomposition._sparse_pca/SparsePCA/__init__": {
    "U_init": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._sparse_pca/SparsePCA/__init__/U_init",
          "name": "U_init",
          "qname": "sklearn.decomposition._sparse_pca.SparsePCA.__init__.U_init",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "ndarray of shape (n_samples, n_components)",
            "default_value": "None",
            "description": "Initial values for the loadings for warm restart scenarios. Only used\nif `U_init` and `V_init` are not None."
          },
          "type": {
            "kind": "NamedType",
            "name": "ndarray of shape (n_samples, n_components)"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._sparse_pca/SparsePCA/__init__/U_init",
          "name": "U_init",
          "qname": "sklearn.decomposition._sparse_pca.SparsePCA.__init__.U_init",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "ndarray of shape (n_samples, n_components)",
            "default_value": "None",
            "description": "Initial values for the loadings for warm restart scenarios. Only used\nif `U_init` and `V_init` are not None."
          },
          "type": {
            "kind": "NamedType",
            "name": "ndarray of shape (n_samples, n_components)"
          }
        },
        "hasCondition": {
          "condition": "if U_init and V_init are not None"
        },
        "hasAction": {
          "action": "Only used"
        }
      }
    ],
    "V_init": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._sparse_pca/SparsePCA/__init__/V_init",
          "name": "V_init",
          "qname": "sklearn.decomposition._sparse_pca.SparsePCA.__init__.V_init",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "ndarray of shape (n_components, n_features)",
            "default_value": "None",
            "description": "Initial values for the components for warm restart scenarios. Only used\nif `U_init` and `V_init` are not None."
          },
          "type": {
            "kind": "NamedType",
            "name": "ndarray of shape (n_components, n_features)"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._sparse_pca/SparsePCA/__init__/U_init",
          "name": "U_init",
          "qname": "sklearn.decomposition._sparse_pca.SparsePCA.__init__.U_init",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "ndarray of shape (n_samples, n_components)",
            "default_value": "None",
            "description": "Initial values for the loadings for warm restart scenarios. Only used\nif `U_init` and `V_init` are not None."
          },
          "type": {
            "kind": "NamedType",
            "name": "ndarray of shape (n_samples, n_components)"
          }
        },
        "hasCondition": {
          "condition": "if U_init and V_init are not None"
        },
        "hasAction": {
          "action": "Only used"
        }
      }
    ]
  },
  "sklearn/sklearn.decomposition._sparse_pca/SparsePCA/_fit": {},
  "sklearn/sklearn.decomposition._sparse_pca/MiniBatchSparsePCA/__init__": {
    "max_iter": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._sparse_pca/MiniBatchSparsePCA/__init__/max_iter",
          "name": "max_iter",
          "qname": "sklearn.decomposition._sparse_pca.MiniBatchSparsePCA.__init__.max_iter",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "None",
            "description": "Maximum number of iterations over the complete dataset before\nstopping independently of any early stopping criterion heuristics.\nIf `max_iter` is not `None`, `n_iter` is ignored.\n\n.. versionadded:: 1.2"
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._sparse_pca/MiniBatchSparsePCA/__init__/max_iter",
          "name": "max_iter",
          "qname": "sklearn.decomposition._sparse_pca.MiniBatchSparsePCA.__init__.max_iter",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "None",
            "description": "Maximum number of iterations over the complete dataset before\nstopping independently of any early stopping criterion heuristics.\nIf `max_iter` is not `None`, `n_iter` is ignored.\n\n.. versionadded:: 1.2"
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "hasCondition": {
          "condition": "If max_iter is not None"
        },
        "hasAction": {
          "action": ", n_iter is ignored . .."
        }
      }
    ],
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._sparse_pca/MiniBatchSparsePCA/__init__/random_state",
          "name": "random_state",
          "qname": "sklearn.decomposition._sparse_pca.MiniBatchSparsePCA.__init__.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance or None",
            "default_value": "None",
            "description": "Used for random shuffling when ``shuffle`` is set to ``True``,\nduring online dictionary learning. Pass an int for reproducible results\nacross multiple function calls.\nSee :term:`Glossary <random_state>`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._sparse_pca/MiniBatchSparsePCA/__init__/shuffle",
          "name": "shuffle",
          "qname": "sklearn.decomposition._sparse_pca.MiniBatchSparsePCA.__init__.shuffle",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Whether to shuffle the data before splitting it in batches."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "when shuffle is set to True , during online dictionary learning"
        },
        "hasAction": {
          "action": "Used for random shuffling"
        }
      }
    ],
    "tol": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._sparse_pca/MiniBatchSparsePCA/__init__/tol",
          "name": "tol",
          "qname": "sklearn.decomposition._sparse_pca.MiniBatchSparsePCA.__init__.tol",
          "default_value": "0.001",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "1e-3",
            "description": "Control early stopping based on the norm of the differences in the\ndictionary between 2 steps. Used only if `max_iter` is not None.\n\nTo disable early stopping based on changes in the dictionary, set\n`tol` to 0.0.\n\n.. versionadded:: 1.1"
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._sparse_pca/MiniBatchSparsePCA/__init__/max_iter",
          "name": "max_iter",
          "qname": "sklearn.decomposition._sparse_pca.MiniBatchSparsePCA.__init__.max_iter",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "None",
            "description": "Maximum number of iterations over the complete dataset before\nstopping independently of any early stopping criterion heuristics.\nIf `max_iter` is not `None`, `n_iter` is ignored.\n\n.. versionadded:: 1.2"
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "hasCondition": {
          "condition": "only if max_iter is not None"
        },
        "hasAction": {
          "action": "Used"
        }
      }
    ],
    "max_no_improvement": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.decomposition._sparse_pca/MiniBatchSparsePCA/__init__/max_no_improvement",
          "name": "max_no_improvement",
          "qname": "sklearn.decomposition._sparse_pca.MiniBatchSparsePCA.__init__.max_no_improvement",
          "default_value": "10",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int or None",
            "default_value": "10",
            "description": "Control early stopping based on the consecutive number of mini batches\nthat does not yield an improvement on the smoothed cost function. Used only if\n`max_iter` is not None.\n\nTo disable convergence detection based on cost function, set\n`max_no_improvement` to `None`.\n\n.. versionadded:: 1.1"
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.decomposition._sparse_pca/MiniBatchSparsePCA/__init__/max_iter",
          "name": "max_iter",
          "qname": "sklearn.decomposition._sparse_pca.MiniBatchSparsePCA.__init__.max_iter",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "None",
            "description": "Maximum number of iterations over the complete dataset before\nstopping independently of any early stopping criterion heuristics.\nIf `max_iter` is not `None`, `n_iter` is ignored.\n\n.. versionadded:: 1.2"
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "hasCondition": {
          "condition": "only if max_iter is not None"
        },
        "hasAction": {
          "action": "Used"
        }
      }
    ]
  },
  "sklearn/sklearn.decomposition._sparse_pca/MiniBatchSparsePCA/_fit": {},
  "sklearn/sklearn.decomposition._truncated_svd/TruncatedSVD/__init__": {},
  "sklearn/sklearn.decomposition._truncated_svd/TruncatedSVD/fit": {},
  "sklearn/sklearn.decomposition._truncated_svd/TruncatedSVD/fit_transform": {},
  "sklearn/sklearn.decomposition._truncated_svd/TruncatedSVD/transform": {},
  "sklearn/sklearn.decomposition._truncated_svd/TruncatedSVD/inverse_transform": {},
  "sklearn/sklearn.decomposition._truncated_svd/TruncatedSVD/_more_tags": {},
  "sklearn/sklearn.decomposition._truncated_svd/TruncatedSVD/_n_features_out@getter": {},
  "sklearn/sklearn.ensemble._bagging/_generate_indices": {},
  "sklearn/sklearn.ensemble._bagging/_generate_bagging_indices": {},
  "sklearn/sklearn.ensemble._bagging/_parallel_build_estimators": {},
  "sklearn/sklearn.ensemble._bagging/_parallel_predict_proba": {},
  "sklearn/sklearn.ensemble._bagging/_parallel_predict_log_proba": {},
  "sklearn/sklearn.ensemble._bagging/_parallel_decision_function": {},
  "sklearn/sklearn.ensemble._bagging/_parallel_predict_regression": {},
  "sklearn/sklearn.ensemble._bagging/_estimator_has": {},
  "sklearn/sklearn.ensemble._bagging/BaseBagging/__init__": {},
  "sklearn/sklearn.ensemble._bagging/BaseBagging/fit": {},
  "sklearn/sklearn.ensemble._bagging/BaseBagging/_parallel_args": {},
  "sklearn/sklearn.ensemble._bagging/BaseBagging/_fit": {},
  "sklearn/sklearn.ensemble._bagging/BaseBagging/_set_oob_score": {},
  "sklearn/sklearn.ensemble._bagging/BaseBagging/_validate_y": {},
  "sklearn/sklearn.ensemble._bagging/BaseBagging/_get_estimators_indices": {},
  "sklearn/sklearn.ensemble._bagging/BaseBagging/estimators_samples_@getter": {},
  "sklearn/sklearn.ensemble._bagging/BaggingClassifier/__init__": {
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.ensemble._bagging/BaggingClassifier/__init__/random_state",
          "name": "random_state",
          "qname": "sklearn.ensemble._bagging.BaggingClassifier.__init__.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance or None",
            "default_value": "None",
            "description": "Controls the random resampling of the original dataset\n(sample wise and feature wise).\nIf the base estimator accepts a `random_state` attribute, a different\nseed is generated for each instance in the ensemble.\nPass an int for reproducible output across multiple function calls.\nSee :term:`Glossary <random_state>`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.ensemble._bagging/BaggingClassifier/__init__/estimator",
          "name": "estimator",
          "qname": "sklearn.ensemble._bagging.BaggingClassifier.__init__.estimator",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "object",
            "default_value": "None",
            "description": "The base estimator to fit on random subsets of the dataset.\nIf None, then the base estimator is a\n:class:`~sklearn.tree.DecisionTreeClassifier`.\n\n.. versionadded:: 1.2\n   `base_estimator` was renamed to `estimator`."
          },
          "type": {
            "kind": "NamedType",
            "name": "object"
          }
        },
        "hasCondition": {
          "condition": "If the base estimator accepts a random_state attribute"
        },
        "hasAction": {
          "action": ", a different seed is generated for each instance in the ensemble"
        }
      }
    ]
  },
  "sklearn/sklearn.ensemble._bagging/BaggingClassifier/_validate_estimator": {},
  "sklearn/sklearn.ensemble._bagging/BaggingClassifier/_set_oob_score": {},
  "sklearn/sklearn.ensemble._bagging/BaggingClassifier/_validate_y": {},
  "sklearn/sklearn.ensemble._bagging/BaggingClassifier/predict": {},
  "sklearn/sklearn.ensemble._bagging/BaggingClassifier/predict_proba": {},
  "sklearn/sklearn.ensemble._bagging/BaggingClassifier/predict_log_proba": {},
  "sklearn/sklearn.ensemble._bagging/BaggingClassifier/decision_function": {},
  "sklearn/sklearn.ensemble._bagging/BaggingRegressor/__init__": {
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.ensemble._bagging/BaggingRegressor/__init__/random_state",
          "name": "random_state",
          "qname": "sklearn.ensemble._bagging.BaggingRegressor.__init__.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance or None",
            "default_value": "None",
            "description": "Controls the random resampling of the original dataset\n(sample wise and feature wise).\nIf the base estimator accepts a `random_state` attribute, a different\nseed is generated for each instance in the ensemble.\nPass an int for reproducible output across multiple function calls.\nSee :term:`Glossary <random_state>`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.ensemble._bagging/BaggingRegressor/__init__/estimator",
          "name": "estimator",
          "qname": "sklearn.ensemble._bagging.BaggingRegressor.__init__.estimator",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "object",
            "default_value": "None",
            "description": "The base estimator to fit on random subsets of the dataset.\nIf None, then the base estimator is a\n:class:`~sklearn.tree.DecisionTreeRegressor`.\n\n.. versionadded:: 1.2\n   `base_estimator` was renamed to `estimator`."
          },
          "type": {
            "kind": "NamedType",
            "name": "object"
          }
        },
        "hasCondition": {
          "condition": "If the base estimator accepts a random_state attribute"
        },
        "hasAction": {
          "action": ", a different seed is generated for each instance in the ensemble"
        }
      }
    ]
  },
  "sklearn/sklearn.ensemble._bagging/BaggingRegressor/predict": {},
  "sklearn/sklearn.ensemble._bagging/BaggingRegressor/_validate_estimator": {},
  "sklearn/sklearn.ensemble._bagging/BaggingRegressor/_set_oob_score": {},
  "sklearn/sklearn.ensemble._base/_fit_single_estimator": {},
  "sklearn/sklearn.ensemble._base/_set_random_states": {},
  "sklearn/sklearn.ensemble._base/BaseEnsemble/__init__": {},
  "sklearn/sklearn.ensemble._base/BaseEnsemble/_validate_estimator": {},
  "sklearn/sklearn.ensemble._base/BaseEnsemble/base_estimator_@getter": {},
  "sklearn/sklearn.ensemble._base/BaseEnsemble/estimator_@getter": {},
  "sklearn/sklearn.ensemble._base/BaseEnsemble/_make_estimator": {},
  "sklearn/sklearn.ensemble._base/BaseEnsemble/__len__": {},
  "sklearn/sklearn.ensemble._base/BaseEnsemble/__getitem__": {},
  "sklearn/sklearn.ensemble._base/BaseEnsemble/__iter__": {},
  "sklearn/sklearn.ensemble._base/_partition_estimators": {},
  "sklearn/sklearn.ensemble._base/_BaseHeterogeneousEnsemble/named_estimators@getter": {},
  "sklearn/sklearn.ensemble._base/_BaseHeterogeneousEnsemble/__init__": {},
  "sklearn/sklearn.ensemble._base/_BaseHeterogeneousEnsemble/_validate_estimators": {},
  "sklearn/sklearn.ensemble._base/_BaseHeterogeneousEnsemble/set_params": {},
  "sklearn/sklearn.ensemble._base/_BaseHeterogeneousEnsemble/get_params": {},
  "sklearn/sklearn.ensemble._forest/_get_n_samples_bootstrap": {},
  "sklearn/sklearn.ensemble._forest/_generate_sample_indices": {},
  "sklearn/sklearn.ensemble._forest/_generate_unsampled_indices": {},
  "sklearn/sklearn.ensemble._forest/_parallel_build_trees": {},
  "sklearn/sklearn.ensemble._forest/BaseForest/__init__": {},
  "sklearn/sklearn.ensemble._forest/BaseForest/apply": {},
  "sklearn/sklearn.ensemble._forest/BaseForest/decision_path": {},
  "sklearn/sklearn.ensemble._forest/BaseForest/fit": {},
  "sklearn/sklearn.ensemble._forest/BaseForest/_set_oob_score_and_attributes": {},
  "sklearn/sklearn.ensemble._forest/BaseForest/_compute_oob_predictions": {},
  "sklearn/sklearn.ensemble._forest/BaseForest/_validate_y_class_weight": {},
  "sklearn/sklearn.ensemble._forest/BaseForest/_validate_X_predict": {},
  "sklearn/sklearn.ensemble._forest/BaseForest/feature_importances_@getter": {},
  "sklearn/sklearn.ensemble._forest/_accumulate_prediction": {},
  "sklearn/sklearn.ensemble._forest/ForestClassifier/__init__": {},
  "sklearn/sklearn.ensemble._forest/ForestClassifier/_get_oob_predictions": {},
  "sklearn/sklearn.ensemble._forest/ForestClassifier/_set_oob_score_and_attributes": {},
  "sklearn/sklearn.ensemble._forest/ForestClassifier/_validate_y_class_weight": {},
  "sklearn/sklearn.ensemble._forest/ForestClassifier/predict": {},
  "sklearn/sklearn.ensemble._forest/ForestClassifier/predict_proba": {},
  "sklearn/sklearn.ensemble._forest/ForestClassifier/predict_log_proba": {},
  "sklearn/sklearn.ensemble._forest/ForestClassifier/_more_tags": {},
  "sklearn/sklearn.ensemble._forest/ForestRegressor/__init__": {},
  "sklearn/sklearn.ensemble._forest/ForestRegressor/predict": {},
  "sklearn/sklearn.ensemble._forest/ForestRegressor/_get_oob_predictions": {},
  "sklearn/sklearn.ensemble._forest/ForestRegressor/_set_oob_score_and_attributes": {},
  "sklearn/sklearn.ensemble._forest/ForestRegressor/_compute_partial_dependence_recursion": {},
  "sklearn/sklearn.ensemble._forest/ForestRegressor/_more_tags": {},
  "sklearn/sklearn.ensemble._forest/RandomForestClassifier/__init__": {
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.ensemble._forest/RandomForestClassifier/__init__/random_state",
          "name": "random_state",
          "qname": "sklearn.ensemble._forest.RandomForestClassifier.__init__.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance or None",
            "default_value": "None",
            "description": "Controls both the randomness of the bootstrapping of the samples used\nwhen building trees (if ``bootstrap=True``) and the sampling of the\nfeatures to consider when looking for the best split at each node\n(if ``max_features < n_features``).\nSee :term:`Glossary <random_state>` for details."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.ensemble._forest/RandomForestClassifier/__init__/bootstrap",
          "name": "bootstrap",
          "qname": "sklearn.ensemble._forest.RandomForestClassifier.__init__.bootstrap",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Whether bootstrap samples are used when building trees. If False, the\nwhole dataset is used to build each tree."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "if bootstrap equals True ) and the sampling of the features to consider when looking for the best split at each node ( if max_features < n_features )"
        },
        "hasAction": {
          "action": "Controls both the randomness of the bootstrapping of the samples used when building trees ("
        }
      }
    ]
  },
  "sklearn/sklearn.ensemble._forest/RandomForestRegressor/__init__": {
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.ensemble._forest/RandomForestRegressor/__init__/random_state",
          "name": "random_state",
          "qname": "sklearn.ensemble._forest.RandomForestRegressor.__init__.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance or None",
            "default_value": "None",
            "description": "Controls both the randomness of the bootstrapping of the samples used\nwhen building trees (if ``bootstrap=True``) and the sampling of the\nfeatures to consider when looking for the best split at each node\n(if ``max_features < n_features``).\nSee :term:`Glossary <random_state>` for details."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.ensemble._forest/RandomForestRegressor/__init__/bootstrap",
          "name": "bootstrap",
          "qname": "sklearn.ensemble._forest.RandomForestRegressor.__init__.bootstrap",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Whether bootstrap samples are used when building trees. If False, the\nwhole dataset is used to build each tree."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "if bootstrap equals True ) and the sampling of the features to consider when looking for the best split at each node ( if max_features < n_features )"
        },
        "hasAction": {
          "action": "Controls both the randomness of the bootstrapping of the samples used when building trees ("
        }
      }
    ]
  },
  "sklearn/sklearn.ensemble._forest/ExtraTreesClassifier/__init__": {
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.ensemble._forest/ExtraTreesClassifier/__init__/random_state",
          "name": "random_state",
          "qname": "sklearn.ensemble._forest.ExtraTreesClassifier.__init__.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance or None",
            "default_value": "None",
            "description": "Controls 3 sources of randomness:\n\n- the bootstrapping of the samples used when building trees\n  (if ``bootstrap=True``)\n- the sampling of the features to consider when looking for the best\n  split at each node (if ``max_features < n_features``)\n- the draw of the splits for each of the `max_features`\n\nSee :term:`Glossary <random_state>` for details."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.ensemble._forest/ExtraTreesClassifier/__init__/bootstrap",
          "name": "bootstrap",
          "qname": "sklearn.ensemble._forest.ExtraTreesClassifier.__init__.bootstrap",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "Whether bootstrap samples are used when building trees. If False, the\nwhole dataset is used to build each tree."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "when building trees ( if bootstrap equals True"
        },
        "hasAction": {
          "action": "used"
        }
      }
    ]
  },
  "sklearn/sklearn.ensemble._forest/ExtraTreesRegressor/__init__": {
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.ensemble._forest/ExtraTreesRegressor/__init__/random_state",
          "name": "random_state",
          "qname": "sklearn.ensemble._forest.ExtraTreesRegressor.__init__.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance or None",
            "default_value": "None",
            "description": "Controls 3 sources of randomness:\n\n- the bootstrapping of the samples used when building trees\n  (if ``bootstrap=True``)\n- the sampling of the features to consider when looking for the best\n  split at each node (if ``max_features < n_features``)\n- the draw of the splits for each of the `max_features`\n\nSee :term:`Glossary <random_state>` for details."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.ensemble._forest/ExtraTreesRegressor/__init__/bootstrap",
          "name": "bootstrap",
          "qname": "sklearn.ensemble._forest.ExtraTreesRegressor.__init__.bootstrap",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "Whether bootstrap samples are used when building trees. If False, the\nwhole dataset is used to build each tree."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "when building trees ( if bootstrap equals True"
        },
        "hasAction": {
          "action": "used"
        }
      }
    ]
  },
  "sklearn/sklearn.ensemble._forest/RandomTreesEmbedding/__init__": {},
  "sklearn/sklearn.ensemble._forest/RandomTreesEmbedding/_set_oob_score_and_attributes": {},
  "sklearn/sklearn.ensemble._forest/RandomTreesEmbedding/fit": {},
  "sklearn/sklearn.ensemble._forest/RandomTreesEmbedding/fit_transform": {},
  "sklearn/sklearn.ensemble._forest/RandomTreesEmbedding/get_feature_names_out": {},
  "sklearn/sklearn.ensemble._forest/RandomTreesEmbedding/transform": {},
  "sklearn/sklearn.ensemble._gb/VerboseReporter/__init__": {
    "verbose": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.ensemble._gb/VerboseReporter/__init__/verbose",
          "name": "verbose",
          "qname": "sklearn.ensemble._gb.VerboseReporter.__init__.verbose",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "int",
            "default_value": "",
            "description": "Verbosity level. If ``verbose==1`` output is printed once in a while\n(when iteration mod verbose_mod is zero).; if larger than 1 then output\nis printed for each update."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.ensemble._gb/VerboseReporter/__init__/verbose",
          "name": "verbose",
          "qname": "sklearn.ensemble._gb.VerboseReporter.__init__.verbose",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "int",
            "default_value": "",
            "description": "Verbosity level. If ``verbose==1`` output is printed once in a while\n(when iteration mod verbose_mod is zero).; if larger than 1 then output\nis printed for each update."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "hasCondition": {
          "condition": "If verbose equals"
        },
        "hasAction": {
          "action": "1 output is printed once in a while ( when iteration mod verbose_mod is zero ) . ; if larger than 1 then output is printed for each update"
        }
      }
    ]
  },
  "sklearn/sklearn.ensemble._gb/VerboseReporter/init": {},
  "sklearn/sklearn.ensemble._gb/VerboseReporter/update": {},
  "sklearn/sklearn.ensemble._gb/BaseGradientBoosting/__init__": {},
  "sklearn/sklearn.ensemble._gb/BaseGradientBoosting/_validate_y": {},
  "sklearn/sklearn.ensemble._gb/BaseGradientBoosting/_fit_stage": {},
  "sklearn/sklearn.ensemble._gb/BaseGradientBoosting/_check_params": {},
  "sklearn/sklearn.ensemble._gb/BaseGradientBoosting/_init_state": {},
  "sklearn/sklearn.ensemble._gb/BaseGradientBoosting/_clear_state": {},
  "sklearn/sklearn.ensemble._gb/BaseGradientBoosting/_resize_state": {},
  "sklearn/sklearn.ensemble._gb/BaseGradientBoosting/_is_initialized": {},
  "sklearn/sklearn.ensemble._gb/BaseGradientBoosting/_check_initialized": {},
  "sklearn/sklearn.ensemble._gb/BaseGradientBoosting/fit": {},
  "sklearn/sklearn.ensemble._gb/BaseGradientBoosting/_fit_stages": {},
  "sklearn/sklearn.ensemble._gb/BaseGradientBoosting/_make_estimator": {},
  "sklearn/sklearn.ensemble._gb/BaseGradientBoosting/_raw_predict_init": {},
  "sklearn/sklearn.ensemble._gb/BaseGradientBoosting/_raw_predict": {},
  "sklearn/sklearn.ensemble._gb/BaseGradientBoosting/_staged_raw_predict": {},
  "sklearn/sklearn.ensemble._gb/BaseGradientBoosting/feature_importances_@getter": {},
  "sklearn/sklearn.ensemble._gb/BaseGradientBoosting/_compute_partial_dependence_recursion": {},
  "sklearn/sklearn.ensemble._gb/BaseGradientBoosting/apply": {},
  "sklearn/sklearn.ensemble._gb/BaseGradientBoosting/loss_@getter": {},
  "sklearn/sklearn.ensemble._gb/GradientBoostingClassifier/__init__": {
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.ensemble._gb/GradientBoostingClassifier/__init__/random_state",
          "name": "random_state",
          "qname": "sklearn.ensemble._gb.GradientBoostingClassifier.__init__.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance or None",
            "default_value": "None",
            "description": "Controls the random seed given to each Tree estimator at each\nboosting iteration.\nIn addition, it controls the random permutation of the features at\neach split (see Notes for more details).\nIt also controls the random splitting of the training data to obtain a\nvalidation set if `n_iter_no_change` is not None.\nPass an int for reproducible output across multiple function calls.\nSee :term:`Glossary <random_state>`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.ensemble._gb/GradientBoostingClassifier/__init__/n_iter_no_change",
          "name": "n_iter_no_change",
          "qname": "sklearn.ensemble._gb.GradientBoostingClassifier.__init__.n_iter_no_change",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "None",
            "description": "``n_iter_no_change`` is used to decide if early stopping will be used\nto terminate training when validation score is not improving. By\ndefault it is set to None to disable early stopping. If set to a\nnumber, it will set aside ``validation_fraction`` size of the training\ndata as validation and terminate training when validation score is not\nimproving in all of the previous ``n_iter_no_change`` numbers of\niterations. The split is stratified.\nValues must be in the range `[1, inf)`.\n\n.. versionadded:: 0.20"
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "hasCondition": {
          "condition": "if n_iter_no_change is not None"
        },
        "hasAction": {
          "action": "to obtain a validation set"
        }
      }
    ],
    "validation_fraction": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.ensemble._gb/GradientBoostingClassifier/__init__/validation_fraction",
          "name": "validation_fraction",
          "qname": "sklearn.ensemble._gb.GradientBoostingClassifier.__init__.validation_fraction",
          "default_value": "0.1",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "0.1",
            "description": "The proportion of training data to set aside as validation set for\nearly stopping. Values must be in the range `(0.0, 1.0)`.\nOnly used if ``n_iter_no_change`` is set to an integer.\n\n.. versionadded:: 0.20"
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "BoundaryType",
                "base_type": "float",
                "min": 0.0,
                "max": 1.0,
                "min_inclusive": false,
                "max_inclusive": false
              },
              {
                "kind": "NamedType",
                "name": "float"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.ensemble._gb/GradientBoostingClassifier/__init__/n_iter_no_change",
          "name": "n_iter_no_change",
          "qname": "sklearn.ensemble._gb.GradientBoostingClassifier.__init__.n_iter_no_change",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "None",
            "description": "``n_iter_no_change`` is used to decide if early stopping will be used\nto terminate training when validation score is not improving. By\ndefault it is set to None to disable early stopping. If set to a\nnumber, it will set aside ``validation_fraction`` size of the training\ndata as validation and terminate training when validation score is not\nimproving in all of the previous ``n_iter_no_change`` numbers of\niterations. The split is stratified.\nValues must be in the range `[1, inf)`.\n\n.. versionadded:: 0.20"
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "hasCondition": {
          "condition": "if n_iter_no_change is set to an integer"
        },
        "hasAction": {
          "action": "Only used"
        }
      }
    ],
    "tol": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.ensemble._gb/GradientBoostingClassifier/__init__/tol",
          "name": "tol",
          "qname": "sklearn.ensemble._gb.GradientBoostingClassifier.__init__.tol",
          "default_value": "0.0001",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "1e-4",
            "description": "Tolerance for the early stopping. When the loss is not improving\nby at least tol for ``n_iter_no_change`` iterations (if set to a\nnumber), the training stops.\nValues must be in the range `[0.0, inf)`.\n\n.. versionadded:: 0.20"
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.ensemble._gb/GradientBoostingClassifier/__init__/loss",
          "name": "loss",
          "qname": "sklearn.ensemble._gb.GradientBoostingClassifier.__init__.loss",
          "default_value": "'log_loss'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'log_loss', 'deviance', 'exponential'}",
            "default_value": "'log_loss'",
            "description": "The loss function to be optimized. 'log_loss' refers to binomial and\nmultinomial deviance, the same as used in logistic regression.\nIt is a good choice for classification with probabilistic outputs.\nFor loss 'exponential', gradient boosting recovers the AdaBoost algorithm.\n\n.. deprecated:: 1.1\n    The loss 'deviance' was deprecated in v1.1 and will be removed in\n    version 1.3. Use `loss='log_loss'` which is equivalent."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "deviance",
              "exponential",
              "log_loss"
            ]
          }
        },
        "hasCondition": {
          "condition": "When the loss is not improving by at least tol for n_iter_no_change iterations ( if set to a number )"
        },
        "hasAction": {
          "action": ", the training stops"
        }
      }
    ]
  },
  "sklearn/sklearn.ensemble._gb/GradientBoostingClassifier/_validate_y": {},
  "sklearn/sklearn.ensemble._gb/GradientBoostingClassifier/decision_function": {},
  "sklearn/sklearn.ensemble._gb/GradientBoostingClassifier/staged_decision_function": {},
  "sklearn/sklearn.ensemble._gb/GradientBoostingClassifier/predict": {},
  "sklearn/sklearn.ensemble._gb/GradientBoostingClassifier/staged_predict": {},
  "sklearn/sklearn.ensemble._gb/GradientBoostingClassifier/predict_proba": {},
  "sklearn/sklearn.ensemble._gb/GradientBoostingClassifier/predict_log_proba": {},
  "sklearn/sklearn.ensemble._gb/GradientBoostingClassifier/staged_predict_proba": {},
  "sklearn/sklearn.ensemble._gb/GradientBoostingRegressor/__init__": {
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.ensemble._gb/GradientBoostingRegressor/__init__/random_state",
          "name": "random_state",
          "qname": "sklearn.ensemble._gb.GradientBoostingRegressor.__init__.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance or None",
            "default_value": "None",
            "description": "Controls the random seed given to each Tree estimator at each\nboosting iteration.\nIn addition, it controls the random permutation of the features at\neach split (see Notes for more details).\nIt also controls the random splitting of the training data to obtain a\nvalidation set if `n_iter_no_change` is not None.\nPass an int for reproducible output across multiple function calls.\nSee :term:`Glossary <random_state>`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.ensemble._gb/GradientBoostingRegressor/__init__/n_iter_no_change",
          "name": "n_iter_no_change",
          "qname": "sklearn.ensemble._gb.GradientBoostingRegressor.__init__.n_iter_no_change",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "None",
            "description": "``n_iter_no_change`` is used to decide if early stopping will be used\nto terminate training when validation score is not improving. By\ndefault it is set to None to disable early stopping. If set to a\nnumber, it will set aside ``validation_fraction`` size of the training\ndata as validation and terminate training when validation score is not\nimproving in all of the previous ``n_iter_no_change`` numbers of\niterations.\nValues must be in the range `[1, inf)`.\n\n.. versionadded:: 0.20"
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "hasCondition": {
          "condition": "if n_iter_no_change is not None"
        },
        "hasAction": {
          "action": "to obtain a validation set"
        }
      }
    ],
    "alpha": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.ensemble._gb/GradientBoostingRegressor/__init__/alpha",
          "name": "alpha",
          "qname": "sklearn.ensemble._gb.GradientBoostingRegressor.__init__.alpha",
          "default_value": "0.9",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "0.9",
            "description": "The alpha-quantile of the huber loss function and the quantile\nloss function. Only if ``loss='huber'`` or ``loss='quantile'``.\nValues must be in the range `(0.0, 1.0)`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "BoundaryType",
                "base_type": "float",
                "min": 0.0,
                "max": 1.0,
                "min_inclusive": false,
                "max_inclusive": false
              },
              {
                "kind": "NamedType",
                "name": "float"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.ensemble._gb/GradientBoostingRegressor/__init__/loss",
          "name": "loss",
          "qname": "sklearn.ensemble._gb.GradientBoostingRegressor.__init__.loss",
          "default_value": "'squared_error'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'squared_error', 'absolute_error', 'huber', 'quantile'}",
            "default_value": "'squared_error'",
            "description": "Loss function to be optimized. 'squared_error' refers to the squared\nerror for regression. 'absolute_error' refers to the absolute error of\nregression and is a robust loss function. 'huber' is a\ncombination of the two. 'quantile' allows quantile regression (use\n`alpha` to specify the quantile)."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "squared_error",
              "absolute_error",
              "quantile",
              "huber"
            ]
          }
        },
        "hasCondition": {
          "condition": "Only if loss equals huber or loss"
        },
        "hasAction": {
          "action": "equals quantile"
        }
      }
    ],
    "validation_fraction": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.ensemble._gb/GradientBoostingRegressor/__init__/validation_fraction",
          "name": "validation_fraction",
          "qname": "sklearn.ensemble._gb.GradientBoostingRegressor.__init__.validation_fraction",
          "default_value": "0.1",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "0.1",
            "description": "The proportion of training data to set aside as validation set for\nearly stopping. Values must be in the range `(0.0, 1.0)`.\nOnly used if ``n_iter_no_change`` is set to an integer.\n\n.. versionadded:: 0.20"
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "BoundaryType",
                "base_type": "float",
                "min": 0.0,
                "max": 1.0,
                "min_inclusive": false,
                "max_inclusive": false
              },
              {
                "kind": "NamedType",
                "name": "float"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.ensemble._gb/GradientBoostingRegressor/__init__/n_iter_no_change",
          "name": "n_iter_no_change",
          "qname": "sklearn.ensemble._gb.GradientBoostingRegressor.__init__.n_iter_no_change",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "None",
            "description": "``n_iter_no_change`` is used to decide if early stopping will be used\nto terminate training when validation score is not improving. By\ndefault it is set to None to disable early stopping. If set to a\nnumber, it will set aside ``validation_fraction`` size of the training\ndata as validation and terminate training when validation score is not\nimproving in all of the previous ``n_iter_no_change`` numbers of\niterations.\nValues must be in the range `[1, inf)`.\n\n.. versionadded:: 0.20"
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "hasCondition": {
          "condition": "if n_iter_no_change is set to an integer"
        },
        "hasAction": {
          "action": "Only used"
        }
      }
    ],
    "tol": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.ensemble._gb/GradientBoostingRegressor/__init__/tol",
          "name": "tol",
          "qname": "sklearn.ensemble._gb.GradientBoostingRegressor.__init__.tol",
          "default_value": "0.0001",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "1e-4",
            "description": "Tolerance for the early stopping. When the loss is not improving\nby at least tol for ``n_iter_no_change`` iterations (if set to a\nnumber), the training stops.\nValues must be in the range `[0.0, inf)`.\n\n.. versionadded:: 0.20"
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.ensemble._gb/GradientBoostingRegressor/__init__/loss",
          "name": "loss",
          "qname": "sklearn.ensemble._gb.GradientBoostingRegressor.__init__.loss",
          "default_value": "'squared_error'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'squared_error', 'absolute_error', 'huber', 'quantile'}",
            "default_value": "'squared_error'",
            "description": "Loss function to be optimized. 'squared_error' refers to the squared\nerror for regression. 'absolute_error' refers to the absolute error of\nregression and is a robust loss function. 'huber' is a\ncombination of the two. 'quantile' allows quantile regression (use\n`alpha` to specify the quantile)."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "squared_error",
              "absolute_error",
              "quantile",
              "huber"
            ]
          }
        },
        "hasCondition": {
          "condition": "When the loss is not improving by at least tol for n_iter_no_change iterations ( if set to a number )"
        },
        "hasAction": {
          "action": ", the training stops"
        }
      }
    ]
  },
  "sklearn/sklearn.ensemble._gb/GradientBoostingRegressor/_validate_y": {},
  "sklearn/sklearn.ensemble._gb/GradientBoostingRegressor/predict": {},
  "sklearn/sklearn.ensemble._gb/GradientBoostingRegressor/staged_predict": {},
  "sklearn/sklearn.ensemble._gb/GradientBoostingRegressor/apply": {},
  "sklearn/sklearn.ensemble._gb_losses/LossFunction/__init__": {},
  "sklearn/sklearn.ensemble._gb_losses/LossFunction/init_estimator": {},
  "sklearn/sklearn.ensemble._gb_losses/LossFunction/__call__": {},
  "sklearn/sklearn.ensemble._gb_losses/LossFunction/negative_gradient": {},
  "sklearn/sklearn.ensemble._gb_losses/LossFunction/update_terminal_regions": {},
  "sklearn/sklearn.ensemble._gb_losses/LossFunction/_update_terminal_region": {},
  "sklearn/sklearn.ensemble._gb_losses/LossFunction/get_init_raw_predictions": {},
  "sklearn/sklearn.ensemble._gb_losses/RegressionLossFunction/__init__": {},
  "sklearn/sklearn.ensemble._gb_losses/RegressionLossFunction/check_init_estimator": {},
  "sklearn/sklearn.ensemble._gb_losses/RegressionLossFunction/get_init_raw_predictions": {},
  "sklearn/sklearn.ensemble._gb_losses/LeastSquaresError/init_estimator": {},
  "sklearn/sklearn.ensemble._gb_losses/LeastSquaresError/__call__": {},
  "sklearn/sklearn.ensemble._gb_losses/LeastSquaresError/negative_gradient": {},
  "sklearn/sklearn.ensemble._gb_losses/LeastSquaresError/update_terminal_regions": {},
  "sklearn/sklearn.ensemble._gb_losses/LeastSquaresError/_update_terminal_region": {},
  "sklearn/sklearn.ensemble._gb_losses/LeastAbsoluteError/init_estimator": {},
  "sklearn/sklearn.ensemble._gb_losses/LeastAbsoluteError/__call__": {},
  "sklearn/sklearn.ensemble._gb_losses/LeastAbsoluteError/negative_gradient": {},
  "sklearn/sklearn.ensemble._gb_losses/LeastAbsoluteError/_update_terminal_region": {},
  "sklearn/sklearn.ensemble._gb_losses/HuberLossFunction/__init__": {},
  "sklearn/sklearn.ensemble._gb_losses/HuberLossFunction/init_estimator": {},
  "sklearn/sklearn.ensemble._gb_losses/HuberLossFunction/__call__": {},
  "sklearn/sklearn.ensemble._gb_losses/HuberLossFunction/negative_gradient": {},
  "sklearn/sklearn.ensemble._gb_losses/HuberLossFunction/_update_terminal_region": {},
  "sklearn/sklearn.ensemble._gb_losses/QuantileLossFunction/__init__": {},
  "sklearn/sklearn.ensemble._gb_losses/QuantileLossFunction/init_estimator": {},
  "sklearn/sklearn.ensemble._gb_losses/QuantileLossFunction/__call__": {},
  "sklearn/sklearn.ensemble._gb_losses/QuantileLossFunction/negative_gradient": {},
  "sklearn/sklearn.ensemble._gb_losses/QuantileLossFunction/_update_terminal_region": {},
  "sklearn/sklearn.ensemble._gb_losses/ClassificationLossFunction/_raw_prediction_to_proba": {},
  "sklearn/sklearn.ensemble._gb_losses/ClassificationLossFunction/_raw_prediction_to_decision": {},
  "sklearn/sklearn.ensemble._gb_losses/ClassificationLossFunction/check_init_estimator": {},
  "sklearn/sklearn.ensemble._gb_losses/BinomialDeviance/__init__": {},
  "sklearn/sklearn.ensemble._gb_losses/BinomialDeviance/init_estimator": {},
  "sklearn/sklearn.ensemble._gb_losses/BinomialDeviance/__call__": {},
  "sklearn/sklearn.ensemble._gb_losses/BinomialDeviance/negative_gradient": {},
  "sklearn/sklearn.ensemble._gb_losses/BinomialDeviance/_update_terminal_region": {},
  "sklearn/sklearn.ensemble._gb_losses/BinomialDeviance/_raw_prediction_to_proba": {},
  "sklearn/sklearn.ensemble._gb_losses/BinomialDeviance/_raw_prediction_to_decision": {},
  "sklearn/sklearn.ensemble._gb_losses/BinomialDeviance/get_init_raw_predictions": {},
  "sklearn/sklearn.ensemble._gb_losses/MultinomialDeviance/__init__": {},
  "sklearn/sklearn.ensemble._gb_losses/MultinomialDeviance/init_estimator": {},
  "sklearn/sklearn.ensemble._gb_losses/MultinomialDeviance/__call__": {},
  "sklearn/sklearn.ensemble._gb_losses/MultinomialDeviance/negative_gradient": {},
  "sklearn/sklearn.ensemble._gb_losses/MultinomialDeviance/_update_terminal_region": {},
  "sklearn/sklearn.ensemble._gb_losses/MultinomialDeviance/_raw_prediction_to_proba": {},
  "sklearn/sklearn.ensemble._gb_losses/MultinomialDeviance/_raw_prediction_to_decision": {},
  "sklearn/sklearn.ensemble._gb_losses/MultinomialDeviance/get_init_raw_predictions": {},
  "sklearn/sklearn.ensemble._gb_losses/ExponentialLoss/__init__": {},
  "sklearn/sklearn.ensemble._gb_losses/ExponentialLoss/init_estimator": {},
  "sklearn/sklearn.ensemble._gb_losses/ExponentialLoss/__call__": {},
  "sklearn/sklearn.ensemble._gb_losses/ExponentialLoss/negative_gradient": {},
  "sklearn/sklearn.ensemble._gb_losses/ExponentialLoss/_update_terminal_region": {},
  "sklearn/sklearn.ensemble._gb_losses/ExponentialLoss/_raw_prediction_to_proba": {},
  "sklearn/sklearn.ensemble._gb_losses/ExponentialLoss/_raw_prediction_to_decision": {},
  "sklearn/sklearn.ensemble._gb_losses/ExponentialLoss/get_init_raw_predictions": {},
  "sklearn/sklearn.ensemble._iforest/IsolationForest/__init__": {
    "max_samples": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.ensemble._iforest/IsolationForest/__init__/max_samples",
          "name": "max_samples",
          "qname": "sklearn.ensemble._iforest.IsolationForest.__init__.max_samples",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "\"auto\", int or float",
            "default_value": "\"auto\"",
            "description": "The number of samples to draw from X to train each base estimator.\n    - If int, then draw `max_samples` samples.\n    - If float, then draw `max_samples * X.shape[0]` samples.\n    - If \"auto\", then `max_samples=min(256, n_samples)`.\n\nIf max_samples is larger than the number of samples provided,\nall samples will be used for all trees (no sampling)."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "\"auto\""
              },
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "float"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.ensemble._iforest/IsolationForest/__init__/max_samples",
          "name": "max_samples",
          "qname": "sklearn.ensemble._iforest.IsolationForest.__init__.max_samples",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "\"auto\", int or float",
            "default_value": "\"auto\"",
            "description": "The number of samples to draw from X to train each base estimator.\n    - If int, then draw `max_samples` samples.\n    - If float, then draw `max_samples * X.shape[0]` samples.\n    - If \"auto\", then `max_samples=min(256, n_samples)`.\n\nIf max_samples is larger than the number of samples provided,\nall samples will be used for all trees (no sampling)."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "\"auto\""
              },
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "float"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If max_samples is larger than the number of samples provided"
        },
        "hasAction": {
          "action": ", all samples will be used for all trees ( no sampling )"
        }
      }
    ]
  },
  "sklearn/sklearn.ensemble._iforest/IsolationForest/_set_oob_score": {},
  "sklearn/sklearn.ensemble._iforest/IsolationForest/_parallel_args": {},
  "sklearn/sklearn.ensemble._iforest/IsolationForest/fit": {},
  "sklearn/sklearn.ensemble._iforest/IsolationForest/predict": {},
  "sklearn/sklearn.ensemble._iforest/IsolationForest/decision_function": {},
  "sklearn/sklearn.ensemble._iforest/IsolationForest/score_samples": {},
  "sklearn/sklearn.ensemble._iforest/IsolationForest/_compute_chunked_score_samples": {},
  "sklearn/sklearn.ensemble._iforest/IsolationForest/_compute_score_samples": {},
  "sklearn/sklearn.ensemble._iforest/IsolationForest/_more_tags": {},
  "sklearn/sklearn.ensemble._iforest/_average_path_length": {},
  "sklearn/sklearn.ensemble._stacking/_estimator_has": {},
  "sklearn/sklearn.ensemble._stacking/_BaseStacking/__init__": {},
  "sklearn/sklearn.ensemble._stacking/_BaseStacking/_clone_final_estimator": {},
  "sklearn/sklearn.ensemble._stacking/_BaseStacking/_concatenate_predictions": {},
  "sklearn/sklearn.ensemble._stacking/_BaseStacking/_method_name": {},
  "sklearn/sklearn.ensemble._stacking/_BaseStacking/fit": {},
  "sklearn/sklearn.ensemble._stacking/_BaseStacking/n_features_in_@getter": {},
  "sklearn/sklearn.ensemble._stacking/_BaseStacking/_transform": {},
  "sklearn/sklearn.ensemble._stacking/_BaseStacking/get_feature_names_out": {
    "input_features": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.ensemble._stacking/_BaseStacking/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.ensemble._stacking._BaseStacking.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features. The input feature names are only used when `passthrough` is\n`True`.\n\n- If `input_features` is `None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then names are generated: `[x0, x1, ..., x(n_features_in_ - 1)]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined.\n\nIf `passthrough` is `False`, then only the names of `estimators` are used\nto generate the output feature names."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.ensemble._stacking/_BaseStacking/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.ensemble._stacking._BaseStacking.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features. The input feature names are only used when `passthrough` is\n`True`.\n\n- If `input_features` is `None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then names are generated: `[x0, x1, ..., x(n_features_in_ - 1)]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined.\n\nIf `passthrough` is `False`, then only the names of `estimators` are used\nto generate the output feature names."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If input_features is None , then feature_names_in _"
        },
        "hasAction": {
          "action": "is used as feature names in"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.ensemble._stacking/_BaseStacking/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.ensemble._stacking._BaseStacking.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features. The input feature names are only used when `passthrough` is\n`True`.\n\n- If `input_features` is `None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then names are generated: `[x0, x1, ..., x(n_features_in_ - 1)]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined.\n\nIf `passthrough` is `False`, then only the names of `estimators` are used\nto generate the output feature names."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.ensemble._stacking/_BaseStacking/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.ensemble._stacking._BaseStacking.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features. The input feature names are only used when `passthrough` is\n`True`.\n\n- If `input_features` is `None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then names are generated: `[x0, x1, ..., x(n_features_in_ - 1)]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined.\n\nIf `passthrough` is `False`, then only the names of `estimators` are used\nto generate the output feature names."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If input_features is"
        },
        "hasAction": {
          "action": "an array - like , then input_features must match feature_names_in _"
        }
      }
    ]
  },
  "sklearn/sklearn.ensemble._stacking/_BaseStacking/predict": {},
  "sklearn/sklearn.ensemble._stacking/_BaseStacking/_sk_visual_block_with_final_estimator": {},
  "sklearn/sklearn.ensemble._stacking/StackingClassifier/__init__": {},
  "sklearn/sklearn.ensemble._stacking/StackingClassifier/_validate_final_estimator": {},
  "sklearn/sklearn.ensemble._stacking/StackingClassifier/_validate_estimators": {},
  "sklearn/sklearn.ensemble._stacking/StackingClassifier/fit": {},
  "sklearn/sklearn.ensemble._stacking/StackingClassifier/predict": {},
  "sklearn/sklearn.ensemble._stacking/StackingClassifier/predict_proba": {},
  "sklearn/sklearn.ensemble._stacking/StackingClassifier/decision_function": {},
  "sklearn/sklearn.ensemble._stacking/StackingClassifier/transform": {},
  "sklearn/sklearn.ensemble._stacking/StackingClassifier/_sk_visual_block_": {},
  "sklearn/sklearn.ensemble._stacking/StackingRegressor/__init__": {},
  "sklearn/sklearn.ensemble._stacking/StackingRegressor/_validate_final_estimator": {},
  "sklearn/sklearn.ensemble._stacking/StackingRegressor/fit": {},
  "sklearn/sklearn.ensemble._stacking/StackingRegressor/transform": {},
  "sklearn/sklearn.ensemble._stacking/StackingRegressor/_sk_visual_block_": {},
  "sklearn/sklearn.ensemble._voting/_BaseVoting/_log_message": {},
  "sklearn/sklearn.ensemble._voting/_BaseVoting/_weights_not_none@getter": {},
  "sklearn/sklearn.ensemble._voting/_BaseVoting/_predict": {},
  "sklearn/sklearn.ensemble._voting/_BaseVoting/fit": {},
  "sklearn/sklearn.ensemble._voting/_BaseVoting/fit_transform": {},
  "sklearn/sklearn.ensemble._voting/_BaseVoting/n_features_in_@getter": {},
  "sklearn/sklearn.ensemble._voting/_BaseVoting/_sk_visual_block_": {},
  "sklearn/sklearn.ensemble._voting/_BaseVoting/_more_tags": {},
  "sklearn/sklearn.ensemble._voting/VotingClassifier/__init__": {
    "flatten_transform": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.ensemble._voting/VotingClassifier/__init__/flatten_transform",
          "name": "flatten_transform",
          "qname": "sklearn.ensemble._voting.VotingClassifier.__init__.flatten_transform",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Affects shape of transform output only when voting='soft'\nIf voting='soft' and flatten_transform=True, transform method returns\nmatrix with shape (n_samples, n_classifiers * n_classes). If\nflatten_transform=False, it returns\n(n_classifiers, n_samples, n_classes)."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.ensemble._voting/VotingClassifier/__init__/voting",
          "name": "voting",
          "qname": "sklearn.ensemble._voting.VotingClassifier.__init__.voting",
          "default_value": "'hard'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'hard', 'soft'}",
            "default_value": "'hard'",
            "description": "If 'hard', uses predicted class labels for majority rule voting.\nElse if 'soft', predicts the class label based on the argmax of\nthe sums of the predicted probabilities, which is recommended for\nan ensemble of well-calibrated classifiers."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "hard",
              "soft"
            ]
          }
        },
        "hasCondition": {
          "condition": "If voting equals soft and flatten_transform equals True"
        },
        "hasAction": {
          "action": "only when voting equals soft"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.ensemble._voting/VotingClassifier/__init__/flatten_transform",
          "name": "flatten_transform",
          "qname": "sklearn.ensemble._voting.VotingClassifier.__init__.flatten_transform",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Affects shape of transform output only when voting='soft'\nIf voting='soft' and flatten_transform=True, transform method returns\nmatrix with shape (n_samples, n_classifiers * n_classes). If\nflatten_transform=False, it returns\n(n_classifiers, n_samples, n_classes)."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.ensemble._voting/VotingClassifier/__init__/flatten_transform",
          "name": "flatten_transform",
          "qname": "sklearn.ensemble._voting.VotingClassifier.__init__.flatten_transform",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Affects shape of transform output only when voting='soft'\nIf voting='soft' and flatten_transform=True, transform method returns\nmatrix with shape (n_samples, n_classifiers * n_classes). If\nflatten_transform=False, it returns\n(n_classifiers, n_samples, n_classes)."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "If flatten_transform equals False"
        },
        "hasAction": {
          "action": ", it returns ( n_classifiers , n_samples , n_classes )"
        }
      }
    ]
  },
  "sklearn/sklearn.ensemble._voting/VotingClassifier/fit": {},
  "sklearn/sklearn.ensemble._voting/VotingClassifier/predict": {},
  "sklearn/sklearn.ensemble._voting/VotingClassifier/_collect_probas": {},
  "sklearn/sklearn.ensemble._voting/VotingClassifier/_check_voting": {},
  "sklearn/sklearn.ensemble._voting/VotingClassifier/predict_proba": {},
  "sklearn/sklearn.ensemble._voting/VotingClassifier/transform": {},
  "sklearn/sklearn.ensemble._voting/VotingClassifier/get_feature_names_out": {},
  "sklearn/sklearn.ensemble._voting/VotingRegressor/__init__": {},
  "sklearn/sklearn.ensemble._voting/VotingRegressor/fit": {},
  "sklearn/sklearn.ensemble._voting/VotingRegressor/predict": {},
  "sklearn/sklearn.ensemble._voting/VotingRegressor/transform": {},
  "sklearn/sklearn.ensemble._voting/VotingRegressor/get_feature_names_out": {},
  "sklearn/sklearn.ensemble._weight_boosting/BaseWeightBoosting/__init__": {},
  "sklearn/sklearn.ensemble._weight_boosting/BaseWeightBoosting/_check_X": {},
  "sklearn/sklearn.ensemble._weight_boosting/BaseWeightBoosting/fit": {},
  "sklearn/sklearn.ensemble._weight_boosting/BaseWeightBoosting/_boost": {},
  "sklearn/sklearn.ensemble._weight_boosting/BaseWeightBoosting/staged_score": {},
  "sklearn/sklearn.ensemble._weight_boosting/BaseWeightBoosting/feature_importances_@getter": {},
  "sklearn/sklearn.ensemble._weight_boosting/_samme_proba": {},
  "sklearn/sklearn.ensemble._weight_boosting/AdaBoostClassifier/__init__": {
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.ensemble._weight_boosting/AdaBoostClassifier/__init__/random_state",
          "name": "random_state",
          "qname": "sklearn.ensemble._weight_boosting.AdaBoostClassifier.__init__.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance or None",
            "default_value": "None",
            "description": "Controls the random seed given at each `estimator` at each\nboosting iteration.\nThus, it is only used when `estimator` exposes a `random_state`.\nPass an int for reproducible output across multiple function calls.\nSee :term:`Glossary <random_state>`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.ensemble._weight_boosting/AdaBoostClassifier/__init__/estimator",
          "name": "estimator",
          "qname": "sklearn.ensemble._weight_boosting.AdaBoostClassifier.__init__.estimator",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "object",
            "default_value": "None",
            "description": "The base estimator from which the boosted ensemble is built.\nSupport for sample weighting is required, as well as proper\n``classes_`` and ``n_classes_`` attributes. If ``None``, then\nthe base estimator is :class:`~sklearn.tree.DecisionTreeClassifier`\ninitialized with `max_depth=1`.\n\n.. versionadded:: 1.2\n   `base_estimator` was renamed to `estimator`."
          },
          "type": {
            "kind": "NamedType",
            "name": "object"
          }
        },
        "hasCondition": {
          "condition": "when estimator exposes a random_state"
        },
        "hasAction": {
          "action": "Thus , it is only used"
        }
      }
    ]
  },
  "sklearn/sklearn.ensemble._weight_boosting/AdaBoostClassifier/_validate_estimator": {},
  "sklearn/sklearn.ensemble._weight_boosting/AdaBoostClassifier/_boost": {},
  "sklearn/sklearn.ensemble._weight_boosting/AdaBoostClassifier/_boost_real": {},
  "sklearn/sklearn.ensemble._weight_boosting/AdaBoostClassifier/_boost_discrete": {},
  "sklearn/sklearn.ensemble._weight_boosting/AdaBoostClassifier/predict": {},
  "sklearn/sklearn.ensemble._weight_boosting/AdaBoostClassifier/staged_predict": {},
  "sklearn/sklearn.ensemble._weight_boosting/AdaBoostClassifier/decision_function": {},
  "sklearn/sklearn.ensemble._weight_boosting/AdaBoostClassifier/staged_decision_function": {},
  "sklearn/sklearn.ensemble._weight_boosting/AdaBoostClassifier/_compute_proba_from_decision": {},
  "sklearn/sklearn.ensemble._weight_boosting/AdaBoostClassifier/predict_proba": {},
  "sklearn/sklearn.ensemble._weight_boosting/AdaBoostClassifier/staged_predict_proba": {},
  "sklearn/sklearn.ensemble._weight_boosting/AdaBoostClassifier/predict_log_proba": {},
  "sklearn/sklearn.ensemble._weight_boosting/AdaBoostRegressor/__init__": {
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.ensemble._weight_boosting/AdaBoostRegressor/__init__/random_state",
          "name": "random_state",
          "qname": "sklearn.ensemble._weight_boosting.AdaBoostRegressor.__init__.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance or None",
            "default_value": "None",
            "description": "Controls the random seed given at each `estimator` at each\nboosting iteration.\nThus, it is only used when `estimator` exposes a `random_state`.\nIn addition, it controls the bootstrap of the weights used to train the\n`estimator` at each boosting iteration.\nPass an int for reproducible output across multiple function calls.\nSee :term:`Glossary <random_state>`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.ensemble._weight_boosting/AdaBoostRegressor/__init__/estimator",
          "name": "estimator",
          "qname": "sklearn.ensemble._weight_boosting.AdaBoostRegressor.__init__.estimator",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "object",
            "default_value": "None",
            "description": "The base estimator from which the boosted ensemble is built.\nIf ``None``, then the base estimator is\n:class:`~sklearn.tree.DecisionTreeRegressor` initialized with\n`max_depth=3`.\n\n.. versionadded:: 1.2\n   `base_estimator` was renamed to `estimator`."
          },
          "type": {
            "kind": "NamedType",
            "name": "object"
          }
        },
        "hasCondition": {
          "condition": "when estimator exposes a random_state"
        },
        "hasAction": {
          "action": "Thus , it is only used"
        }
      }
    ]
  },
  "sklearn/sklearn.ensemble._weight_boosting/AdaBoostRegressor/_validate_estimator": {},
  "sklearn/sklearn.ensemble._weight_boosting/AdaBoostRegressor/_boost": {},
  "sklearn/sklearn.ensemble._weight_boosting/AdaBoostRegressor/_get_median_predict": {},
  "sklearn/sklearn.ensemble._weight_boosting/AdaBoostRegressor/predict": {},
  "sklearn/sklearn.ensemble._weight_boosting/AdaBoostRegressor/staged_predict": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.binning/_find_binning_thresholds": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.binning/_BinMapper/__init__": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.binning/_BinMapper/fit": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.binning/_BinMapper/transform": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.binning/_BinMapper/make_known_categories_bitsets": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.gradient_boosting/_update_leaves_values": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.gradient_boosting/BaseHistGradientBoosting/__init__": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.gradient_boosting/BaseHistGradientBoosting/_validate_parameters": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.gradient_boosting/BaseHistGradientBoosting/_finalize_sample_weight": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.gradient_boosting/BaseHistGradientBoosting/_check_categories": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.gradient_boosting/BaseHistGradientBoosting/_check_interaction_cst": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.gradient_boosting/BaseHistGradientBoosting/fit": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.gradient_boosting/BaseHistGradientBoosting/_is_fitted": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.gradient_boosting/BaseHistGradientBoosting/_clear_state": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.gradient_boosting/BaseHistGradientBoosting/_get_small_trainset": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.gradient_boosting/BaseHistGradientBoosting/_check_early_stopping_scorer": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.gradient_boosting/BaseHistGradientBoosting/_check_early_stopping_loss": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.gradient_boosting/BaseHistGradientBoosting/_should_stop": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.gradient_boosting/BaseHistGradientBoosting/_bin_data": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.gradient_boosting/BaseHistGradientBoosting/_print_iteration_stats": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.gradient_boosting/BaseHistGradientBoosting/_raw_predict": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.gradient_boosting/BaseHistGradientBoosting/_predict_iterations": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.gradient_boosting/BaseHistGradientBoosting/_staged_raw_predict": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.gradient_boosting/BaseHistGradientBoosting/_compute_partial_dependence_recursion": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.gradient_boosting/BaseHistGradientBoosting/_more_tags": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.gradient_boosting/BaseHistGradientBoosting/_get_loss": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.gradient_boosting/BaseHistGradientBoosting/_encode_y": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.gradient_boosting/BaseHistGradientBoosting/n_iter_@getter": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.gradient_boosting/HistGradientBoostingRegressor/__init__": {
    "quantile": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.ensemble._hist_gradient_boosting.gradient_boosting/HistGradientBoostingRegressor/__init__/quantile",
          "name": "quantile",
          "qname": "sklearn.ensemble._hist_gradient_boosting.gradient_boosting.HistGradientBoostingRegressor.__init__.quantile",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "None",
            "description": "If loss is \"quantile\", this parameter specifies which quantile to be estimated\nand must be between 0 and 1."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.ensemble._hist_gradient_boosting.gradient_boosting/HistGradientBoostingRegressor/__init__/loss",
          "name": "loss",
          "qname": "sklearn.ensemble._hist_gradient_boosting.gradient_boosting.HistGradientBoostingRegressor.__init__.loss",
          "default_value": "'squared_error'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "{'squared_error', 'absolute_error', 'poisson', 'quantile'}",
            "default_value": "'squared_error'",
            "description": "The loss function to use in the boosting process. Note that the\n\"squared error\" and \"poisson\" losses actually implement\n\"half least squares loss\" and \"half poisson deviance\" to simplify the\ncomputation of the gradient. Furthermore, \"poisson\" loss internally\nuses a log-link and requires ``y >= 0``.\n\"quantile\" uses the pinball loss.\n\n.. versionchanged:: 0.23\n   Added option 'poisson'.\n\n.. versionchanged:: 1.1\n   Added option 'quantile'."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "squared_error",
              "absolute_error",
              "poisson",
              "quantile"
            ]
          }
        },
        "hasCondition": {
          "condition": "If loss is quantile"
        },
        "hasAction": {
          "action": ", this parameter specifies which quantile to be estimated and must be between 0 and 1"
        }
      }
    ],
    "scoring": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.ensemble._hist_gradient_boosting.gradient_boosting/HistGradientBoostingRegressor/__init__/scoring",
          "name": "scoring",
          "qname": "sklearn.ensemble._hist_gradient_boosting.gradient_boosting.HistGradientBoostingRegressor.__init__.scoring",
          "default_value": "'loss'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable or None",
            "default_value": "'loss'",
            "description": "Scoring parameter to use for early stopping. It can be a single\nstring (see :ref:`scoring_parameter`) or a callable (see\n:ref:`scoring`). If None, the estimator's default scorer is used. If\n``scoring='loss'``, early stopping is checked w.r.t the loss value.\nOnly used if early stopping is performed."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.ensemble._hist_gradient_boosting.gradient_boosting/HistGradientBoostingRegressor/__init__/scoring",
          "name": "scoring",
          "qname": "sklearn.ensemble._hist_gradient_boosting.gradient_boosting.HistGradientBoostingRegressor.__init__.scoring",
          "default_value": "'loss'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable or None",
            "default_value": "'loss'",
            "description": "Scoring parameter to use for early stopping. It can be a single\nstring (see :ref:`scoring_parameter`) or a callable (see\n:ref:`scoring`). If None, the estimator's default scorer is used. If\n``scoring='loss'``, early stopping is checked w.r.t the loss value.\nOnly used if early stopping is performed."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If scoring equals loss"
        },
        "hasAction": {
          "action": ", early stopping is checked w.r.t the loss value"
        }
      }
    ]
  },
  "sklearn/sklearn.ensemble._hist_gradient_boosting.gradient_boosting/HistGradientBoostingRegressor/predict": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.gradient_boosting/HistGradientBoostingRegressor/staged_predict": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.gradient_boosting/HistGradientBoostingRegressor/_encode_y": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.gradient_boosting/HistGradientBoostingRegressor/_get_loss": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.gradient_boosting/HistGradientBoostingClassifier/__init__": {
    "scoring": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.ensemble._hist_gradient_boosting.gradient_boosting/HistGradientBoostingClassifier/__init__/scoring",
          "name": "scoring",
          "qname": "sklearn.ensemble._hist_gradient_boosting.gradient_boosting.HistGradientBoostingClassifier.__init__.scoring",
          "default_value": "'loss'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable or None",
            "default_value": "'loss'",
            "description": "Scoring parameter to use for early stopping. It can be a single\nstring (see :ref:`scoring_parameter`) or a callable (see\n:ref:`scoring`). If None, the estimator's default scorer\nis used. If ``scoring='loss'``, early stopping is checked\nw.r.t the loss value. Only used if early stopping is performed."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.ensemble._hist_gradient_boosting.gradient_boosting/HistGradientBoostingClassifier/__init__/scoring",
          "name": "scoring",
          "qname": "sklearn.ensemble._hist_gradient_boosting.gradient_boosting.HistGradientBoostingClassifier.__init__.scoring",
          "default_value": "'loss'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable or None",
            "default_value": "'loss'",
            "description": "Scoring parameter to use for early stopping. It can be a single\nstring (see :ref:`scoring_parameter`) or a callable (see\n:ref:`scoring`). If None, the estimator's default scorer\nis used. If ``scoring='loss'``, early stopping is checked\nw.r.t the loss value. Only used if early stopping is performed."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If scoring equals loss"
        },
        "hasAction": {
          "action": ", early stopping is checked w.r.t the loss value"
        }
      }
    ]
  },
  "sklearn/sklearn.ensemble._hist_gradient_boosting.gradient_boosting/HistGradientBoostingClassifier/_finalize_sample_weight": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.gradient_boosting/HistGradientBoostingClassifier/predict": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.gradient_boosting/HistGradientBoostingClassifier/staged_predict": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.gradient_boosting/HistGradientBoostingClassifier/predict_proba": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.gradient_boosting/HistGradientBoostingClassifier/staged_predict_proba": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.gradient_boosting/HistGradientBoostingClassifier/decision_function": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.gradient_boosting/HistGradientBoostingClassifier/staged_decision_function": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.gradient_boosting/HistGradientBoostingClassifier/_encode_y": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.gradient_boosting/HistGradientBoostingClassifier/_get_loss": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.grower/TreeNode/__init__": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.grower/TreeNode/set_children_bounds": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.grower/TreeNode/__lt__": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.grower/TreeGrower/__init__": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.grower/TreeGrower/_validate_parameters": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.grower/TreeGrower/grow": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.grower/TreeGrower/_apply_shrinkage": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.grower/TreeGrower/_intilialize_root": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.grower/TreeGrower/_compute_best_split_and_push": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.grower/TreeGrower/split_next": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.grower/TreeGrower/_compute_interactions": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.grower/TreeGrower/_finalize_leaf": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.grower/TreeGrower/_finalize_splittable_nodes": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.grower/TreeGrower/make_predictor": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.grower/_fill_predictor_arrays": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.predictor/TreePredictor/__init__": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.predictor/TreePredictor/get_n_leaf_nodes": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.predictor/TreePredictor/get_max_depth": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.predictor/TreePredictor/predict": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.predictor/TreePredictor/predict_binned": {},
  "sklearn/sklearn.ensemble._hist_gradient_boosting.predictor/TreePredictor/compute_partial_dependence": {},
  "sklearn/sklearn.feature_selection._base/SelectorMixin/get_support": {},
  "sklearn/sklearn.feature_selection._base/SelectorMixin/_get_support_mask": {},
  "sklearn/sklearn.feature_selection._base/SelectorMixin/transform": {},
  "sklearn/sklearn.feature_selection._base/SelectorMixin/_transform": {},
  "sklearn/sklearn.feature_selection._base/SelectorMixin/inverse_transform": {},
  "sklearn/sklearn.feature_selection._base/SelectorMixin/get_feature_names_out": {
    "input_features": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.feature_selection._base/SelectorMixin/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.feature_selection._base.SelectorMixin.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features.\n\n- If `input_features` is `None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then the following input feature names are generated:\n  `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.feature_selection._base/SelectorMixin/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.feature_selection._base.SelectorMixin.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features.\n\n- If `input_features` is `None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then the following input feature names are generated:\n  `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If input_features is None , then feature_names_in _"
        },
        "hasAction": {
          "action": "is used as feature names in"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.feature_selection._base/SelectorMixin/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.feature_selection._base.SelectorMixin.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features.\n\n- If `input_features` is `None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then the following input feature names are generated:\n  `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.feature_selection._base/SelectorMixin/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.feature_selection._base.SelectorMixin.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features.\n\n- If `input_features` is `None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then the following input feature names are generated:\n  `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If input_features is"
        },
        "hasAction": {
          "action": "an array - like , then input_features must match feature_names_in _"
        }
      }
    ]
  },
  "sklearn/sklearn.feature_selection._base/_get_feature_importances": {
    "norm_order": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.feature_selection._base/_get_feature_importances/norm_order",
          "name": "norm_order",
          "qname": "sklearn.feature_selection._base._get_feature_importances.norm_order",
          "default_value": "1",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "int",
            "default_value": "1",
            "description": "The norm order to apply when `transform_func=\"norm\"`. Only applied\nwhen `importances.ndim > 1`."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.feature_selection._base/_get_feature_importances/transform_func",
          "name": "transform_func",
          "qname": "sklearn.feature_selection._base._get_feature_importances.transform_func",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "{\"norm\", \"square\"}",
            "default_value": "None",
            "description": "The transform to apply to the feature importances. By default (`None`)\nno transformation is applied."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "norm",
              "square"
            ]
          }
        },
        "hasCondition": {
          "condition": "when transform_func equals norm"
        },
        "hasAction": {
          "action": "to apply"
        }
      }
    ]
  },
  "sklearn/sklearn.feature_selection._from_model/_calculate_threshold": {},
  "sklearn/sklearn.feature_selection._from_model/_estimator_has": {},
  "sklearn/sklearn.feature_selection._from_model/SelectFromModel/__init__": {},
  "sklearn/sklearn.feature_selection._from_model/SelectFromModel/_get_support_mask": {},
  "sklearn/sklearn.feature_selection._from_model/SelectFromModel/_check_max_features": {},
  "sklearn/sklearn.feature_selection._from_model/SelectFromModel/fit": {},
  "sklearn/sklearn.feature_selection._from_model/SelectFromModel/threshold_@getter": {},
  "sklearn/sklearn.feature_selection._from_model/SelectFromModel/partial_fit": {},
  "sklearn/sklearn.feature_selection._from_model/SelectFromModel/n_features_in_@getter": {},
  "sklearn/sklearn.feature_selection._from_model/SelectFromModel/_more_tags": {},
  "sklearn/sklearn.feature_selection._mutual_info/_compute_mi_cc": {},
  "sklearn/sklearn.feature_selection._mutual_info/_compute_mi_cd": {},
  "sklearn/sklearn.feature_selection._mutual_info/_compute_mi": {},
  "sklearn/sklearn.feature_selection._mutual_info/_iterate_columns": {},
  "sklearn/sklearn.feature_selection._mutual_info/_estimate_mi": {},
  "sklearn/sklearn.feature_selection._mutual_info/mutual_info_regression": {},
  "sklearn/sklearn.feature_selection._mutual_info/mutual_info_classif": {},
  "sklearn/sklearn.feature_selection._rfe/_rfe_single_fit": {},
  "sklearn/sklearn.feature_selection._rfe/_estimator_has": {},
  "sklearn/sklearn.feature_selection._rfe/RFE/__init__": {},
  "sklearn/sklearn.feature_selection._rfe/RFE/_estimator_type@getter": {},
  "sklearn/sklearn.feature_selection._rfe/RFE/classes_@getter": {},
  "sklearn/sklearn.feature_selection._rfe/RFE/fit": {},
  "sklearn/sklearn.feature_selection._rfe/RFE/_fit": {},
  "sklearn/sklearn.feature_selection._rfe/RFE/predict": {},
  "sklearn/sklearn.feature_selection._rfe/RFE/score": {},
  "sklearn/sklearn.feature_selection._rfe/RFE/_get_support_mask": {},
  "sklearn/sklearn.feature_selection._rfe/RFE/decision_function": {},
  "sklearn/sklearn.feature_selection._rfe/RFE/predict_proba": {},
  "sklearn/sklearn.feature_selection._rfe/RFE/predict_log_proba": {},
  "sklearn/sklearn.feature_selection._rfe/RFE/_more_tags": {},
  "sklearn/sklearn.feature_selection._rfe/RFECV/__init__": {},
  "sklearn/sklearn.feature_selection._rfe/RFECV/fit": {},
  "sklearn/sklearn.feature_selection._sequential/SequentialFeatureSelector/__init__": {
    "n_features_to_select": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.feature_selection._sequential/SequentialFeatureSelector/__init__/n_features_to_select",
          "name": "n_features_to_select",
          "qname": "sklearn.feature_selection._sequential.SequentialFeatureSelector.__init__.n_features_to_select",
          "default_value": "'warn'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "\"auto\", int or float",
            "default_value": "'warn'",
            "description": "If `\"auto\"`, the behaviour depends on the `tol` parameter:\n\n- if `tol` is not `None`, then features are selected until the score\n  improvement does not exceed `tol`.\n- otherwise, half of the features are selected.\n\nIf integer, the parameter is the absolute number of features to select.\nIf float between 0 and 1, it is the fraction of features to select.\n\n.. versionadded:: 1.1\n   The option `\"auto\"` was added in version 1.1.\n\n.. deprecated:: 1.1\n   The default changed from `None` to `\"warn\"` in 1.1 and will become\n   `\"auto\"` in 1.3. `None` and `'warn'` will be removed in 1.3.\n   To keep the same behaviour as `None`, set\n   `n_features_to_select=\"auto\" and `tol=None`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "\"auto\""
              },
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "float"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.feature_selection._sequential/SequentialFeatureSelector/__init__/tol",
          "name": "tol",
          "qname": "sklearn.feature_selection._sequential.SequentialFeatureSelector.__init__.tol",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "None",
            "description": "If the score is not incremented by at least `tol` between two\nconsecutive feature additions or removals, stop adding or removing.\n`tol` is enabled only when `n_features_to_select` is `\"auto\"`.\n\n.. versionadded:: 1.1"
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "hasCondition": {
          "condition": "if tol is not None"
        },
        "hasAction": {
          "action": "If auto , the behaviour depends on the tol parameter : - , then features are selected until the score improvement does not exceed tol"
        }
      }
    ],
    "tol": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.feature_selection._sequential/SequentialFeatureSelector/__init__/tol",
          "name": "tol",
          "qname": "sklearn.feature_selection._sequential.SequentialFeatureSelector.__init__.tol",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "None",
            "description": "If the score is not incremented by at least `tol` between two\nconsecutive feature additions or removals, stop adding or removing.\n`tol` is enabled only when `n_features_to_select` is `\"auto\"`.\n\n.. versionadded:: 1.1"
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.feature_selection._sequential/SequentialFeatureSelector/__init__/n_features_to_select",
          "name": "n_features_to_select",
          "qname": "sklearn.feature_selection._sequential.SequentialFeatureSelector.__init__.n_features_to_select",
          "default_value": "'warn'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "\"auto\", int or float",
            "default_value": "'warn'",
            "description": "If `\"auto\"`, the behaviour depends on the `tol` parameter:\n\n- if `tol` is not `None`, then features are selected until the score\n  improvement does not exceed `tol`.\n- otherwise, half of the features are selected.\n\nIf integer, the parameter is the absolute number of features to select.\nIf float between 0 and 1, it is the fraction of features to select.\n\n.. versionadded:: 1.1\n   The option `\"auto\"` was added in version 1.1.\n\n.. deprecated:: 1.1\n   The default changed from `None` to `\"warn\"` in 1.1 and will become\n   `\"auto\"` in 1.3. `None` and `'warn'` will be removed in 1.3.\n   To keep the same behaviour as `None`, set\n   `n_features_to_select=\"auto\" and `tol=None`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "\"auto\""
              },
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "float"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "only when n_features_to_select is auto"
        },
        "hasAction": {
          "action": "tol is enabled"
        }
      }
    ],
    "cv": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.feature_selection._sequential/SequentialFeatureSelector/__init__/cv",
          "name": "cv",
          "qname": "sklearn.feature_selection._sequential.SequentialFeatureSelector.__init__.cv",
          "default_value": "5",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, cross-validation generator or an iterable",
            "default_value": "None",
            "description": "Determines the cross-validation splitting strategy.\nPossible inputs for cv are:\n\n- None, to use the default 5-fold cross validation,\n- integer, to specify the number of folds in a `(Stratified)KFold`,\n- :term:`CV splitter`,\n- An iterable yielding (train, test) splits as arrays of indices.\n\nFor integer/None inputs, if the estimator is a classifier and ``y`` is\neither binary or multiclass, :class:`StratifiedKFold` is used. In all\nother cases, :class:`KFold` is used. These splitters are instantiated\nwith `shuffle=False` so the splits will be the same across calls.\n\nRefer :ref:`User Guide <cross_validation>` for the various\ncross-validation strategies that can be used here."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "cross-validation generator"
              },
              {
                "kind": "NamedType",
                "name": "an iterable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.feature_selection._sequential/SequentialFeatureSelector/__init__/estimator",
          "name": "estimator",
          "qname": "sklearn.feature_selection._sequential.SequentialFeatureSelector.__init__.estimator",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "estimator instance",
            "default_value": "",
            "description": "An unfitted estimator."
          },
          "type": {
            "kind": "NamedType",
            "name": "estimator instance"
          }
        },
        "hasCondition": {
          "condition": "if the estimator is a classifier and y is either binary or multiclass ,"
        },
        "hasAction": {
          "action": "For integer / None inputs , : class : StratifiedKFold is used"
        }
      }
    ]
  },
  "sklearn/sklearn.feature_selection._sequential/SequentialFeatureSelector/fit": {},
  "sklearn/sklearn.feature_selection._sequential/SequentialFeatureSelector/_get_best_new_feature_score": {},
  "sklearn/sklearn.feature_selection._sequential/SequentialFeatureSelector/_get_support_mask": {},
  "sklearn/sklearn.feature_selection._sequential/SequentialFeatureSelector/_more_tags": {},
  "sklearn/sklearn.feature_selection._univariate_selection/_clean_nans": {},
  "sklearn/sklearn.feature_selection._univariate_selection/f_oneway": {},
  "sklearn/sklearn.feature_selection._univariate_selection/f_classif": {},
  "sklearn/sklearn.feature_selection._univariate_selection/_chisquare": {},
  "sklearn/sklearn.feature_selection._univariate_selection/chi2": {},
  "sklearn/sklearn.feature_selection._univariate_selection/r_regression": {
    "force_finite": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.feature_selection._univariate_selection/r_regression/force_finite",
          "name": "force_finite",
          "qname": "sklearn.feature_selection._univariate_selection.r_regression.force_finite",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Whether or not to force the Pearson's R correlation to be finite.\nIn the particular case where some features in `X` or the target `y`\nare constant, the Pearson's R correlation is not defined. When\n`force_finite=False`, a correlation of `np.nan` is returned to\nacknowledge this case. When `force_finite=True`, this value will be\nforced to a minimal correlation of `0.0`.\n\n.. versionadded:: 1.1"
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.feature_selection._univariate_selection/r_regression/force_finite",
          "name": "force_finite",
          "qname": "sklearn.feature_selection._univariate_selection.r_regression.force_finite",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Whether or not to force the Pearson's R correlation to be finite.\nIn the particular case where some features in `X` or the target `y`\nare constant, the Pearson's R correlation is not defined. When\n`force_finite=False`, a correlation of `np.nan` is returned to\nacknowledge this case. When `force_finite=True`, this value will be\nforced to a minimal correlation of `0.0`.\n\n.. versionadded:: 1.1"
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "When force_finite equals False , a correlation of np.nan"
        },
        "hasAction": {
          "action": "is returned to acknowledge this case"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.feature_selection._univariate_selection/r_regression/force_finite",
          "name": "force_finite",
          "qname": "sklearn.feature_selection._univariate_selection.r_regression.force_finite",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Whether or not to force the Pearson's R correlation to be finite.\nIn the particular case where some features in `X` or the target `y`\nare constant, the Pearson's R correlation is not defined. When\n`force_finite=False`, a correlation of `np.nan` is returned to\nacknowledge this case. When `force_finite=True`, this value will be\nforced to a minimal correlation of `0.0`.\n\n.. versionadded:: 1.1"
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.feature_selection._univariate_selection/r_regression/force_finite",
          "name": "force_finite",
          "qname": "sklearn.feature_selection._univariate_selection.r_regression.force_finite",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Whether or not to force the Pearson's R correlation to be finite.\nIn the particular case where some features in `X` or the target `y`\nare constant, the Pearson's R correlation is not defined. When\n`force_finite=False`, a correlation of `np.nan` is returned to\nacknowledge this case. When `force_finite=True`, this value will be\nforced to a minimal correlation of `0.0`.\n\n.. versionadded:: 1.1"
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "When force_finite equals True"
        },
        "hasAction": {
          "action": ", this value will be forced to a minimal correlation of 0.0 . .."
        }
      }
    ]
  },
  "sklearn/sklearn.feature_selection._univariate_selection/f_regression": {
    "force_finite": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.feature_selection._univariate_selection/f_regression/force_finite",
          "name": "force_finite",
          "qname": "sklearn.feature_selection._univariate_selection.f_regression.force_finite",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Whether or not to force the F-statistics and associated p-values to\nbe finite. There are two cases where the F-statistic is expected to not\nbe finite:\n\n- when the target `y` or some features in `X` are constant. In this\n  case, the Pearson's R correlation is not defined leading to obtain\n  `np.nan` values in the F-statistic and p-value. When\n  `force_finite=True`, the F-statistic is set to `0.0` and the\n  associated p-value is set to `1.0`.\n- when a feature in `X` is perfectly correlated (or\n  anti-correlated) with the target `y`. In this case, the F-statistic\n  is expected to be `np.inf`. When `force_finite=True`, the F-statistic\n  is set to `np.finfo(dtype).max` and the associated p-value is set to\n  `0.0`.\n\n.. versionadded:: 1.1"
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.feature_selection._univariate_selection/f_regression/force_finite",
          "name": "force_finite",
          "qname": "sklearn.feature_selection._univariate_selection.f_regression.force_finite",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Whether or not to force the F-statistics and associated p-values to\nbe finite. There are two cases where the F-statistic is expected to not\nbe finite:\n\n- when the target `y` or some features in `X` are constant. In this\n  case, the Pearson's R correlation is not defined leading to obtain\n  `np.nan` values in the F-statistic and p-value. When\n  `force_finite=True`, the F-statistic is set to `0.0` and the\n  associated p-value is set to `1.0`.\n- when a feature in `X` is perfectly correlated (or\n  anti-correlated) with the target `y`. In this case, the F-statistic\n  is expected to be `np.inf`. When `force_finite=True`, the F-statistic\n  is set to `np.finfo(dtype).max` and the associated p-value is set to\n  `0.0`.\n\n.. versionadded:: 1.1"
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "When force_finite equals True"
        },
        "hasAction": {
          "action": ", the F - statistic is set to 0.0 and the associated p - value is set to 1.0 . - when a feature in X is perfectly correlated ( or anti - correlated ) with the target y."
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.feature_selection._univariate_selection/f_regression/force_finite",
          "name": "force_finite",
          "qname": "sklearn.feature_selection._univariate_selection.f_regression.force_finite",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Whether or not to force the F-statistics and associated p-values to\nbe finite. There are two cases where the F-statistic is expected to not\nbe finite:\n\n- when the target `y` or some features in `X` are constant. In this\n  case, the Pearson's R correlation is not defined leading to obtain\n  `np.nan` values in the F-statistic and p-value. When\n  `force_finite=True`, the F-statistic is set to `0.0` and the\n  associated p-value is set to `1.0`.\n- when a feature in `X` is perfectly correlated (or\n  anti-correlated) with the target `y`. In this case, the F-statistic\n  is expected to be `np.inf`. When `force_finite=True`, the F-statistic\n  is set to `np.finfo(dtype).max` and the associated p-value is set to\n  `0.0`.\n\n.. versionadded:: 1.1"
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.feature_selection._univariate_selection/f_regression/force_finite",
          "name": "force_finite",
          "qname": "sklearn.feature_selection._univariate_selection.f_regression.force_finite",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Whether or not to force the F-statistics and associated p-values to\nbe finite. There are two cases where the F-statistic is expected to not\nbe finite:\n\n- when the target `y` or some features in `X` are constant. In this\n  case, the Pearson's R correlation is not defined leading to obtain\n  `np.nan` values in the F-statistic and p-value. When\n  `force_finite=True`, the F-statistic is set to `0.0` and the\n  associated p-value is set to `1.0`.\n- when a feature in `X` is perfectly correlated (or\n  anti-correlated) with the target `y`. In this case, the F-statistic\n  is expected to be `np.inf`. When `force_finite=True`, the F-statistic\n  is set to `np.finfo(dtype).max` and the associated p-value is set to\n  `0.0`.\n\n.. versionadded:: 1.1"
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "When force_finite equals True"
        },
        "hasAction": {
          "action": ", the F - statistic is set to np.finfo(dtype).max and the associated p - value is set to 0.0 . .."
        }
      }
    ]
  },
  "sklearn/sklearn.feature_selection._univariate_selection/_BaseFilter/__init__": {},
  "sklearn/sklearn.feature_selection._univariate_selection/_BaseFilter/fit": {},
  "sklearn/sklearn.feature_selection._univariate_selection/_BaseFilter/_check_params": {},
  "sklearn/sklearn.feature_selection._univariate_selection/_BaseFilter/_more_tags": {},
  "sklearn/sklearn.feature_selection._univariate_selection/SelectPercentile/__init__": {},
  "sklearn/sklearn.feature_selection._univariate_selection/SelectPercentile/_get_support_mask": {},
  "sklearn/sklearn.feature_selection._univariate_selection/SelectKBest/__init__": {},
  "sklearn/sklearn.feature_selection._univariate_selection/SelectKBest/_check_params": {},
  "sklearn/sklearn.feature_selection._univariate_selection/SelectKBest/_get_support_mask": {},
  "sklearn/sklearn.feature_selection._univariate_selection/SelectFpr/__init__": {},
  "sklearn/sklearn.feature_selection._univariate_selection/SelectFpr/_get_support_mask": {},
  "sklearn/sklearn.feature_selection._univariate_selection/SelectFdr/__init__": {},
  "sklearn/sklearn.feature_selection._univariate_selection/SelectFdr/_get_support_mask": {},
  "sklearn/sklearn.feature_selection._univariate_selection/SelectFwe/__init__": {},
  "sklearn/sklearn.feature_selection._univariate_selection/SelectFwe/_get_support_mask": {},
  "sklearn/sklearn.feature_selection._univariate_selection/GenericUnivariateSelect/__init__": {},
  "sklearn/sklearn.feature_selection._univariate_selection/GenericUnivariateSelect/_make_selector": {},
  "sklearn/sklearn.feature_selection._univariate_selection/GenericUnivariateSelect/_more_tags": {},
  "sklearn/sklearn.feature_selection._univariate_selection/GenericUnivariateSelect/_check_params": {},
  "sklearn/sklearn.feature_selection._univariate_selection/GenericUnivariateSelect/_get_support_mask": {},
  "sklearn/sklearn.feature_selection._variance_threshold/VarianceThreshold/__init__": {},
  "sklearn/sklearn.feature_selection._variance_threshold/VarianceThreshold/fit": {},
  "sklearn/sklearn.feature_selection._variance_threshold/VarianceThreshold/_get_support_mask": {},
  "sklearn/sklearn.feature_selection._variance_threshold/VarianceThreshold/_more_tags": {},
  "sklearn/sklearn.impute._base/_check_inputs_dtype": {},
  "sklearn/sklearn.impute._base/_most_frequent": {},
  "sklearn/sklearn.impute._base/_BaseImputer/__init__": {},
  "sklearn/sklearn.impute._base/_BaseImputer/_fit_indicator": {},
  "sklearn/sklearn.impute._base/_BaseImputer/_transform_indicator": {},
  "sklearn/sklearn.impute._base/_BaseImputer/_concatenate_indicator": {},
  "sklearn/sklearn.impute._base/_BaseImputer/_concatenate_indicator_feature_names_out": {},
  "sklearn/sklearn.impute._base/_BaseImputer/_more_tags": {},
  "sklearn/sklearn.impute._base/SimpleImputer/__init__": {
    "fill_value": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.impute._base/SimpleImputer/__init__/fill_value",
          "name": "fill_value",
          "qname": "sklearn.impute._base.SimpleImputer.__init__.fill_value",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or numerical value",
            "default_value": "None",
            "description": "When strategy == \"constant\", `fill_value` is used to replace all\noccurrences of missing_values. For string or object data types,\n`fill_value` must be a string.\nIf `None`, `fill_value` will be 0 when imputing numerical\ndata and \"missing_value\" for strings or object data types."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "numerical value"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.impute._base/SimpleImputer/__init__/strategy",
          "name": "strategy",
          "qname": "sklearn.impute._base.SimpleImputer.__init__.strategy",
          "default_value": "'mean'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "'mean'",
            "description": "The imputation strategy.\n\n- If \"mean\", then replace missing values using the mean along\n  each column. Can only be used with numeric data.\n- If \"median\", then replace missing values using the median along\n  each column. Can only be used with numeric data.\n- If \"most_frequent\", then replace missing using the most frequent\n  value along each column. Can be used with strings or numeric data.\n  If there is more than one such value, only the smallest is returned.\n- If \"constant\", then replace missing values with fill_value. Can be\n  used with strings or numeric data.\n\n.. versionadded:: 0.20\n   strategy=\"constant\" for fixed value imputation."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        "hasCondition": {
          "condition": "When strategy equals constant"
        },
        "hasAction": {
          "action": ", fill_value is used to replace all occurrences of missing_values"
        }
      }
    ],
    "copy": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.impute._base/SimpleImputer/__init__/copy",
          "name": "copy",
          "qname": "sklearn.impute._base.SimpleImputer.__init__.copy",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "If True, a copy of X will be created. If False, imputation will\nbe done in-place whenever possible. Note that, in the following cases,\na new copy will always be made, even if `copy=False`:\n\n- If `X` is not an array of floating values;\n- If `X` is encoded as a CSR matrix;\n- If `add_indicator=True`."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.impute._base/SimpleImputer/__init__/copy",
          "name": "copy",
          "qname": "sklearn.impute._base.SimpleImputer.__init__.copy",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "If True, a copy of X will be created. If False, imputation will\nbe done in-place whenever possible. Note that, in the following cases,\na new copy will always be made, even if `copy=False`:\n\n- If `X` is not an array of floating values;\n- If `X` is encoded as a CSR matrix;\n- If `add_indicator=True`."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "even if copy equals False"
        },
        "hasAction": {
          "action": "that , in the following cases , a new copy will always be made , : - If X is not an array of floating values"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.impute._base/SimpleImputer/__init__/copy",
          "name": "copy",
          "qname": "sklearn.impute._base.SimpleImputer.__init__.copy",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "If True, a copy of X will be created. If False, imputation will\nbe done in-place whenever possible. Note that, in the following cases,\na new copy will always be made, even if `copy=False`:\n\n- If `X` is not an array of floating values;\n- If `X` is encoded as a CSR matrix;\n- If `add_indicator=True`."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.impute._base/SimpleImputer/__init__/add_indicator",
          "name": "add_indicator",
          "qname": "sklearn.impute._base.SimpleImputer.__init__.add_indicator",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "If True, a :class:`MissingIndicator` transform will stack onto output\nof the imputer's transform. This allows a predictive estimator\nto account for missingness despite imputation. If a feature has no\nmissing values at fit/train time, the feature won't appear on\nthe missing indicator even if there are missing values at\ntransform/test time."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "If add_indicator equals True"
        },
        "hasAction": {
          "action": "If X is encoded as a CSR matrix ; -"
        }
      }
    ],
    "keep_empty_features": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.impute._base/SimpleImputer/__init__/keep_empty_features",
          "name": "keep_empty_features",
          "qname": "sklearn.impute._base.SimpleImputer.__init__.keep_empty_features",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "If True, features that consist exclusively of missing values when\n`fit` is called are returned in results when `transform` is called.\nThe imputed value is always `0` except when `strategy=\"constant\"`\nin which case `fill_value` will be used instead.\n\n.. versionadded:: 1.2"
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.impute._base/SimpleImputer/__init__/fill_value",
          "name": "fill_value",
          "qname": "sklearn.impute._base.SimpleImputer.__init__.fill_value",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or numerical value",
            "default_value": "None",
            "description": "When strategy == \"constant\", `fill_value` is used to replace all\noccurrences of missing_values. For string or object data types,\n`fill_value` must be a string.\nIf `None`, `fill_value` will be 0 when imputing numerical\ndata and \"missing_value\" for strings or object data types."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "numerical value"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "in which case fill_value will be used instead"
        },
        "hasAction": {
          "action": "when strategy equals constant"
        }
      }
    ]
  },
  "sklearn/sklearn.impute._base/SimpleImputer/_validate_input": {},
  "sklearn/sklearn.impute._base/SimpleImputer/fit": {},
  "sklearn/sklearn.impute._base/SimpleImputer/_sparse_fit": {},
  "sklearn/sklearn.impute._base/SimpleImputer/_dense_fit": {},
  "sklearn/sklearn.impute._base/SimpleImputer/transform": {},
  "sklearn/sklearn.impute._base/SimpleImputer/inverse_transform": {},
  "sklearn/sklearn.impute._base/SimpleImputer/_more_tags": {},
  "sklearn/sklearn.impute._base/SimpleImputer/get_feature_names_out": {
    "input_features": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.impute._base/SimpleImputer/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.impute._base.SimpleImputer.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features.\n\n- If `input_features` is `None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then the following input feature names are generated:\n  `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.impute._base/SimpleImputer/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.impute._base.SimpleImputer.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features.\n\n- If `input_features` is `None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then the following input feature names are generated:\n  `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If input_features is None , then feature_names_in _"
        },
        "hasAction": {
          "action": "is used as feature names in"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.impute._base/SimpleImputer/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.impute._base.SimpleImputer.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features.\n\n- If `input_features` is `None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then the following input feature names are generated:\n  `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.impute._base/SimpleImputer/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.impute._base.SimpleImputer.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features.\n\n- If `input_features` is `None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then the following input feature names are generated:\n  `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If input_features is"
        },
        "hasAction": {
          "action": "an array - like , then input_features must match feature_names_in _"
        }
      }
    ]
  },
  "sklearn/sklearn.impute._base/MissingIndicator/__init__": {},
  "sklearn/sklearn.impute._base/MissingIndicator/_get_missing_features_info": {},
  "sklearn/sklearn.impute._base/MissingIndicator/_validate_input": {},
  "sklearn/sklearn.impute._base/MissingIndicator/_fit": {},
  "sklearn/sklearn.impute._base/MissingIndicator/fit": {},
  "sklearn/sklearn.impute._base/MissingIndicator/transform": {},
  "sklearn/sklearn.impute._base/MissingIndicator/fit_transform": {},
  "sklearn/sklearn.impute._base/MissingIndicator/get_feature_names_out": {
    "input_features": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.impute._base/MissingIndicator/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.impute._base.MissingIndicator.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features.\n\n- If `input_features` is `None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then the following input feature names are generated:\n  `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.impute._base/MissingIndicator/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.impute._base.MissingIndicator.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features.\n\n- If `input_features` is `None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then the following input feature names are generated:\n  `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If input_features is None , then feature_names_in _"
        },
        "hasAction": {
          "action": "is used as feature names in"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.impute._base/MissingIndicator/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.impute._base.MissingIndicator.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features.\n\n- If `input_features` is `None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then the following input feature names are generated:\n  `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.impute._base/MissingIndicator/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.impute._base.MissingIndicator.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features.\n\n- If `input_features` is `None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then the following input feature names are generated:\n  `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If input_features is"
        },
        "hasAction": {
          "action": "an array - like , then input_features must match feature_names_in _"
        }
      }
    ]
  },
  "sklearn/sklearn.impute._base/MissingIndicator/_more_tags": {},
  "sklearn/sklearn.impute._iterative/_assign_where": {},
  "sklearn/sklearn.impute._iterative/IterativeImputer/__init__": {
    "estimator": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.impute._iterative/IterativeImputer/__init__/estimator",
          "name": "estimator",
          "qname": "sklearn.impute._iterative.IterativeImputer.__init__.estimator",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "estimator object",
            "default_value": "BayesianRidge()",
            "description": "The estimator to use at each step of the round-robin imputation.\nIf `sample_posterior=True`, the estimator must support\n`return_std` in its `predict` method."
          },
          "type": {
            "kind": "NamedType",
            "name": "estimator object"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.impute._iterative/IterativeImputer/__init__/sample_posterior",
          "name": "sample_posterior",
          "qname": "sklearn.impute._iterative.IterativeImputer.__init__.sample_posterior",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "Whether to sample from the (Gaussian) predictive posterior of the\nfitted estimator for each imputation. Estimator must support\n`return_std` in its `predict` method if set to `True`. Set to\n`True` if using `IterativeImputer` for multiple imputations."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "If sample_posterior equals True"
        },
        "hasAction": {
          "action": ", the estimator must support return_std in its predict method"
        }
      }
    ],
    "max_iter": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.impute._iterative/IterativeImputer/__init__/max_iter",
          "name": "max_iter",
          "qname": "sklearn.impute._iterative.IterativeImputer.__init__.max_iter",
          "default_value": "10",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "10",
            "description": "Maximum number of imputation rounds to perform before returning the\nimputations computed during the final round. A round is a single\nimputation of each feature with missing values. The stopping criterion\nis met once `max(abs(X_t - X_{t-1}))/max(abs(X[known_vals])) < tol`,\nwhere `X_t` is `X` at iteration `t`. Note that early stopping is only\napplied if `sample_posterior=False`."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.impute._iterative/IterativeImputer/__init__/sample_posterior",
          "name": "sample_posterior",
          "qname": "sklearn.impute._iterative.IterativeImputer.__init__.sample_posterior",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "Whether to sample from the (Gaussian) predictive posterior of the\nfitted estimator for each imputation. Estimator must support\n`return_std` in its `predict` method if set to `True`. Set to\n`True` if using `IterativeImputer` for multiple imputations."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "if sample_posterior equals False"
        },
        "hasAction": {
          "action": "that early stopping is only applied"
        }
      }
    ]
  },
  "sklearn/sklearn.impute._iterative/IterativeImputer/_impute_one_feature": {},
  "sklearn/sklearn.impute._iterative/IterativeImputer/_get_neighbor_feat_idx": {},
  "sklearn/sklearn.impute._iterative/IterativeImputer/_get_ordered_idx": {},
  "sklearn/sklearn.impute._iterative/IterativeImputer/_get_abs_corr_mat": {},
  "sklearn/sklearn.impute._iterative/IterativeImputer/_initial_imputation": {},
  "sklearn/sklearn.impute._iterative/IterativeImputer/_validate_limit": {},
  "sklearn/sklearn.impute._iterative/IterativeImputer/fit_transform": {},
  "sklearn/sklearn.impute._iterative/IterativeImputer/transform": {},
  "sklearn/sklearn.impute._iterative/IterativeImputer/fit": {},
  "sklearn/sklearn.impute._iterative/IterativeImputer/get_feature_names_out": {
    "input_features": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.impute._iterative/IterativeImputer/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.impute._iterative.IterativeImputer.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features.\n\n- If `input_features` is `None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then the following input feature names are generated:\n  `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.impute._iterative/IterativeImputer/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.impute._iterative.IterativeImputer.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features.\n\n- If `input_features` is `None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then the following input feature names are generated:\n  `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If input_features is None , then feature_names_in _"
        },
        "hasAction": {
          "action": "is used as feature names in"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.impute._iterative/IterativeImputer/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.impute._iterative.IterativeImputer.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features.\n\n- If `input_features` is `None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then the following input feature names are generated:\n  `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.impute._iterative/IterativeImputer/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.impute._iterative.IterativeImputer.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features.\n\n- If `input_features` is `None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then the following input feature names are generated:\n  `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If input_features is"
        },
        "hasAction": {
          "action": "an array - like , then input_features must match feature_names_in _"
        }
      }
    ]
  },
  "sklearn/sklearn.impute._knn/KNNImputer/__init__": {},
  "sklearn/sklearn.impute._knn/KNNImputer/_calc_impute": {},
  "sklearn/sklearn.impute._knn/KNNImputer/fit": {},
  "sklearn/sklearn.impute._knn/KNNImputer/transform": {},
  "sklearn/sklearn.impute._knn/KNNImputer/get_feature_names_out": {
    "input_features": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.impute._knn/KNNImputer/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.impute._knn.KNNImputer.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features.\n\n- If `input_features` is `None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then the following input feature names are generated:\n  `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.impute._knn/KNNImputer/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.impute._knn.KNNImputer.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features.\n\n- If `input_features` is `None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then the following input feature names are generated:\n  `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If input_features is None , then feature_names_in _"
        },
        "hasAction": {
          "action": "is used as feature names in"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.impute._knn/KNNImputer/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.impute._knn.KNNImputer.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features.\n\n- If `input_features` is `None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then the following input feature names are generated:\n  `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.impute._knn/KNNImputer/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.impute._knn.KNNImputer.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features.\n\n- If `input_features` is `None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then the following input feature names are generated:\n  `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If input_features is"
        },
        "hasAction": {
          "action": "an array - like , then input_features must match feature_names_in _"
        }
      }
    ]
  },
  "sklearn/sklearn.inspection._partial_dependence/_grid_from_X": {},
  "sklearn/sklearn.inspection._partial_dependence/_partial_dependence_recursion": {},
  "sklearn/sklearn.inspection._partial_dependence/_partial_dependence_brute": {},
  "sklearn/sklearn.inspection._partial_dependence/partial_dependence": {
    "X": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.inspection._partial_dependence/partial_dependence/X",
          "name": "X",
          "qname": "sklearn.inspection._partial_dependence.partial_dependence.X",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "{array-like or dataframe} of shape (n_samples, n_features)",
            "default_value": "",
            "description": "``X`` is used to generate a grid of values for the target\n``features`` (where the partial dependence will be evaluated), and\nalso to generate values for the complement features when the\n`method` is 'brute'."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "EnumType",
                "values": []
              },
              {
                "kind": "NamedType",
                "name": "of shape (n_samples, n_features)"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.inspection._partial_dependence/partial_dependence/method",
          "name": "method",
          "qname": "sklearn.inspection._partial_dependence.partial_dependence.method",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'auto', 'recursion', 'brute'}",
            "default_value": "'auto'",
            "description": "The method used to calculate the averaged predictions:\n\n- `'recursion'` is only supported for some tree-based estimators\n  (namely\n  :class:`~sklearn.ensemble.GradientBoostingClassifier`,\n  :class:`~sklearn.ensemble.GradientBoostingRegressor`,\n  :class:`~sklearn.ensemble.HistGradientBoostingClassifier`,\n  :class:`~sklearn.ensemble.HistGradientBoostingRegressor`,\n  :class:`~sklearn.tree.DecisionTreeRegressor`,\n  :class:`~sklearn.ensemble.RandomForestRegressor`,\n  ) when `kind='average'`.\n  This is more efficient in terms of speed.\n  With this method, the target response of a\n  classifier is always the decision function, not the predicted\n  probabilities. Since the `'recursion'` method implicitly computes\n  the average of the Individual Conditional Expectation (ICE) by\n  design, it is not compatible with ICE and thus `kind` must be\n  `'average'`.\n\n- `'brute'` is supported for any estimator, but is more\n  computationally intensive.\n\n- `'auto'`: the `'recursion'` is used for estimators that support it,\n  and `'brute'` is used otherwise.\n\nPlease see :ref:`this note <pdp_method_differences>` for\ndifferences between the `'brute'` and `'recursion'` method."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "brute",
              "auto",
              "recursion"
            ]
          }
        },
        "hasCondition": {
          "condition": "when the method is brute"
        },
        "hasAction": {
          "action": "also to generate values for the complement features"
        }
      }
    ]
  },
  "sklearn/sklearn.inspection._pd_utils/_check_feature_names": {},
  "sklearn/sklearn.inspection._pd_utils/_get_feature_index": {},
  "sklearn/sklearn.inspection._permutation_importance/_weights_scorer": {},
  "sklearn/sklearn.inspection._permutation_importance/_calculate_permutation_scores": {},
  "sklearn/sklearn.inspection._permutation_importance/_create_importances_bunch": {},
  "sklearn/sklearn.inspection._permutation_importance/permutation_importance": {
    "scoring": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.inspection._permutation_importance/permutation_importance/scoring",
          "name": "scoring",
          "qname": "sklearn.inspection._permutation_importance.permutation_importance.scoring",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str, callable, list, tuple, or dict",
            "default_value": "None",
            "description": "Scorer to use.\nIf `scoring` represents a single score, one can use:\n\n- a single string (see :ref:`scoring_parameter`);\n- a callable (see :ref:`scoring`) that returns a single value.\n\nIf `scoring` represents multiple scores, one can use:\n\n- a list or tuple of unique strings;\n- a callable returning a dictionary where the keys are the metric\n  names and the values are the metric scores;\n- a dictionary with metric names as keys and callables a values.\n\nPassing multiple scores to `scoring` is more efficient than calling\n`permutation_importance` for each of the scores as it reuses\npredictions to avoid redundant computation.\n\nIf None, the estimator's default scorer is used."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              },
              {
                "kind": "NamedType",
                "name": "list"
              },
              {
                "kind": "NamedType",
                "name": "tuple"
              },
              {
                "kind": "NamedType",
                "name": "dict"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.inspection._permutation_importance/permutation_importance/scoring",
          "name": "scoring",
          "qname": "sklearn.inspection._permutation_importance.permutation_importance.scoring",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str, callable, list, tuple, or dict",
            "default_value": "None",
            "description": "Scorer to use.\nIf `scoring` represents a single score, one can use:\n\n- a single string (see :ref:`scoring_parameter`);\n- a callable (see :ref:`scoring`) that returns a single value.\n\nIf `scoring` represents multiple scores, one can use:\n\n- a list or tuple of unique strings;\n- a callable returning a dictionary where the keys are the metric\n  names and the values are the metric scores;\n- a dictionary with metric names as keys and callables a values.\n\nPassing multiple scores to `scoring` is more efficient than calling\n`permutation_importance` for each of the scores as it reuses\npredictions to avoid redundant computation.\n\nIf None, the estimator's default scorer is used."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              },
              {
                "kind": "NamedType",
                "name": "list"
              },
              {
                "kind": "NamedType",
                "name": "tuple"
              },
              {
                "kind": "NamedType",
                "name": "dict"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If scoring represents a single score"
        },
        "hasAction": {
          "action": ", one can use : - a single string ( see : ref : scoring_parameter ) ; - a callable ( see : ref : scoring ) that returns a single value"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.inspection._permutation_importance/permutation_importance/scoring",
          "name": "scoring",
          "qname": "sklearn.inspection._permutation_importance.permutation_importance.scoring",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str, callable, list, tuple, or dict",
            "default_value": "None",
            "description": "Scorer to use.\nIf `scoring` represents a single score, one can use:\n\n- a single string (see :ref:`scoring_parameter`);\n- a callable (see :ref:`scoring`) that returns a single value.\n\nIf `scoring` represents multiple scores, one can use:\n\n- a list or tuple of unique strings;\n- a callable returning a dictionary where the keys are the metric\n  names and the values are the metric scores;\n- a dictionary with metric names as keys and callables a values.\n\nPassing multiple scores to `scoring` is more efficient than calling\n`permutation_importance` for each of the scores as it reuses\npredictions to avoid redundant computation.\n\nIf None, the estimator's default scorer is used."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              },
              {
                "kind": "NamedType",
                "name": "list"
              },
              {
                "kind": "NamedType",
                "name": "tuple"
              },
              {
                "kind": "NamedType",
                "name": "dict"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.inspection._permutation_importance/permutation_importance/scoring",
          "name": "scoring",
          "qname": "sklearn.inspection._permutation_importance.permutation_importance.scoring",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str, callable, list, tuple, or dict",
            "default_value": "None",
            "description": "Scorer to use.\nIf `scoring` represents a single score, one can use:\n\n- a single string (see :ref:`scoring_parameter`);\n- a callable (see :ref:`scoring`) that returns a single value.\n\nIf `scoring` represents multiple scores, one can use:\n\n- a list or tuple of unique strings;\n- a callable returning a dictionary where the keys are the metric\n  names and the values are the metric scores;\n- a dictionary with metric names as keys and callables a values.\n\nPassing multiple scores to `scoring` is more efficient than calling\n`permutation_importance` for each of the scores as it reuses\npredictions to avoid redundant computation.\n\nIf None, the estimator's default scorer is used."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              },
              {
                "kind": "NamedType",
                "name": "list"
              },
              {
                "kind": "NamedType",
                "name": "tuple"
              },
              {
                "kind": "NamedType",
                "name": "dict"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If scoring represents multiple scores"
        },
        "hasAction": {
          "action": ", one can use : - a list or tuple of unique strings ; - a callable returning a dictionary where the keys are the metric names and the values are the metric scores ; - a dictionary with metric names as keys and callables a values"
        }
      }
    ],
    "max_samples": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.inspection._permutation_importance/permutation_importance/max_samples",
          "name": "max_samples",
          "qname": "sklearn.inspection._permutation_importance.permutation_importance.max_samples",
          "default_value": "1.0",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int or float",
            "default_value": "1.0",
            "description": "The number of samples to draw from X to compute feature importance\nin each repeat (without replacement).\n\n- If int, then draw `max_samples` samples.\n- If float, then draw `max_samples * X.shape[0]` samples.\n- If `max_samples` is equal to `1.0` or `X.shape[0]`, all samples\n  will be used.\n\nWhile using this option may provide less accurate importance estimates,\nit keeps the method tractable when evaluating feature importance on\nlarge datasets. In combination with `n_repeats`, this allows to control\nthe computational speed vs statistical accuracy trade-off of this method.\n\n.. versionadded:: 1.0"
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "float"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.inspection._permutation_importance/permutation_importance/max_samples",
          "name": "max_samples",
          "qname": "sklearn.inspection._permutation_importance.permutation_importance.max_samples",
          "default_value": "1.0",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int or float",
            "default_value": "1.0",
            "description": "The number of samples to draw from X to compute feature importance\nin each repeat (without replacement).\n\n- If int, then draw `max_samples` samples.\n- If float, then draw `max_samples * X.shape[0]` samples.\n- If `max_samples` is equal to `1.0` or `X.shape[0]`, all samples\n  will be used.\n\nWhile using this option may provide less accurate importance estimates,\nit keeps the method tractable when evaluating feature importance on\nlarge datasets. In combination with `n_repeats`, this allows to control\nthe computational speed vs statistical accuracy trade-off of this method.\n\n.. versionadded:: 1.0"
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "float"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If max_samples is equal to 1.0 or X.shape[0 ]"
        },
        "hasAction": {
          "action": ", all samples will be used"
        }
      }
    ]
  },
  "sklearn/sklearn.inspection._plot.decision_boundary/_check_boundary_response_method": {},
  "sklearn/sklearn.inspection._plot.decision_boundary/DecisionBoundaryDisplay/__init__": {},
  "sklearn/sklearn.inspection._plot.decision_boundary/DecisionBoundaryDisplay/plot": {},
  "sklearn/sklearn.inspection._plot.decision_boundary/DecisionBoundaryDisplay/from_estimator": {
    "response_method": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.inspection._plot.decision_boundary/DecisionBoundaryDisplay/from_estimator/response_method",
          "name": "response_method",
          "qname": "sklearn.inspection._plot.decision_boundary.DecisionBoundaryDisplay.from_estimator.response_method",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'auto', 'predict_proba', 'decision_function',                 'predict'}",
            "default_value": "'auto'",
            "description": "Specifies whether to use :term:`predict_proba`,\n:term:`decision_function`, :term:`predict` as the target response.\nIf set to 'auto', the response method is tried in the following order:\n:term:`decision_function`, :term:`predict_proba`, :term:`predict`.\nFor multiclass problems, :term:`predict` is selected when\n`response_method=\"auto\"`."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "decision_function",
              "predict",
              "predict_proba",
              "auto"
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.inspection._plot.decision_boundary/DecisionBoundaryDisplay/from_estimator/response_method",
          "name": "response_method",
          "qname": "sklearn.inspection._plot.decision_boundary.DecisionBoundaryDisplay.from_estimator.response_method",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'auto', 'predict_proba', 'decision_function',                 'predict'}",
            "default_value": "'auto'",
            "description": "Specifies whether to use :term:`predict_proba`,\n:term:`decision_function`, :term:`predict` as the target response.\nIf set to 'auto', the response method is tried in the following order:\n:term:`decision_function`, :term:`predict_proba`, :term:`predict`.\nFor multiclass problems, :term:`predict` is selected when\n`response_method=\"auto\"`."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "decision_function",
              "predict",
              "predict_proba",
              "auto"
            ]
          }
        },
        "hasCondition": {
          "condition": "when response_method equals auto"
        },
        "hasAction": {
          "action": "For multiclass problems , : term : predict is selected"
        }
      }
    ]
  },
  "sklearn/sklearn.inspection._plot.partial_dependence/PartialDependenceDisplay/__init__": {
    "subsample": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.inspection._plot.partial_dependence/PartialDependenceDisplay/__init__/subsample",
          "name": "subsample",
          "qname": "sklearn.inspection._plot.partial_dependence.PartialDependenceDisplay.__init__.subsample",
          "default_value": "1000",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float, int or None",
            "default_value": "1000",
            "description": "Sampling for ICE curves when `kind` is 'individual' or 'both'.\nIf float, should be between 0.0 and 1.0 and represent the proportion\nof the dataset to be used to plot ICE curves. If int, represents the\nmaximum absolute number of samples to use.\n\nNote that the full dataset is still used to calculate partial\ndependence when `kind='both'`.\n\n.. versionadded:: 0.24"
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "float"
              },
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.inspection._plot.partial_dependence/PartialDependenceDisplay/__init__/kind",
          "name": "kind",
          "qname": "sklearn.inspection._plot.partial_dependence.PartialDependenceDisplay.__init__.kind",
          "default_value": "'average'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'average', 'individual', 'both'} or list of such str",
            "default_value": "'average'",
            "description": "Whether to plot the partial dependence averaged across all the samples\nin the dataset or one line per sample or both.\n\n- ``kind='average'`` results in the traditional PD plot;\n- ``kind='individual'`` results in the ICE plot;\n- ``kind='both'`` results in plotting both the ICE and PD on the same\n  plot.\n\nA list of such strings can be provided to specify `kind` on a per-plot\nbasis. The length of the list should be the same as the number of\ninteraction requested in `features`.\n\n.. note::\n   ICE ('individual' or 'both') is not a valid option for 2-ways\n   interactions plot. As a result, an error will be raised.\n   2-ways interaction plots should always be configured to\n   use the 'average' kind instead.\n\n.. note::\n   The fast ``method='recursion'`` option is only available for\n   ``kind='average'``. Plotting individual dependencies requires using\n   the slower ``method='brute'`` option.\n\n.. versionadded:: 0.24\n   Add `kind` parameter with `'average'`, `'individual'`, and `'both'`\n   options.\n\n.. versionadded:: 1.1\n   Add the possibility to pass a list of string specifying `kind`\n   for each plot."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "EnumType",
                "values": [
                  "average",
                  "both",
                  "individual"
                ]
              },
              {
                "kind": "NamedType",
                "name": "list of such str"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "when kind is individual or both"
        },
        "hasAction": {
          "action": "Sampling for ICE curves"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.inspection._plot.partial_dependence/PartialDependenceDisplay/__init__/subsample",
          "name": "subsample",
          "qname": "sklearn.inspection._plot.partial_dependence.PartialDependenceDisplay.__init__.subsample",
          "default_value": "1000",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float, int or None",
            "default_value": "1000",
            "description": "Sampling for ICE curves when `kind` is 'individual' or 'both'.\nIf float, should be between 0.0 and 1.0 and represent the proportion\nof the dataset to be used to plot ICE curves. If int, represents the\nmaximum absolute number of samples to use.\n\nNote that the full dataset is still used to calculate partial\ndependence when `kind='both'`.\n\n.. versionadded:: 0.24"
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "float"
              },
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.inspection._plot.partial_dependence/PartialDependenceDisplay/__init__/kind",
          "name": "kind",
          "qname": "sklearn.inspection._plot.partial_dependence.PartialDependenceDisplay.__init__.kind",
          "default_value": "'average'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'average', 'individual', 'both'} or list of such str",
            "default_value": "'average'",
            "description": "Whether to plot the partial dependence averaged across all the samples\nin the dataset or one line per sample or both.\n\n- ``kind='average'`` results in the traditional PD plot;\n- ``kind='individual'`` results in the ICE plot;\n- ``kind='both'`` results in plotting both the ICE and PD on the same\n  plot.\n\nA list of such strings can be provided to specify `kind` on a per-plot\nbasis. The length of the list should be the same as the number of\ninteraction requested in `features`.\n\n.. note::\n   ICE ('individual' or 'both') is not a valid option for 2-ways\n   interactions plot. As a result, an error will be raised.\n   2-ways interaction plots should always be configured to\n   use the 'average' kind instead.\n\n.. note::\n   The fast ``method='recursion'`` option is only available for\n   ``kind='average'``. Plotting individual dependencies requires using\n   the slower ``method='brute'`` option.\n\n.. versionadded:: 0.24\n   Add `kind` parameter with `'average'`, `'individual'`, and `'both'`\n   options.\n\n.. versionadded:: 1.1\n   Add the possibility to pass a list of string specifying `kind`\n   for each plot."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "EnumType",
                "values": [
                  "average",
                  "both",
                  "individual"
                ]
              },
              {
                "kind": "NamedType",
                "name": "list of such str"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "when kind equals both"
        },
        "hasAction": {
          "action": "to calculate partial dependence"
        }
      }
    ]
  },
  "sklearn/sklearn.inspection._plot.partial_dependence/PartialDependenceDisplay/from_estimator": {
    "X": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.inspection._plot.partial_dependence/PartialDependenceDisplay/from_estimator/X",
          "name": "X",
          "qname": "sklearn.inspection._plot.partial_dependence.PartialDependenceDisplay.from_estimator.X",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "{array-like, dataframe} of shape (n_samples, n_features)",
            "default_value": "",
            "description": "``X`` is used to generate a grid of values for the target\n``features`` (where the partial dependence will be evaluated), and\nalso to generate values for the complement features when the\n`method` is `'brute'`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "EnumType",
                "values": []
              },
              {
                "kind": "NamedType",
                "name": "of shape (n_samples, n_features)"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.inspection._plot.partial_dependence/PartialDependenceDisplay/from_estimator/method",
          "name": "method",
          "qname": "sklearn.inspection._plot.partial_dependence.PartialDependenceDisplay.from_estimator.method",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "'auto'",
            "description": "The method used to calculate the averaged predictions:\n\n- `'recursion'` is only supported for some tree-based estimators\n  (namely\n  :class:`~sklearn.ensemble.GradientBoostingClassifier`,\n  :class:`~sklearn.ensemble.GradientBoostingRegressor`,\n  :class:`~sklearn.ensemble.HistGradientBoostingClassifier`,\n  :class:`~sklearn.ensemble.HistGradientBoostingRegressor`,\n  :class:`~sklearn.tree.DecisionTreeRegressor`,\n  :class:`~sklearn.ensemble.RandomForestRegressor`\n  but is more efficient in terms of speed.\n  With this method, the target response of a\n  classifier is always the decision function, not the predicted\n  probabilities. Since the `'recursion'` method implicitly computes\n  the average of the ICEs by design, it is not compatible with ICE and\n  thus `kind` must be `'average'`.\n\n- `'brute'` is supported for any estimator, but is more\n  computationally intensive.\n\n- `'auto'`: the `'recursion'` is used for estimators that support it,\n  and `'brute'` is used otherwise.\n\nPlease see :ref:`this note <pdp_method_differences>` for\ndifferences between the `'brute'` and `'recursion'` method."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        "hasCondition": {
          "condition": "when the method is brute"
        },
        "hasAction": {
          "action": "also to generate values for the complement features"
        }
      }
    ],
    "subsample": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.inspection._plot.partial_dependence/PartialDependenceDisplay/from_estimator/subsample",
          "name": "subsample",
          "qname": "sklearn.inspection._plot.partial_dependence.PartialDependenceDisplay.from_estimator.subsample",
          "default_value": "1000",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float, int or None",
            "default_value": "1000",
            "description": "Sampling for ICE curves when `kind` is 'individual' or 'both'.\nIf `float`, should be between 0.0 and 1.0 and represent the proportion\nof the dataset to be used to plot ICE curves. If `int`, represents the\nabsolute number samples to use.\n\nNote that the full dataset is still used to calculate averaged partial\ndependence when `kind='both'`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "float"
              },
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.inspection._plot.partial_dependence/PartialDependenceDisplay/from_estimator/kind",
          "name": "kind",
          "qname": "sklearn.inspection._plot.partial_dependence.PartialDependenceDisplay.from_estimator.kind",
          "default_value": "'average'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'average', 'individual', 'both'}",
            "default_value": "'average'",
            "description": " Whether to plot the partial dependence averaged across all the samples\n in the dataset or one line per sample or both.\n\n - ``kind='average'`` results in the traditional PD plot;\n - ``kind='individual'`` results in the ICE plot.\n\nNote that the fast ``method='recursion'`` option is only available for\n``kind='average'``. Plotting individual dependencies requires using the\nslower ``method='brute'`` option."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "average",
              "both",
              "individual"
            ]
          }
        },
        "hasCondition": {
          "condition": "when kind is individual or both"
        },
        "hasAction": {
          "action": "Sampling for ICE curves"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.inspection._plot.partial_dependence/PartialDependenceDisplay/from_estimator/subsample",
          "name": "subsample",
          "qname": "sklearn.inspection._plot.partial_dependence.PartialDependenceDisplay.from_estimator.subsample",
          "default_value": "1000",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float, int or None",
            "default_value": "1000",
            "description": "Sampling for ICE curves when `kind` is 'individual' or 'both'.\nIf `float`, should be between 0.0 and 1.0 and represent the proportion\nof the dataset to be used to plot ICE curves. If `int`, represents the\nabsolute number samples to use.\n\nNote that the full dataset is still used to calculate averaged partial\ndependence when `kind='both'`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "float"
              },
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.inspection._plot.partial_dependence/PartialDependenceDisplay/from_estimator/kind",
          "name": "kind",
          "qname": "sklearn.inspection._plot.partial_dependence.PartialDependenceDisplay.from_estimator.kind",
          "default_value": "'average'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'average', 'individual', 'both'}",
            "default_value": "'average'",
            "description": " Whether to plot the partial dependence averaged across all the samples\n in the dataset or one line per sample or both.\n\n - ``kind='average'`` results in the traditional PD plot;\n - ``kind='individual'`` results in the ICE plot.\n\nNote that the fast ``method='recursion'`` option is only available for\n``kind='average'``. Plotting individual dependencies requires using the\nslower ``method='brute'`` option."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "average",
              "both",
              "individual"
            ]
          }
        },
        "hasCondition": {
          "condition": "when kind equals both"
        },
        "hasAction": {
          "action": "to calculate averaged partial dependence"
        }
      }
    ]
  },
  "sklearn/sklearn.inspection._plot.partial_dependence/PartialDependenceDisplay/_get_sample_count": {},
  "sklearn/sklearn.inspection._plot.partial_dependence/PartialDependenceDisplay/_plot_ice_lines": {},
  "sklearn/sklearn.inspection._plot.partial_dependence/PartialDependenceDisplay/_plot_average_dependence": {},
  "sklearn/sklearn.inspection._plot.partial_dependence/PartialDependenceDisplay/_plot_one_way_partial_dependence": {},
  "sklearn/sklearn.inspection._plot.partial_dependence/PartialDependenceDisplay/_plot_two_way_partial_dependence": {},
  "sklearn/sklearn.inspection._plot.partial_dependence/PartialDependenceDisplay/plot": {},
  "sklearn/sklearn.linear_model._base/_deprecate_normalize": {},
  "sklearn/sklearn.linear_model._base/make_dataset": {},
  "sklearn/sklearn.linear_model._base/_preprocess_data": {},
  "sklearn/sklearn.linear_model._base/_rescale_data": {},
  "sklearn/sklearn.linear_model._base/LinearModel/fit": {},
  "sklearn/sklearn.linear_model._base/LinearModel/_decision_function": {},
  "sklearn/sklearn.linear_model._base/LinearModel/predict": {},
  "sklearn/sklearn.linear_model._base/LinearModel/_set_intercept": {},
  "sklearn/sklearn.linear_model._base/LinearModel/_more_tags": {},
  "sklearn/sklearn.linear_model._base/LinearClassifierMixin/decision_function": {},
  "sklearn/sklearn.linear_model._base/LinearClassifierMixin/predict": {},
  "sklearn/sklearn.linear_model._base/LinearClassifierMixin/_predict_proba_lr": {},
  "sklearn/sklearn.linear_model._base/SparseCoefMixin/densify": {},
  "sklearn/sklearn.linear_model._base/SparseCoefMixin/sparsify": {},
  "sklearn/sklearn.linear_model._base/LinearRegression/__init__": {},
  "sklearn/sklearn.linear_model._base/LinearRegression/fit": {},
  "sklearn/sklearn.linear_model._base/_check_precomputed_gram_matrix": {},
  "sklearn/sklearn.linear_model._base/_pre_fit": {},
  "sklearn/sklearn.linear_model._bayes/BayesianRidge/__init__": {},
  "sklearn/sklearn.linear_model._bayes/BayesianRidge/fit": {},
  "sklearn/sklearn.linear_model._bayes/BayesianRidge/predict": {},
  "sklearn/sklearn.linear_model._bayes/BayesianRidge/_update_coef_": {},
  "sklearn/sklearn.linear_model._bayes/BayesianRidge/_log_marginal_likelihood": {},
  "sklearn/sklearn.linear_model._bayes/ARDRegression/__init__": {},
  "sklearn/sklearn.linear_model._bayes/ARDRegression/fit": {},
  "sklearn/sklearn.linear_model._bayes/ARDRegression/_update_sigma_woodbury": {},
  "sklearn/sklearn.linear_model._bayes/ARDRegression/_update_sigma": {},
  "sklearn/sklearn.linear_model._bayes/ARDRegression/predict": {},
  "sklearn/sklearn.linear_model._coordinate_descent/_set_order": {},
  "sklearn/sklearn.linear_model._coordinate_descent/_alpha_grid": {},
  "sklearn/sklearn.linear_model._coordinate_descent/lasso_path": {},
  "sklearn/sklearn.linear_model._coordinate_descent/enet_path": {},
  "sklearn/sklearn.linear_model._coordinate_descent/ElasticNet/__init__": {
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._coordinate_descent/ElasticNet/__init__/random_state",
          "name": "random_state",
          "qname": "sklearn.linear_model._coordinate_descent.ElasticNet.__init__.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance",
            "default_value": "None",
            "description": "The seed of the pseudo random number generator that selects a random\nfeature to update. Used when ``selection`` == 'random'.\nPass an int for reproducible output across multiple function calls.\nSee :term:`Glossary <random_state>`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._coordinate_descent/ElasticNet/__init__/selection",
          "name": "selection",
          "qname": "sklearn.linear_model._coordinate_descent.ElasticNet.__init__.selection",
          "default_value": "'cyclic'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'cyclic', 'random'}",
            "default_value": "'cyclic'",
            "description": "If set to 'random', a random coefficient is updated every iteration\nrather than looping over features sequentially by default. This\n(setting to 'random') often leads to significantly faster convergence\nespecially when tol is higher than 1e-4."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "cyclic",
              "random"
            ]
          }
        },
        "hasCondition": {
          "condition": "when selection equals random"
        },
        "hasAction": {
          "action": "Used"
        }
      }
    ],
    "selection": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._coordinate_descent/ElasticNet/__init__/selection",
          "name": "selection",
          "qname": "sklearn.linear_model._coordinate_descent.ElasticNet.__init__.selection",
          "default_value": "'cyclic'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'cyclic', 'random'}",
            "default_value": "'cyclic'",
            "description": "If set to 'random', a random coefficient is updated every iteration\nrather than looping over features sequentially by default. This\n(setting to 'random') often leads to significantly faster convergence\nespecially when tol is higher than 1e-4."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "cyclic",
              "random"
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._coordinate_descent/ElasticNet/__init__/tol",
          "name": "tol",
          "qname": "sklearn.linear_model._coordinate_descent.ElasticNet.__init__.tol",
          "default_value": "0.0001",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "1e-4",
            "description": "The tolerance for the optimization: if the updates are\nsmaller than ``tol``, the optimization code checks the\ndual gap for optimality and continues until it is smaller\nthan ``tol``, see Notes below."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "hasCondition": {
          "condition": "especially when tol is higher than 1e-4"
        },
        "hasAction": {
          "action": "This ( setting to random ) often leads to significantly faster convergence"
        }
      }
    ]
  },
  "sklearn/sklearn.linear_model._coordinate_descent/ElasticNet/fit": {},
  "sklearn/sklearn.linear_model._coordinate_descent/ElasticNet/sparse_coef_@getter": {},
  "sklearn/sklearn.linear_model._coordinate_descent/ElasticNet/_decision_function": {},
  "sklearn/sklearn.linear_model._coordinate_descent/Lasso/__init__": {
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._coordinate_descent/Lasso/__init__/random_state",
          "name": "random_state",
          "qname": "sklearn.linear_model._coordinate_descent.Lasso.__init__.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance",
            "default_value": "None",
            "description": "The seed of the pseudo random number generator that selects a random\nfeature to update. Used when ``selection`` == 'random'.\nPass an int for reproducible output across multiple function calls.\nSee :term:`Glossary <random_state>`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._coordinate_descent/Lasso/__init__/selection",
          "name": "selection",
          "qname": "sklearn.linear_model._coordinate_descent.Lasso.__init__.selection",
          "default_value": "'cyclic'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'cyclic', 'random'}",
            "default_value": "'cyclic'",
            "description": "If set to 'random', a random coefficient is updated every iteration\nrather than looping over features sequentially by default. This\n(setting to 'random') often leads to significantly faster convergence\nespecially when tol is higher than 1e-4."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "cyclic",
              "random"
            ]
          }
        },
        "hasCondition": {
          "condition": "when selection equals random"
        },
        "hasAction": {
          "action": "Used"
        }
      }
    ],
    "selection": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._coordinate_descent/Lasso/__init__/selection",
          "name": "selection",
          "qname": "sklearn.linear_model._coordinate_descent.Lasso.__init__.selection",
          "default_value": "'cyclic'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'cyclic', 'random'}",
            "default_value": "'cyclic'",
            "description": "If set to 'random', a random coefficient is updated every iteration\nrather than looping over features sequentially by default. This\n(setting to 'random') often leads to significantly faster convergence\nespecially when tol is higher than 1e-4."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "cyclic",
              "random"
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._coordinate_descent/Lasso/__init__/tol",
          "name": "tol",
          "qname": "sklearn.linear_model._coordinate_descent.Lasso.__init__.tol",
          "default_value": "0.0001",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "1e-4",
            "description": "The tolerance for the optimization: if the updates are\nsmaller than ``tol``, the optimization code checks the\ndual gap for optimality and continues until it is smaller\nthan ``tol``, see Notes below."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "hasCondition": {
          "condition": "especially when tol is higher than 1e-4"
        },
        "hasAction": {
          "action": "This ( setting to random ) often leads to significantly faster convergence"
        }
      }
    ]
  },
  "sklearn/sklearn.linear_model._coordinate_descent/_path_residuals": {},
  "sklearn/sklearn.linear_model._coordinate_descent/LinearModelCV/__init__": {},
  "sklearn/sklearn.linear_model._coordinate_descent/LinearModelCV/_get_estimator": {},
  "sklearn/sklearn.linear_model._coordinate_descent/LinearModelCV/_is_multitask": {},
  "sklearn/sklearn.linear_model._coordinate_descent/LinearModelCV/path": {},
  "sklearn/sklearn.linear_model._coordinate_descent/LinearModelCV/fit": {},
  "sklearn/sklearn.linear_model._coordinate_descent/LinearModelCV/_more_tags": {},
  "sklearn/sklearn.linear_model._coordinate_descent/LassoCV/__init__": {
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._coordinate_descent/LassoCV/__init__/random_state",
          "name": "random_state",
          "qname": "sklearn.linear_model._coordinate_descent.LassoCV.__init__.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance",
            "default_value": "None",
            "description": "The seed of the pseudo random number generator that selects a random\nfeature to update. Used when ``selection`` == 'random'.\nPass an int for reproducible output across multiple function calls.\nSee :term:`Glossary <random_state>`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._coordinate_descent/LassoCV/__init__/selection",
          "name": "selection",
          "qname": "sklearn.linear_model._coordinate_descent.LassoCV.__init__.selection",
          "default_value": "'cyclic'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'cyclic', 'random'}",
            "default_value": "'cyclic'",
            "description": "If set to 'random', a random coefficient is updated every iteration\nrather than looping over features sequentially by default. This\n(setting to 'random') often leads to significantly faster convergence\nespecially when tol is higher than 1e-4."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "cyclic",
              "random"
            ]
          }
        },
        "hasCondition": {
          "condition": "when selection equals random"
        },
        "hasAction": {
          "action": "Used"
        }
      }
    ],
    "selection": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._coordinate_descent/LassoCV/__init__/selection",
          "name": "selection",
          "qname": "sklearn.linear_model._coordinate_descent.LassoCV.__init__.selection",
          "default_value": "'cyclic'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'cyclic', 'random'}",
            "default_value": "'cyclic'",
            "description": "If set to 'random', a random coefficient is updated every iteration\nrather than looping over features sequentially by default. This\n(setting to 'random') often leads to significantly faster convergence\nespecially when tol is higher than 1e-4."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "cyclic",
              "random"
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._coordinate_descent/LassoCV/__init__/tol",
          "name": "tol",
          "qname": "sklearn.linear_model._coordinate_descent.LassoCV.__init__.tol",
          "default_value": "0.0001",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "1e-4",
            "description": "The tolerance for the optimization: if the updates are\nsmaller than ``tol``, the optimization code checks the\ndual gap for optimality and continues until it is smaller\nthan ``tol``."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "hasCondition": {
          "condition": "especially when tol is higher than 1e-4"
        },
        "hasAction": {
          "action": "This ( setting to random ) often leads to significantly faster convergence"
        }
      }
    ]
  },
  "sklearn/sklearn.linear_model._coordinate_descent/LassoCV/_get_estimator": {},
  "sklearn/sklearn.linear_model._coordinate_descent/LassoCV/_is_multitask": {},
  "sklearn/sklearn.linear_model._coordinate_descent/LassoCV/_more_tags": {},
  "sklearn/sklearn.linear_model._coordinate_descent/ElasticNetCV/__init__": {
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._coordinate_descent/ElasticNetCV/__init__/random_state",
          "name": "random_state",
          "qname": "sklearn.linear_model._coordinate_descent.ElasticNetCV.__init__.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance",
            "default_value": "None",
            "description": "The seed of the pseudo random number generator that selects a random\nfeature to update. Used when ``selection`` == 'random'.\nPass an int for reproducible output across multiple function calls.\nSee :term:`Glossary <random_state>`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._coordinate_descent/ElasticNetCV/__init__/selection",
          "name": "selection",
          "qname": "sklearn.linear_model._coordinate_descent.ElasticNetCV.__init__.selection",
          "default_value": "'cyclic'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'cyclic', 'random'}",
            "default_value": "'cyclic'",
            "description": "If set to 'random', a random coefficient is updated every iteration\nrather than looping over features sequentially by default. This\n(setting to 'random') often leads to significantly faster convergence\nespecially when tol is higher than 1e-4."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "cyclic",
              "random"
            ]
          }
        },
        "hasCondition": {
          "condition": "when selection equals random"
        },
        "hasAction": {
          "action": "Used"
        }
      }
    ],
    "selection": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._coordinate_descent/ElasticNetCV/__init__/selection",
          "name": "selection",
          "qname": "sklearn.linear_model._coordinate_descent.ElasticNetCV.__init__.selection",
          "default_value": "'cyclic'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'cyclic', 'random'}",
            "default_value": "'cyclic'",
            "description": "If set to 'random', a random coefficient is updated every iteration\nrather than looping over features sequentially by default. This\n(setting to 'random') often leads to significantly faster convergence\nespecially when tol is higher than 1e-4."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "cyclic",
              "random"
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._coordinate_descent/ElasticNetCV/__init__/tol",
          "name": "tol",
          "qname": "sklearn.linear_model._coordinate_descent.ElasticNetCV.__init__.tol",
          "default_value": "0.0001",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "1e-4",
            "description": "The tolerance for the optimization: if the updates are\nsmaller than ``tol``, the optimization code checks the\ndual gap for optimality and continues until it is smaller\nthan ``tol``."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "hasCondition": {
          "condition": "especially when tol is higher than 1e-4"
        },
        "hasAction": {
          "action": "This ( setting to random ) often leads to significantly faster convergence"
        }
      }
    ]
  },
  "sklearn/sklearn.linear_model._coordinate_descent/ElasticNetCV/_get_estimator": {},
  "sklearn/sklearn.linear_model._coordinate_descent/ElasticNetCV/_is_multitask": {},
  "sklearn/sklearn.linear_model._coordinate_descent/ElasticNetCV/_more_tags": {},
  "sklearn/sklearn.linear_model._coordinate_descent/MultiTaskElasticNet/__init__": {
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._coordinate_descent/MultiTaskElasticNet/__init__/random_state",
          "name": "random_state",
          "qname": "sklearn.linear_model._coordinate_descent.MultiTaskElasticNet.__init__.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance",
            "default_value": "None",
            "description": "The seed of the pseudo random number generator that selects a random\nfeature to update. Used when ``selection`` == 'random'.\nPass an int for reproducible output across multiple function calls.\nSee :term:`Glossary <random_state>`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._coordinate_descent/MultiTaskElasticNet/__init__/selection",
          "name": "selection",
          "qname": "sklearn.linear_model._coordinate_descent.MultiTaskElasticNet.__init__.selection",
          "default_value": "'cyclic'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'cyclic', 'random'}",
            "default_value": "'cyclic'",
            "description": "If set to 'random', a random coefficient is updated every iteration\nrather than looping over features sequentially by default. This\n(setting to 'random') often leads to significantly faster convergence\nespecially when tol is higher than 1e-4."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "cyclic",
              "random"
            ]
          }
        },
        "hasCondition": {
          "condition": "when selection equals random"
        },
        "hasAction": {
          "action": "Used"
        }
      }
    ],
    "selection": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._coordinate_descent/MultiTaskElasticNet/__init__/selection",
          "name": "selection",
          "qname": "sklearn.linear_model._coordinate_descent.MultiTaskElasticNet.__init__.selection",
          "default_value": "'cyclic'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'cyclic', 'random'}",
            "default_value": "'cyclic'",
            "description": "If set to 'random', a random coefficient is updated every iteration\nrather than looping over features sequentially by default. This\n(setting to 'random') often leads to significantly faster convergence\nespecially when tol is higher than 1e-4."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "cyclic",
              "random"
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._coordinate_descent/MultiTaskElasticNet/__init__/tol",
          "name": "tol",
          "qname": "sklearn.linear_model._coordinate_descent.MultiTaskElasticNet.__init__.tol",
          "default_value": "0.0001",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "1e-4",
            "description": "The tolerance for the optimization: if the updates are\nsmaller than ``tol``, the optimization code checks the\ndual gap for optimality and continues until it is smaller\nthan ``tol``."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "hasCondition": {
          "condition": "especially when tol is higher than 1e-4"
        },
        "hasAction": {
          "action": "This ( setting to random ) often leads to significantly faster convergence"
        }
      }
    ]
  },
  "sklearn/sklearn.linear_model._coordinate_descent/MultiTaskElasticNet/fit": {},
  "sklearn/sklearn.linear_model._coordinate_descent/MultiTaskElasticNet/_more_tags": {},
  "sklearn/sklearn.linear_model._coordinate_descent/MultiTaskLasso/__init__": {
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._coordinate_descent/MultiTaskLasso/__init__/random_state",
          "name": "random_state",
          "qname": "sklearn.linear_model._coordinate_descent.MultiTaskLasso.__init__.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance",
            "default_value": "None",
            "description": "The seed of the pseudo random number generator that selects a random\nfeature to update. Used when ``selection`` == 'random'.\nPass an int for reproducible output across multiple function calls.\nSee :term:`Glossary <random_state>`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._coordinate_descent/MultiTaskLasso/__init__/selection",
          "name": "selection",
          "qname": "sklearn.linear_model._coordinate_descent.MultiTaskLasso.__init__.selection",
          "default_value": "'cyclic'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'cyclic', 'random'}",
            "default_value": "'cyclic'",
            "description": "If set to 'random', a random coefficient is updated every iteration\nrather than looping over features sequentially by default. This\n(setting to 'random') often leads to significantly faster convergence\nespecially when tol is higher than 1e-4."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "cyclic",
              "random"
            ]
          }
        },
        "hasCondition": {
          "condition": "when selection equals random"
        },
        "hasAction": {
          "action": "Used"
        }
      }
    ],
    "selection": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._coordinate_descent/MultiTaskLasso/__init__/selection",
          "name": "selection",
          "qname": "sklearn.linear_model._coordinate_descent.MultiTaskLasso.__init__.selection",
          "default_value": "'cyclic'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'cyclic', 'random'}",
            "default_value": "'cyclic'",
            "description": "If set to 'random', a random coefficient is updated every iteration\nrather than looping over features sequentially by default. This\n(setting to 'random') often leads to significantly faster convergence\nespecially when tol is higher than 1e-4."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "cyclic",
              "random"
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._coordinate_descent/MultiTaskLasso/__init__/tol",
          "name": "tol",
          "qname": "sklearn.linear_model._coordinate_descent.MultiTaskLasso.__init__.tol",
          "default_value": "0.0001",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "1e-4",
            "description": "The tolerance for the optimization: if the updates are\nsmaller than ``tol``, the optimization code checks the\ndual gap for optimality and continues until it is smaller\nthan ``tol``."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "hasCondition": {
          "condition": "especially when tol is higher than 1e-4"
        },
        "hasAction": {
          "action": "This ( setting to random ) often leads to significantly faster convergence"
        }
      }
    ]
  },
  "sklearn/sklearn.linear_model._coordinate_descent/MultiTaskElasticNetCV/__init__": {
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._coordinate_descent/MultiTaskElasticNetCV/__init__/random_state",
          "name": "random_state",
          "qname": "sklearn.linear_model._coordinate_descent.MultiTaskElasticNetCV.__init__.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance",
            "default_value": "None",
            "description": "The seed of the pseudo random number generator that selects a random\nfeature to update. Used when ``selection`` == 'random'.\nPass an int for reproducible output across multiple function calls.\nSee :term:`Glossary <random_state>`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._coordinate_descent/MultiTaskElasticNetCV/__init__/selection",
          "name": "selection",
          "qname": "sklearn.linear_model._coordinate_descent.MultiTaskElasticNetCV.__init__.selection",
          "default_value": "'cyclic'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'cyclic', 'random'}",
            "default_value": "'cyclic'",
            "description": "If set to 'random', a random coefficient is updated every iteration\nrather than looping over features sequentially by default. This\n(setting to 'random') often leads to significantly faster convergence\nespecially when tol is higher than 1e-4."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "cyclic",
              "random"
            ]
          }
        },
        "hasCondition": {
          "condition": "when selection equals random"
        },
        "hasAction": {
          "action": "Used"
        }
      }
    ],
    "selection": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._coordinate_descent/MultiTaskElasticNetCV/__init__/selection",
          "name": "selection",
          "qname": "sklearn.linear_model._coordinate_descent.MultiTaskElasticNetCV.__init__.selection",
          "default_value": "'cyclic'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'cyclic', 'random'}",
            "default_value": "'cyclic'",
            "description": "If set to 'random', a random coefficient is updated every iteration\nrather than looping over features sequentially by default. This\n(setting to 'random') often leads to significantly faster convergence\nespecially when tol is higher than 1e-4."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "cyclic",
              "random"
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._coordinate_descent/MultiTaskElasticNetCV/__init__/tol",
          "name": "tol",
          "qname": "sklearn.linear_model._coordinate_descent.MultiTaskElasticNetCV.__init__.tol",
          "default_value": "0.0001",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "1e-4",
            "description": "The tolerance for the optimization: if the updates are\nsmaller than ``tol``, the optimization code checks the\ndual gap for optimality and continues until it is smaller\nthan ``tol``."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "hasCondition": {
          "condition": "especially when tol is higher than 1e-4"
        },
        "hasAction": {
          "action": "This ( setting to random ) often leads to significantly faster convergence"
        }
      }
    ]
  },
  "sklearn/sklearn.linear_model._coordinate_descent/MultiTaskElasticNetCV/_get_estimator": {},
  "sklearn/sklearn.linear_model._coordinate_descent/MultiTaskElasticNetCV/_is_multitask": {},
  "sklearn/sklearn.linear_model._coordinate_descent/MultiTaskElasticNetCV/_more_tags": {},
  "sklearn/sklearn.linear_model._coordinate_descent/MultiTaskElasticNetCV/fit": {},
  "sklearn/sklearn.linear_model._coordinate_descent/MultiTaskLassoCV/__init__": {
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._coordinate_descent/MultiTaskLassoCV/__init__/random_state",
          "name": "random_state",
          "qname": "sklearn.linear_model._coordinate_descent.MultiTaskLassoCV.__init__.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance",
            "default_value": "None",
            "description": "The seed of the pseudo random number generator that selects a random\nfeature to update. Used when ``selection`` == 'random'.\nPass an int for reproducible output across multiple function calls.\nSee :term:`Glossary <random_state>`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._coordinate_descent/MultiTaskLassoCV/__init__/selection",
          "name": "selection",
          "qname": "sklearn.linear_model._coordinate_descent.MultiTaskLassoCV.__init__.selection",
          "default_value": "'cyclic'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'cyclic', 'random'}",
            "default_value": "'cyclic'",
            "description": "If set to 'random', a random coefficient is updated every iteration\nrather than looping over features sequentially by default. This\n(setting to 'random') often leads to significantly faster convergence\nespecially when tol is higher than 1e-4."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "cyclic",
              "random"
            ]
          }
        },
        "hasCondition": {
          "condition": "when selection equals random"
        },
        "hasAction": {
          "action": "Used"
        }
      }
    ],
    "selection": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._coordinate_descent/MultiTaskLassoCV/__init__/selection",
          "name": "selection",
          "qname": "sklearn.linear_model._coordinate_descent.MultiTaskLassoCV.__init__.selection",
          "default_value": "'cyclic'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'cyclic', 'random'}",
            "default_value": "'cyclic'",
            "description": "If set to 'random', a random coefficient is updated every iteration\nrather than looping over features sequentially by default. This\n(setting to 'random') often leads to significantly faster convergence\nespecially when tol is higher than 1e-4."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "cyclic",
              "random"
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._coordinate_descent/MultiTaskLassoCV/__init__/tol",
          "name": "tol",
          "qname": "sklearn.linear_model._coordinate_descent.MultiTaskLassoCV.__init__.tol",
          "default_value": "0.0001",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "1e-4",
            "description": "The tolerance for the optimization: if the updates are\nsmaller than ``tol``, the optimization code checks the\ndual gap for optimality and continues until it is smaller\nthan ``tol``."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "hasCondition": {
          "condition": "especially when tol is higher than 1e-4"
        },
        "hasAction": {
          "action": "This ( setting to random ) often leads to significantly faster convergence"
        }
      }
    ]
  },
  "sklearn/sklearn.linear_model._coordinate_descent/MultiTaskLassoCV/_get_estimator": {},
  "sklearn/sklearn.linear_model._coordinate_descent/MultiTaskLassoCV/_is_multitask": {},
  "sklearn/sklearn.linear_model._coordinate_descent/MultiTaskLassoCV/_more_tags": {},
  "sklearn/sklearn.linear_model._coordinate_descent/MultiTaskLassoCV/fit": {},
  "sklearn/sklearn.linear_model._huber/_huber_loss_and_gradient": {},
  "sklearn/sklearn.linear_model._huber/HuberRegressor/__init__": {},
  "sklearn/sklearn.linear_model._huber/HuberRegressor/fit": {},
  "sklearn/sklearn.linear_model._least_angle/lars_path": {
    "X": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._least_angle/lars_path/X",
          "name": "X",
          "qname": "sklearn.linear_model._least_angle.lars_path.X",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "None or array-like of shape (n_samples, n_features)",
            "default_value": "",
            "description": "Input data. Note that if X is `None` then the Gram matrix must be\nspecified, i.e., cannot be `None` or `False`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "None"
              },
              {
                "kind": "NamedType",
                "name": "array-like of shape (n_samples, n_features)"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._least_angle/lars_path/X",
          "name": "X",
          "qname": "sklearn.linear_model._least_angle.lars_path.X",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "None or array-like of shape (n_samples, n_features)",
            "default_value": "",
            "description": "Input data. Note that if X is `None` then the Gram matrix must be\nspecified, i.e., cannot be `None` or `False`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "None"
              },
              {
                "kind": "NamedType",
                "name": "array-like of shape (n_samples, n_features)"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "if X is None then"
        },
        "hasAction": {
          "action": "that the Gram matrix must be specified"
        }
      }
    ]
  },
  "sklearn/sklearn.linear_model._least_angle/lars_path_gram": {
    "return_path": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._least_angle/lars_path_gram/return_path",
          "name": "return_path",
          "qname": "sklearn.linear_model._least_angle.lars_path_gram.return_path",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "If ``return_path==True`` returns the entire path, else returns only the\nlast point of the path."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._least_angle/lars_path_gram/return_path",
          "name": "return_path",
          "qname": "sklearn.linear_model._least_angle.lars_path_gram.return_path",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "If ``return_path==True`` returns the entire path, else returns only the\nlast point of the path."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "If return_path equals True returns the entire path"
        },
        "hasAction": {
          "action": ", else returns only the last point of the path"
        }
      }
    ]
  },
  "sklearn/sklearn.linear_model._least_angle/_lars_path_solver": {
    "X": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._least_angle/_lars_path_solver/X",
          "name": "X",
          "qname": "sklearn.linear_model._least_angle._lars_path_solver.X",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "None or ndarray of shape (n_samples, n_features)",
            "default_value": "",
            "description": "Input data. Note that if X is None then Gram must be specified,\ni.e., cannot be None or False."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "None"
              },
              {
                "kind": "NamedType",
                "name": "ndarray of shape (n_samples, n_features)"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._least_angle/_lars_path_solver/X",
          "name": "X",
          "qname": "sklearn.linear_model._least_angle._lars_path_solver.X",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "None or ndarray of shape (n_samples, n_features)",
            "default_value": "",
            "description": "Input data. Note that if X is None then Gram must be specified,\ni.e., cannot be None or False."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "None"
              },
              {
                "kind": "NamedType",
                "name": "ndarray of shape (n_samples, n_features)"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "if X is None then"
        },
        "hasAction": {
          "action": "that Gram must be specified"
        }
      }
    ],
    "return_path": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._least_angle/_lars_path_solver/return_path",
          "name": "return_path",
          "qname": "sklearn.linear_model._least_angle._lars_path_solver.return_path",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "If ``return_path==True`` returns the entire path, else returns only the\nlast point of the path."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._least_angle/_lars_path_solver/return_path",
          "name": "return_path",
          "qname": "sklearn.linear_model._least_angle._lars_path_solver.return_path",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "If ``return_path==True`` returns the entire path, else returns only the\nlast point of the path."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "If return_path equals True returns the entire path"
        },
        "hasAction": {
          "action": ", else returns only the last point of the path"
        }
      }
    ]
  },
  "sklearn/sklearn.linear_model._least_angle/Lars/__init__": {
    "normalize": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._least_angle/Lars/__init__/normalize",
          "name": "normalize",
          "qname": "sklearn.linear_model._least_angle.Lars.__init__.normalize",
          "default_value": "'deprecated'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "This parameter is ignored when ``fit_intercept`` is set to False.\nIf True, the regressors X will be normalized before regression by\nsubtracting the mean and dividing by the l2-norm.\nIf you wish to standardize, please use\n:class:`~sklearn.preprocessing.StandardScaler` before calling ``fit``\non an estimator with ``normalize=False``.\n\n.. versionchanged:: 1.2\n   default changed from True to False in 1.2.\n\n.. deprecated:: 1.2\n    ``normalize`` was deprecated in version 1.2 and will be removed in 1.4."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._least_angle/Lars/__init__/fit_intercept",
          "name": "fit_intercept",
          "qname": "sklearn.linear_model._least_angle.Lars.__init__.fit_intercept",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Whether to calculate the intercept for this model. If set\nto false, no intercept will be used in calculations\n(i.e. data is expected to be centered)."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "when fit_intercept is set to False"
        },
        "hasAction": {
          "action": "This parameter is ignored"
        }
      }
    ],
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._least_angle/Lars/__init__/random_state",
          "name": "random_state",
          "qname": "sklearn.linear_model._least_angle.Lars.__init__.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance or None",
            "default_value": "None",
            "description": "Determines random number generation for jittering. Pass an int\nfor reproducible output across multiple function calls.\nSee :term:`Glossary <random_state>`. Ignored if `jitter` is None.\n\n.. versionadded:: 0.23"
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._least_angle/Lars/__init__/jitter",
          "name": "jitter",
          "qname": "sklearn.linear_model._least_angle.Lars.__init__.jitter",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "None",
            "description": "Upper bound on a uniform noise parameter to be added to the\n`y` values, to satisfy the model's assumption of\none-at-a-time computations. Might help with stability.\n\n.. versionadded:: 0.23"
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "hasCondition": {
          "condition": "if jitter is None"
        },
        "hasAction": {
          "action": "Ignored . .."
        }
      }
    ]
  },
  "sklearn/sklearn.linear_model._least_angle/Lars/_get_gram": {},
  "sklearn/sklearn.linear_model._least_angle/Lars/_fit": {},
  "sklearn/sklearn.linear_model._least_angle/Lars/fit": {},
  "sklearn/sklearn.linear_model._least_angle/LassoLars/__init__": {
    "normalize": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._least_angle/LassoLars/__init__/normalize",
          "name": "normalize",
          "qname": "sklearn.linear_model._least_angle.LassoLars.__init__.normalize",
          "default_value": "'deprecated'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "This parameter is ignored when ``fit_intercept`` is set to False.\nIf True, the regressors X will be normalized before regression by\nsubtracting the mean and dividing by the l2-norm.\nIf you wish to standardize, please use\n:class:`~sklearn.preprocessing.StandardScaler` before calling ``fit``\non an estimator with ``normalize=False``.\n\n.. versionchanged:: 1.2\n   default changed from True to False in 1.2.\n\n.. deprecated:: 1.2\n    ``normalize`` was deprecated in version 1.2 and will be removed in 1.4."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._least_angle/LassoLars/__init__/fit_intercept",
          "name": "fit_intercept",
          "qname": "sklearn.linear_model._least_angle.LassoLars.__init__.fit_intercept",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Whether to calculate the intercept for this model. If set\nto false, no intercept will be used in calculations\n(i.e. data is expected to be centered)."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "when fit_intercept is set to False"
        },
        "hasAction": {
          "action": "This parameter is ignored"
        }
      }
    ],
    "positive": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._least_angle/LassoLars/__init__/positive",
          "name": "positive",
          "qname": "sklearn.linear_model._least_angle.LassoLars.__init__.positive",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "Restrict coefficients to be >= 0. Be aware that you might want to\nremove fit_intercept which is set True by default.\nUnder the positive restriction the model coefficients will not converge\nto the ordinary-least-squares solution for small values of alpha.\nOnly coefficients up to the smallest alpha value (``alphas_[alphas_ >\n0.].min()`` when fit_path=True) reached by the stepwise Lars-Lasso\nalgorithm are typically in congruence with the solution of the\ncoordinate descent Lasso estimator."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._least_angle/LassoLars/__init__/fit_path",
          "name": "fit_path",
          "qname": "sklearn.linear_model._least_angle.LassoLars.__init__.fit_path",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "If ``True`` the full path is stored in the ``coef_path_`` attribute.\nIf you compute the solution for a large problem or many targets,\nsetting ``fit_path`` to ``False`` will lead to a speedup, especially\nwith a small alpha."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "when fit_path equals True )"
        },
        "hasAction": {
          "action": "Only coefficients up to the smallest alpha value ( alphas_[alphas _ > 0.].min ( ) reached by the stepwise Lars - Lasso algorithm are typically in congruence with the solution of the coordinate descent Lasso estimator"
        }
      }
    ],
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._least_angle/LassoLars/__init__/random_state",
          "name": "random_state",
          "qname": "sklearn.linear_model._least_angle.LassoLars.__init__.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance or None",
            "default_value": "None",
            "description": "Determines random number generation for jittering. Pass an int\nfor reproducible output across multiple function calls.\nSee :term:`Glossary <random_state>`. Ignored if `jitter` is None.\n\n.. versionadded:: 0.23"
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._least_angle/LassoLars/__init__/jitter",
          "name": "jitter",
          "qname": "sklearn.linear_model._least_angle.LassoLars.__init__.jitter",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "None",
            "description": "Upper bound on a uniform noise parameter to be added to the\n`y` values, to satisfy the model's assumption of\none-at-a-time computations. Might help with stability.\n\n.. versionadded:: 0.23"
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "hasCondition": {
          "condition": "if jitter is None"
        },
        "hasAction": {
          "action": "Ignored . .."
        }
      }
    ]
  },
  "sklearn/sklearn.linear_model._least_angle/_check_copy_and_writeable": {},
  "sklearn/sklearn.linear_model._least_angle/_lars_path_residues": {
    "normalize": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._least_angle/_lars_path_residues/normalize",
          "name": "normalize",
          "qname": "sklearn.linear_model._least_angle._lars_path_residues.normalize",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "This parameter is ignored when ``fit_intercept`` is set to False.\nIf True, the regressors X will be normalized before regression by\nsubtracting the mean and dividing by the l2-norm.\nIf you wish to standardize, please use\n:class:`~sklearn.preprocessing.StandardScaler` before calling ``fit``\non an estimator with ``normalize=False``.\n\n.. versionchanged:: 1.2\n   default changed from True to False in 1.2.\n\n.. deprecated:: 1.2\n    ``normalize`` was deprecated in version 1.2 and will be removed in 1.4."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._least_angle/_lars_path_residues/fit_intercept",
          "name": "fit_intercept",
          "qname": "sklearn.linear_model._least_angle._lars_path_residues.fit_intercept",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "whether to calculate the intercept for this model. If set\nto false, no intercept will be used in calculations\n(i.e. data is expected to be centered)."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "when fit_intercept is set to False"
        },
        "hasAction": {
          "action": "This parameter is ignored"
        }
      }
    ]
  },
  "sklearn/sklearn.linear_model._least_angle/LarsCV/__init__": {
    "normalize": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._least_angle/LarsCV/__init__/normalize",
          "name": "normalize",
          "qname": "sklearn.linear_model._least_angle.LarsCV.__init__.normalize",
          "default_value": "'deprecated'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "This parameter is ignored when ``fit_intercept`` is set to False.\nIf True, the regressors X will be normalized before regression by\nsubtracting the mean and dividing by the l2-norm.\nIf you wish to standardize, please use\n:class:`~sklearn.preprocessing.StandardScaler` before calling ``fit``\non an estimator with ``normalize=False``.\n\n.. versionchanged:: 1.2\n   default changed from True to False in 1.2.\n\n.. deprecated:: 1.2\n    ``normalize`` was deprecated in version 1.2 and will be removed in 1.4."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._least_angle/LarsCV/__init__/fit_intercept",
          "name": "fit_intercept",
          "qname": "sklearn.linear_model._least_angle.LarsCV.__init__.fit_intercept",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Whether to calculate the intercept for this model. If set\nto false, no intercept will be used in calculations\n(i.e. data is expected to be centered)."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "when fit_intercept is set to False"
        },
        "hasAction": {
          "action": "This parameter is ignored"
        }
      }
    ]
  },
  "sklearn/sklearn.linear_model._least_angle/LarsCV/_more_tags": {},
  "sklearn/sklearn.linear_model._least_angle/LarsCV/fit": {},
  "sklearn/sklearn.linear_model._least_angle/LassoLarsCV/__init__": {
    "normalize": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._least_angle/LassoLarsCV/__init__/normalize",
          "name": "normalize",
          "qname": "sklearn.linear_model._least_angle.LassoLarsCV.__init__.normalize",
          "default_value": "'deprecated'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "This parameter is ignored when ``fit_intercept`` is set to False.\nIf True, the regressors X will be normalized before regression by\nsubtracting the mean and dividing by the l2-norm.\nIf you wish to standardize, please use\n:class:`~sklearn.preprocessing.StandardScaler` before calling ``fit``\non an estimator with ``normalize=False``.\n\n.. versionchanged:: 1.2\n   default changed from True to False in 1.2.\n\n.. deprecated:: 1.2\n    ``normalize`` was deprecated in version 1.2 and will be removed in 1.4."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._least_angle/LassoLarsCV/__init__/fit_intercept",
          "name": "fit_intercept",
          "qname": "sklearn.linear_model._least_angle.LassoLarsCV.__init__.fit_intercept",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Whether to calculate the intercept for this model. If set\nto false, no intercept will be used in calculations\n(i.e. data is expected to be centered)."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "when fit_intercept is set to False"
        },
        "hasAction": {
          "action": "This parameter is ignored"
        }
      }
    ]
  },
  "sklearn/sklearn.linear_model._least_angle/LassoLarsIC/__init__": {
    "normalize": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._least_angle/LassoLarsIC/__init__/normalize",
          "name": "normalize",
          "qname": "sklearn.linear_model._least_angle.LassoLarsIC.__init__.normalize",
          "default_value": "'deprecated'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "This parameter is ignored when ``fit_intercept`` is set to False.\nIf True, the regressors X will be normalized before regression by\nsubtracting the mean and dividing by the l2-norm.\nIf you wish to standardize, please use\n:class:`~sklearn.preprocessing.StandardScaler` before calling ``fit``\non an estimator with ``normalize=False``.\n\n.. versionchanged:: 1.2\n   default changed from True to False in 1.2.\n\n.. deprecated:: 1.2\n    ``normalize`` was deprecated in version 1.2 and will be removed in 1.4."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._least_angle/LassoLarsIC/__init__/fit_intercept",
          "name": "fit_intercept",
          "qname": "sklearn.linear_model._least_angle.LassoLarsIC.__init__.fit_intercept",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Whether to calculate the intercept for this model. If set\nto false, no intercept will be used in calculations\n(i.e. data is expected to be centered)."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "when fit_intercept is set to False"
        },
        "hasAction": {
          "action": "This parameter is ignored"
        }
      }
    ]
  },
  "sklearn/sklearn.linear_model._least_angle/LassoLarsIC/_more_tags": {},
  "sklearn/sklearn.linear_model._least_angle/LassoLarsIC/fit": {},
  "sklearn/sklearn.linear_model._least_angle/LassoLarsIC/_estimate_noise_variance": {},
  "sklearn/sklearn.linear_model._linear_loss/LinearModelLoss/__init__": {},
  "sklearn/sklearn.linear_model._linear_loss/LinearModelLoss/init_zero_coef": {},
  "sklearn/sklearn.linear_model._linear_loss/LinearModelLoss/weight_intercept": {},
  "sklearn/sklearn.linear_model._linear_loss/LinearModelLoss/weight_intercept_raw": {},
  "sklearn/sklearn.linear_model._linear_loss/LinearModelLoss/l2_penalty": {},
  "sklearn/sklearn.linear_model._linear_loss/LinearModelLoss/loss": {},
  "sklearn/sklearn.linear_model._linear_loss/LinearModelLoss/loss_gradient": {},
  "sklearn/sklearn.linear_model._linear_loss/LinearModelLoss/gradient": {},
  "sklearn/sklearn.linear_model._linear_loss/LinearModelLoss/gradient_hessian": {},
  "sklearn/sklearn.linear_model._linear_loss/LinearModelLoss/gradient_hessian_product": {},
  "sklearn/sklearn.linear_model._logistic/_check_solver": {},
  "sklearn/sklearn.linear_model._logistic/_check_multi_class": {},
  "sklearn/sklearn.linear_model._logistic/_logistic_regression_path": {
    "class_weight": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._logistic/_logistic_regression_path/class_weight",
          "name": "class_weight",
          "qname": "sklearn.linear_model._logistic._logistic_regression_path.class_weight",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "dict or 'balanced'",
            "default_value": "None",
            "description": "Weights associated with classes in the form ``{class_label: weight}``.\nIf not given, all classes are supposed to have weight one.\n\nThe \"balanced\" mode uses the values of y to automatically adjust\nweights inversely proportional to class frequencies in the input data\nas ``n_samples / (n_classes * np.bincount(y))``.\n\nNote that these weights will be multiplied with sample_weight (passed\nthrough the fit method) if sample_weight is specified."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "dict"
              },
              {
                "kind": "NamedType",
                "name": "'balanced'"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._logistic/_logistic_regression_path/sample_weight",
          "name": "sample_weight",
          "qname": "sklearn.linear_model._logistic._logistic_regression_path.sample_weight",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "array-like of shape(n_samples,)",
            "default_value": "None",
            "description": "Array of weights that are assigned to individual samples.\nIf not provided, then each sample is given unit weight."
          },
          "type": {
            "kind": "NamedType",
            "name": "array-like of shape(n_samples,)"
          }
        },
        "hasCondition": {
          "condition": "if sample_weight is specified"
        },
        "hasAction": {
          "action": "( passed through the fit method )"
        }
      }
    ],
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._logistic/_logistic_regression_path/random_state",
          "name": "random_state",
          "qname": "sklearn.linear_model._logistic._logistic_regression_path.random_state",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "int, RandomState instance",
            "default_value": "None",
            "description": "Used when ``solver`` == 'sag', 'saga' or 'liblinear' to shuffle the\ndata. See :term:`Glossary <random_state>` for details."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._logistic/_logistic_regression_path/solver",
          "name": "solver",
          "qname": "sklearn.linear_model._logistic._logistic_regression_path.solver",
          "default_value": "'lbfgs'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "{'lbfgs', 'liblinear', 'newton-cg', 'newton-cholesky', 'sag', 'saga'}",
            "default_value": "'lbfgs'",
            "description": "Numerical solver to use."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "newton-cholesky",
              "saga",
              "liblinear",
              "newton-cg",
              "lbfgs",
              "sag"
            ]
          }
        },
        "hasCondition": {
          "condition": "when solver equals sag , saga or liblinear to shuffle the data"
        },
        "hasAction": {
          "action": "Used"
        }
      }
    ],
    "l1_ratio": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._logistic/_logistic_regression_path/l1_ratio",
          "name": "l1_ratio",
          "qname": "sklearn.linear_model._logistic._logistic_regression_path.l1_ratio",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "float",
            "default_value": "None",
            "description": "The Elastic-Net mixing parameter, with ``0 <= l1_ratio <= 1``. Only\nused if ``penalty='elasticnet'``. Setting ``l1_ratio=0`` is equivalent\nto using ``penalty='l2'``, while setting ``l1_ratio=1`` is equivalent\nto using ``penalty='l1'``. For ``0 < l1_ratio <1``, the penalty is a\ncombination of L1 and L2."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._logistic/_logistic_regression_path/penalty",
          "name": "penalty",
          "qname": "sklearn.linear_model._logistic._logistic_regression_path.penalty",
          "default_value": "'l2'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "{'l1', 'l2', 'elasticnet'}",
            "default_value": "'l2'",
            "description": "Used to specify the norm used in the penalization. The 'newton-cg',\n'sag' and 'lbfgs' solvers support only l2 penalties. 'elasticnet' is\nonly supported by the 'saga' solver."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "elasticnet",
              "l1",
              "l2"
            ]
          }
        },
        "hasCondition": {
          "condition": "if penalty equals elasticnet"
        },
        "hasAction": {
          "action": "Only used"
        }
      }
    ]
  },
  "sklearn/sklearn.linear_model._logistic/_log_reg_scoring_path": {
    "Cs": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._logistic/_log_reg_scoring_path/Cs",
          "name": "Cs",
          "qname": "sklearn.linear_model._logistic._log_reg_scoring_path.Cs",
          "default_value": "10",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "int or list of floats",
            "default_value": "10",
            "description": "Each of the values in Cs describes the inverse of\nregularization strength. If Cs is as an int, then a grid of Cs\nvalues are chosen in a logarithmic scale between 1e-4 and 1e4.\nIf not provided, then a fixed set of values for Cs are used."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "list of floats"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._logistic/_log_reg_scoring_path/Cs",
          "name": "Cs",
          "qname": "sklearn.linear_model._logistic._log_reg_scoring_path.Cs",
          "default_value": "10",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "int or list of floats",
            "default_value": "10",
            "description": "Each of the values in Cs describes the inverse of\nregularization strength. If Cs is as an int, then a grid of Cs\nvalues are chosen in a logarithmic scale between 1e-4 and 1e4.\nIf not provided, then a fixed set of values for Cs are used."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "list of floats"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If Cs is as an int"
        },
        "hasAction": {
          "action": ", then a grid of Cs values are chosen in a logarithmic scale between 1e-4 and 1e4"
        }
      }
    ],
    "class_weight": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._logistic/_log_reg_scoring_path/class_weight",
          "name": "class_weight",
          "qname": "sklearn.linear_model._logistic._log_reg_scoring_path.class_weight",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "dict or 'balanced'",
            "default_value": "None",
            "description": "Weights associated with classes in the form ``{class_label: weight}``.\nIf not given, all classes are supposed to have weight one.\n\nThe \"balanced\" mode uses the values of y to automatically adjust\nweights inversely proportional to class frequencies in the input data\nas ``n_samples / (n_classes * np.bincount(y))``\n\nNote that these weights will be multiplied with sample_weight (passed\nthrough the fit method) if sample_weight is specified."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "dict"
              },
              {
                "kind": "NamedType",
                "name": "'balanced'"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._logistic/_log_reg_scoring_path/sample_weight",
          "name": "sample_weight",
          "qname": "sklearn.linear_model._logistic._log_reg_scoring_path.sample_weight",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "array-like of shape(n_samples,)",
            "default_value": "None",
            "description": "Array of weights that are assigned to individual samples.\nIf not provided, then each sample is given unit weight."
          },
          "type": {
            "kind": "NamedType",
            "name": "array-like of shape(n_samples,)"
          }
        },
        "hasCondition": {
          "condition": "if sample_weight is specified"
        },
        "hasAction": {
          "action": "( passed through the fit method )"
        }
      }
    ],
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._logistic/_log_reg_scoring_path/random_state",
          "name": "random_state",
          "qname": "sklearn.linear_model._logistic._log_reg_scoring_path.random_state",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "int, RandomState instance",
            "default_value": "None",
            "description": "Used when ``solver`` == 'sag', 'saga' or 'liblinear' to shuffle the\ndata. See :term:`Glossary <random_state>` for details."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._logistic/_log_reg_scoring_path/solver",
          "name": "solver",
          "qname": "sklearn.linear_model._logistic._log_reg_scoring_path.solver",
          "default_value": "'lbfgs'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "{'lbfgs', 'liblinear', 'newton-cg', 'newton-cholesky', 'sag', 'saga'}",
            "default_value": "'lbfgs'",
            "description": "Decides which solver to use."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "newton-cholesky",
              "saga",
              "liblinear",
              "newton-cg",
              "lbfgs",
              "sag"
            ]
          }
        },
        "hasCondition": {
          "condition": "when solver equals sag , saga or liblinear to shuffle the data"
        },
        "hasAction": {
          "action": "Used"
        }
      }
    ],
    "l1_ratio": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._logistic/_log_reg_scoring_path/l1_ratio",
          "name": "l1_ratio",
          "qname": "sklearn.linear_model._logistic._log_reg_scoring_path.l1_ratio",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "float",
            "default_value": "None",
            "description": "The Elastic-Net mixing parameter, with ``0 <= l1_ratio <= 1``. Only\nused if ``penalty='elasticnet'``. Setting ``l1_ratio=0`` is equivalent\nto using ``penalty='l2'``, while setting ``l1_ratio=1`` is equivalent\nto using ``penalty='l1'``. For ``0 < l1_ratio <1``, the penalty is a\ncombination of L1 and L2."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._logistic/_log_reg_scoring_path/penalty",
          "name": "penalty",
          "qname": "sklearn.linear_model._logistic._log_reg_scoring_path.penalty",
          "default_value": "'l2'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "{'l1', 'l2', 'elasticnet'}",
            "default_value": "'l2'",
            "description": "Used to specify the norm used in the penalization. The 'newton-cg',\n'sag' and 'lbfgs' solvers support only l2 penalties. 'elasticnet' is\nonly supported by the 'saga' solver."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "elasticnet",
              "l1",
              "l2"
            ]
          }
        },
        "hasCondition": {
          "condition": "if penalty equals elasticnet"
        },
        "hasAction": {
          "action": "Only used"
        }
      }
    ]
  },
  "sklearn/sklearn.linear_model._logistic/LogisticRegression/__init__": {
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._logistic/LogisticRegression/__init__/random_state",
          "name": "random_state",
          "qname": "sklearn.linear_model._logistic.LogisticRegression.__init__.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance",
            "default_value": "None",
            "description": "Used when ``solver`` == 'sag', 'saga' or 'liblinear' to shuffle the\ndata. See :term:`Glossary <random_state>` for details."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._logistic/LogisticRegression/__init__/solver",
          "name": "solver",
          "qname": "sklearn.linear_model._logistic.LogisticRegression.__init__.solver",
          "default_value": "'lbfgs'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'lbfgs', 'liblinear', 'newton-cg', 'newton-cholesky', 'sag', 'saga'}",
            "default_value": "'lbfgs'",
            "description": "Algorithm to use in the optimization problem. Default is 'lbfgs'.\nTo choose a solver, you might want to consider the following aspects:\n\n    - For small datasets, 'liblinear' is a good choice, whereas 'sag'\n      and 'saga' are faster for large ones;\n    - For multiclass problems, only 'newton-cg', 'sag', 'saga' and\n      'lbfgs' handle multinomial loss;\n    - 'liblinear' is limited to one-versus-rest schemes.\n    - 'newton-cholesky' is a good choice for `n_samples` >> `n_features`,\n      especially with one-hot encoded categorical features with rare\n      categories. Note that it is limited to binary classification and the\n      one-versus-rest reduction for multiclass classification. Be aware that\n      the memory usage of this solver has a quadratic dependency on\n      `n_features` because it explicitly computes the Hessian matrix.\n\n.. warning::\n   The choice of the algorithm depends on the penalty chosen.\n   Supported penalties by solver:\n\n   - 'lbfgs'           -   ['l2', None]\n   - 'liblinear'       -   ['l1', 'l2']\n   - 'newton-cg'       -   ['l2', None]\n   - 'newton-cholesky' -   ['l2', None]\n   - 'sag'             -   ['l2', None]\n   - 'saga'            -   ['elasticnet', 'l1', 'l2', None]\n\n.. note::\n   'sag' and 'saga' fast convergence is only guaranteed on features\n   with approximately the same scale. You can preprocess the data with\n   a scaler from :mod:`sklearn.preprocessing`.\n\n.. seealso::\n   Refer to the User Guide for more information regarding\n   :class:`LogisticRegression` and more specifically the\n   :ref:`Table <Logistic_regression>`\n   summarizing solver/penalty supports.\n\n.. versionadded:: 0.17\n   Stochastic Average Gradient descent solver.\n.. versionadded:: 0.19\n   SAGA solver.\n.. versionchanged:: 0.22\n    The default solver changed from 'liblinear' to 'lbfgs' in 0.22.\n.. versionadded:: 1.2\n   newton-cholesky solver."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "newton-cholesky",
              "saga",
              "liblinear",
              "newton-cg",
              "lbfgs",
              "sag"
            ]
          }
        },
        "hasCondition": {
          "condition": "when solver equals sag , saga or liblinear to shuffle the data"
        },
        "hasAction": {
          "action": "Used"
        }
      }
    ],
    "n_jobs": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._logistic/LogisticRegression/__init__/n_jobs",
          "name": "n_jobs",
          "qname": "sklearn.linear_model._logistic.LogisticRegression.__init__.n_jobs",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "None",
            "description": "Number of CPU cores used when parallelizing over classes if\nmulti_class='ovr'\". This parameter is ignored when the ``solver`` is\nset to 'liblinear' regardless of whether 'multi_class' is specified or\nnot. ``None`` means 1 unless in a :obj:`joblib.parallel_backend`\ncontext. ``-1`` means using all processors.\nSee :term:`Glossary <n_jobs>` for more details."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._logistic/LogisticRegression/__init__/multi_class",
          "name": "multi_class",
          "qname": "sklearn.linear_model._logistic.LogisticRegression.__init__.multi_class",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'auto', 'ovr', 'multinomial'}",
            "default_value": "'auto'",
            "description": "If the option chosen is 'ovr', then a binary problem is fit for each\nlabel. For 'multinomial' the loss minimised is the multinomial loss fit\nacross the entire probability distribution, *even when the data is\nbinary*. 'multinomial' is unavailable when solver='liblinear'.\n'auto' selects 'ovr' if the data is binary, or if solver='liblinear',\nand otherwise selects 'multinomial'.\n\n.. versionadded:: 0.18\n   Stochastic Average Gradient descent solver for 'multinomial' case.\n.. versionchanged:: 0.22\n    Default changed from 'ovr' to 'auto' in 0.22."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "ovr",
              "multinomial",
              "auto"
            ]
          }
        },
        "hasCondition": {
          "condition": "if multi_class equals ovr"
        },
        "hasAction": {
          "action": "when parallelizing over classes"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._logistic/LogisticRegression/__init__/n_jobs",
          "name": "n_jobs",
          "qname": "sklearn.linear_model._logistic.LogisticRegression.__init__.n_jobs",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "None",
            "description": "Number of CPU cores used when parallelizing over classes if\nmulti_class='ovr'\". This parameter is ignored when the ``solver`` is\nset to 'liblinear' regardless of whether 'multi_class' is specified or\nnot. ``None`` means 1 unless in a :obj:`joblib.parallel_backend`\ncontext. ``-1`` means using all processors.\nSee :term:`Glossary <n_jobs>` for more details."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._logistic/LogisticRegression/__init__/solver",
          "name": "solver",
          "qname": "sklearn.linear_model._logistic.LogisticRegression.__init__.solver",
          "default_value": "'lbfgs'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'lbfgs', 'liblinear', 'newton-cg', 'newton-cholesky', 'sag', 'saga'}",
            "default_value": "'lbfgs'",
            "description": "Algorithm to use in the optimization problem. Default is 'lbfgs'.\nTo choose a solver, you might want to consider the following aspects:\n\n    - For small datasets, 'liblinear' is a good choice, whereas 'sag'\n      and 'saga' are faster for large ones;\n    - For multiclass problems, only 'newton-cg', 'sag', 'saga' and\n      'lbfgs' handle multinomial loss;\n    - 'liblinear' is limited to one-versus-rest schemes.\n    - 'newton-cholesky' is a good choice for `n_samples` >> `n_features`,\n      especially with one-hot encoded categorical features with rare\n      categories. Note that it is limited to binary classification and the\n      one-versus-rest reduction for multiclass classification. Be aware that\n      the memory usage of this solver has a quadratic dependency on\n      `n_features` because it explicitly computes the Hessian matrix.\n\n.. warning::\n   The choice of the algorithm depends on the penalty chosen.\n   Supported penalties by solver:\n\n   - 'lbfgs'           -   ['l2', None]\n   - 'liblinear'       -   ['l1', 'l2']\n   - 'newton-cg'       -   ['l2', None]\n   - 'newton-cholesky' -   ['l2', None]\n   - 'sag'             -   ['l2', None]\n   - 'saga'            -   ['elasticnet', 'l1', 'l2', None]\n\n.. note::\n   'sag' and 'saga' fast convergence is only guaranteed on features\n   with approximately the same scale. You can preprocess the data with\n   a scaler from :mod:`sklearn.preprocessing`.\n\n.. seealso::\n   Refer to the User Guide for more information regarding\n   :class:`LogisticRegression` and more specifically the\n   :ref:`Table <Logistic_regression>`\n   summarizing solver/penalty supports.\n\n.. versionadded:: 0.17\n   Stochastic Average Gradient descent solver.\n.. versionadded:: 0.19\n   SAGA solver.\n.. versionchanged:: 0.22\n    The default solver changed from 'liblinear' to 'lbfgs' in 0.22.\n.. versionadded:: 1.2\n   newton-cholesky solver."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "newton-cholesky",
              "saga",
              "liblinear",
              "newton-cg",
              "lbfgs",
              "sag"
            ]
          }
        },
        "hasCondition": {
          "condition": "when the solver is set to liblinear regardless of whether multi_class is specified or not"
        },
        "hasAction": {
          "action": "This parameter is ignored"
        }
      }
    ],
    "l1_ratio": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._logistic/LogisticRegression/__init__/l1_ratio",
          "name": "l1_ratio",
          "qname": "sklearn.linear_model._logistic.LogisticRegression.__init__.l1_ratio",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "None",
            "description": "The Elastic-Net mixing parameter, with ``0 <= l1_ratio <= 1``. Only\nused if ``penalty='elasticnet'``. Setting ``l1_ratio=0`` is equivalent\nto using ``penalty='l2'``, while setting ``l1_ratio=1`` is equivalent\nto using ``penalty='l1'``. For ``0 < l1_ratio <1``, the penalty is a\ncombination of L1 and L2."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._logistic/LogisticRegression/__init__/penalty",
          "name": "penalty",
          "qname": "sklearn.linear_model._logistic.LogisticRegression.__init__.penalty",
          "default_value": "'l2'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "{'l1', 'l2', 'elasticnet', None}",
            "default_value": "'l2'",
            "description": "Specify the norm of the penalty:\n\n- `None`: no penalty is added;\n- `'l2'`: add a L2 penalty term and it is the default choice;\n- `'l1'`: add a L1 penalty term;\n- `'elasticnet'`: both L1 and L2 penalty terms are added.\n\n.. warning::\n   Some penalties may not work with some solvers. See the parameter\n   `solver` below, to know the compatibility between the penalty and\n   solver.\n\n.. versionadded:: 0.19\n   l1 penalty with SAGA solver (allowing 'multinomial' + L1)\n\n.. deprecated:: 1.2\n   The 'none' option was deprecated in version 1.2, and will be removed\n   in 1.4. Use `None` instead."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "elasticnet",
              "l1",
              "l2"
            ]
          }
        },
        "hasCondition": {
          "condition": "if penalty equals elasticnet"
        },
        "hasAction": {
          "action": "Only used"
        }
      }
    ]
  },
  "sklearn/sklearn.linear_model._logistic/LogisticRegression/fit": {},
  "sklearn/sklearn.linear_model._logistic/LogisticRegression/predict_proba": {},
  "sklearn/sklearn.linear_model._logistic/LogisticRegression/predict_log_proba": {},
  "sklearn/sklearn.linear_model._logistic/LogisticRegressionCV/__init__": {
    "Cs": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._logistic/LogisticRegressionCV/__init__/Cs",
          "name": "Cs",
          "qname": "sklearn.linear_model._logistic.LogisticRegressionCV.__init__.Cs",
          "default_value": "10",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int or list of floats",
            "default_value": "10",
            "description": "Each of the values in Cs describes the inverse of regularization\nstrength. If Cs is as an int, then a grid of Cs values are chosen\nin a logarithmic scale between 1e-4 and 1e4.\nLike in support vector machines, smaller values specify stronger\nregularization."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "list of floats"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._logistic/LogisticRegressionCV/__init__/Cs",
          "name": "Cs",
          "qname": "sklearn.linear_model._logistic.LogisticRegressionCV.__init__.Cs",
          "default_value": "10",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int or list of floats",
            "default_value": "10",
            "description": "Each of the values in Cs describes the inverse of regularization\nstrength. If Cs is as an int, then a grid of Cs values are chosen\nin a logarithmic scale between 1e-4 and 1e4.\nLike in support vector machines, smaller values specify stronger\nregularization."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "list of floats"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If Cs is as an int"
        },
        "hasAction": {
          "action": ", then a grid of Cs values are chosen in a logarithmic scale between 1e-4 and 1e4"
        }
      }
    ],
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._logistic/LogisticRegressionCV/__init__/random_state",
          "name": "random_state",
          "qname": "sklearn.linear_model._logistic.LogisticRegressionCV.__init__.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance",
            "default_value": "None",
            "description": "Used when `solver='sag'`, 'saga' or 'liblinear' to shuffle the data.\nNote that this only applies to the solver and not the cross-validation\ngenerator. See :term:`Glossary <random_state>` for details."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._logistic/LogisticRegressionCV/__init__/solver",
          "name": "solver",
          "qname": "sklearn.linear_model._logistic.LogisticRegressionCV.__init__.solver",
          "default_value": "'lbfgs'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'lbfgs', 'liblinear', 'newton-cg', 'newton-cholesky', 'sag', 'saga'}",
            "default_value": "'lbfgs'",
            "description": "Algorithm to use in the optimization problem. Default is 'lbfgs'.\nTo choose a solver, you might want to consider the following aspects:\n\n    - For small datasets, 'liblinear' is a good choice, whereas 'sag'\n      and 'saga' are faster for large ones;\n    - For multiclass problems, only 'newton-cg', 'sag', 'saga' and\n      'lbfgs' handle multinomial loss;\n    - 'liblinear' might be slower in :class:`LogisticRegressionCV`\n      because it does not handle warm-starting. 'liblinear' is\n      limited to one-versus-rest schemes.\n    - 'newton-cholesky' is a good choice for `n_samples` >> `n_features`,\n      especially with one-hot encoded categorical features with rare\n      categories. Note that it is limited to binary classification and the\n      one-versus-rest reduction for multiclass classification. Be aware that\n      the memory usage of this solver has a quadratic dependency on\n      `n_features` because it explicitly computes the Hessian matrix.\n\n.. warning::\n   The choice of the algorithm depends on the penalty chosen.\n   Supported penalties by solver:\n\n   - 'lbfgs'           -   ['l2']\n   - 'liblinear'       -   ['l1', 'l2']\n   - 'newton-cg'       -   ['l2']\n   - 'newton-cholesky' -   ['l2']\n   - 'sag'             -   ['l2']\n   - 'saga'            -   ['elasticnet', 'l1', 'l2']\n\n.. note::\n   'sag' and 'saga' fast convergence is only guaranteed on features\n   with approximately the same scale. You can preprocess the data with\n   a scaler from :mod:`sklearn.preprocessing`.\n\n.. versionadded:: 0.17\n   Stochastic Average Gradient descent solver.\n.. versionadded:: 0.19\n   SAGA solver.\n.. versionadded:: 1.2\n   newton-cholesky solver."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "newton-cholesky",
              "saga",
              "liblinear",
              "newton-cg",
              "lbfgs",
              "sag"
            ]
          }
        },
        "hasCondition": {
          "condition": "when solver equals sag , saga or liblinear to shuffle the data"
        },
        "hasAction": {
          "action": "Used"
        }
      }
    ],
    "l1_ratios": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._logistic/LogisticRegressionCV/__init__/l1_ratios",
          "name": "l1_ratios",
          "qname": "sklearn.linear_model._logistic.LogisticRegressionCV.__init__.l1_ratios",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "list of float",
            "default_value": "None",
            "description": "The list of Elastic-Net mixing parameter, with ``0 <= l1_ratio <= 1``.\nOnly used if ``penalty='elasticnet'``. A value of 0 is equivalent to\nusing ``penalty='l2'``, while 1 is equivalent to using\n``penalty='l1'``. For ``0 < l1_ratio <1``, the penalty is a combination\nof L1 and L2."
          },
          "type": {
            "kind": "NamedType",
            "name": "list of float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._logistic/LogisticRegressionCV/__init__/penalty",
          "name": "penalty",
          "qname": "sklearn.linear_model._logistic.LogisticRegressionCV.__init__.penalty",
          "default_value": "'l2'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'l1', 'l2', 'elasticnet'}",
            "default_value": "'l2'",
            "description": "Specify the norm of the penalty:\n\n- `'l2'`: add a L2 penalty term (used by default);\n- `'l1'`: add a L1 penalty term;\n- `'elasticnet'`: both L1 and L2 penalty terms are added.\n\n.. warning::\n   Some penalties may not work with some solvers. See the parameter\n   `solver` below, to know the compatibility between the penalty and\n   solver."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "elasticnet",
              "l1",
              "l2"
            ]
          }
        },
        "hasCondition": {
          "condition": "if penalty equals elasticnet"
        },
        "hasAction": {
          "action": "Only used"
        }
      }
    ]
  },
  "sklearn/sklearn.linear_model._logistic/LogisticRegressionCV/fit": {},
  "sklearn/sklearn.linear_model._logistic/LogisticRegressionCV/score": {},
  "sklearn/sklearn.linear_model._logistic/LogisticRegressionCV/_more_tags": {},
  "sklearn/sklearn.linear_model._omp/_cholesky_omp": {},
  "sklearn/sklearn.linear_model._omp/_gram_omp": {
    "tol_0": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._omp/_gram_omp/tol_0",
          "name": "tol_0",
          "qname": "sklearn.linear_model._omp._gram_omp.tol_0",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "float",
            "default_value": "None",
            "description": "Squared norm of y, required if tol is not None."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._omp/_gram_omp/tol",
          "name": "tol",
          "qname": "sklearn.linear_model._omp._gram_omp.tol",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "float",
            "default_value": "None",
            "description": "Targeted squared error, if not None overrides n_nonzero_coefs."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "hasCondition": {
          "condition": "if tol is not None"
        },
        "hasAction": {
          "action": "required"
        }
      }
    ]
  },
  "sklearn/sklearn.linear_model._omp/orthogonal_mp": {},
  "sklearn/sklearn.linear_model._omp/orthogonal_mp_gram": {},
  "sklearn/sklearn.linear_model._omp/OrthogonalMatchingPursuit/__init__": {
    "normalize": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._omp/OrthogonalMatchingPursuit/__init__/normalize",
          "name": "normalize",
          "qname": "sklearn.linear_model._omp.OrthogonalMatchingPursuit.__init__.normalize",
          "default_value": "'deprecated'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "This parameter is ignored when ``fit_intercept`` is set to False.\nIf True, the regressors X will be normalized before regression by\nsubtracting the mean and dividing by the l2-norm.\nIf you wish to standardize, please use\n:class:`~sklearn.preprocessing.StandardScaler` before calling ``fit``\non an estimator with ``normalize=False``.\n\n.. versionchanged:: 1.2\n   default changed from True to False in 1.2.\n\n.. deprecated:: 1.2\n    ``normalize`` was deprecated in version 1.2 and will be removed in 1.4."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._omp/OrthogonalMatchingPursuit/__init__/fit_intercept",
          "name": "fit_intercept",
          "qname": "sklearn.linear_model._omp.OrthogonalMatchingPursuit.__init__.fit_intercept",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Whether to calculate the intercept for this model. If set\nto false, no intercept will be used in calculations\n(i.e. data is expected to be centered)."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "when fit_intercept is set to False"
        },
        "hasAction": {
          "action": "This parameter is ignored"
        }
      }
    ]
  },
  "sklearn/sklearn.linear_model._omp/OrthogonalMatchingPursuit/fit": {},
  "sklearn/sklearn.linear_model._omp/_omp_path_residues": {
    "normalize": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._omp/_omp_path_residues/normalize",
          "name": "normalize",
          "qname": "sklearn.linear_model._omp._omp_path_residues.normalize",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "This parameter is ignored when ``fit_intercept`` is set to False.\nIf True, the regressors X will be normalized before regression by\nsubtracting the mean and dividing by the l2-norm.\nIf you wish to standardize, please use\n:class:`~sklearn.preprocessing.StandardScaler` before calling ``fit``\non an estimator with ``normalize=False``.\n\n.. versionchanged:: 1.2\n   default changed from True to False in 1.2.\n\n.. deprecated:: 1.2\n    ``normalize`` was deprecated in version 1.2 and will be removed in 1.4."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._omp/_omp_path_residues/fit_intercept",
          "name": "fit_intercept",
          "qname": "sklearn.linear_model._omp._omp_path_residues.fit_intercept",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Whether to calculate the intercept for this model. If set\nto false, no intercept will be used in calculations\n(i.e. data is expected to be centered)."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "when fit_intercept is set to False"
        },
        "hasAction": {
          "action": "This parameter is ignored"
        }
      }
    ]
  },
  "sklearn/sklearn.linear_model._omp/OrthogonalMatchingPursuitCV/__init__": {
    "normalize": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._omp/OrthogonalMatchingPursuitCV/__init__/normalize",
          "name": "normalize",
          "qname": "sklearn.linear_model._omp.OrthogonalMatchingPursuitCV.__init__.normalize",
          "default_value": "'deprecated'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "This parameter is ignored when ``fit_intercept`` is set to False.\nIf True, the regressors X will be normalized before regression by\nsubtracting the mean and dividing by the l2-norm.\nIf you wish to standardize, please use\n:class:`~sklearn.preprocessing.StandardScaler` before calling ``fit``\non an estimator with ``normalize=False``.\n\n.. versionchanged:: 1.2\n   default changed from True to False in 1.2.\n\n.. deprecated:: 1.2\n    ``normalize`` was deprecated in version 1.2 and will be removed in 1.4."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._omp/OrthogonalMatchingPursuitCV/__init__/fit_intercept",
          "name": "fit_intercept",
          "qname": "sklearn.linear_model._omp.OrthogonalMatchingPursuitCV.__init__.fit_intercept",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Whether to calculate the intercept for this model. If set\nto false, no intercept will be used in calculations\n(i.e. data is expected to be centered)."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "when fit_intercept is set to False"
        },
        "hasAction": {
          "action": "This parameter is ignored"
        }
      }
    ]
  },
  "sklearn/sklearn.linear_model._omp/OrthogonalMatchingPursuitCV/fit": {},
  "sklearn/sklearn.linear_model._passive_aggressive/PassiveAggressiveClassifier/__init__": {
    "validation_fraction": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._passive_aggressive/PassiveAggressiveClassifier/__init__/validation_fraction",
          "name": "validation_fraction",
          "qname": "sklearn.linear_model._passive_aggressive.PassiveAggressiveClassifier.__init__.validation_fraction",
          "default_value": "0.1",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "0.1",
            "description": "The proportion of training data to set aside as validation set for\nearly stopping. Must be between 0 and 1.\nOnly used if early_stopping is True.\n\n.. versionadded:: 0.20"
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._passive_aggressive/PassiveAggressiveClassifier/__init__/early_stopping",
          "name": "early_stopping",
          "qname": "sklearn.linear_model._passive_aggressive.PassiveAggressiveClassifier.__init__.early_stopping",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "Whether to use early stopping to terminate training when validation.\nscore is not improving. If set to True, it will automatically set aside\na stratified fraction of training data as validation and terminate\ntraining when validation score is not improving by at least tol for\nn_iter_no_change consecutive epochs.\n\n.. versionadded:: 0.20"
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "if early_stopping is True"
        },
        "hasAction": {
          "action": "Only used"
        }
      }
    ],
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._passive_aggressive/PassiveAggressiveClassifier/__init__/random_state",
          "name": "random_state",
          "qname": "sklearn.linear_model._passive_aggressive.PassiveAggressiveClassifier.__init__.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance",
            "default_value": "None",
            "description": "Used to shuffle the training data, when ``shuffle`` is set to\n``True``. Pass an int for reproducible output across multiple\nfunction calls.\nSee :term:`Glossary <random_state>`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._passive_aggressive/PassiveAggressiveClassifier/__init__/shuffle",
          "name": "shuffle",
          "qname": "sklearn.linear_model._passive_aggressive.PassiveAggressiveClassifier.__init__.shuffle",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Whether or not the training data should be shuffled after each epoch."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "when shuffle is set to True"
        },
        "hasAction": {
          "action": "Used to shuffle the training data ,"
        }
      }
    ],
    "warm_start": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._passive_aggressive/PassiveAggressiveClassifier/__init__/warm_start",
          "name": "warm_start",
          "qname": "sklearn.linear_model._passive_aggressive.PassiveAggressiveClassifier.__init__.warm_start",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "When set to True, reuse the solution of the previous call to fit as\ninitialization, otherwise, just erase the previous solution.\nSee :term:`the Glossary <warm_start>`.\n\nRepeatedly calling fit or partial_fit when warm_start is True can\nresult in a different solution than when calling fit a single time\nbecause of the way the data is shuffled."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._passive_aggressive/PassiveAggressiveClassifier/__init__/warm_start",
          "name": "warm_start",
          "qname": "sklearn.linear_model._passive_aggressive.PassiveAggressiveClassifier.__init__.warm_start",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "When set to True, reuse the solution of the previous call to fit as\ninitialization, otherwise, just erase the previous solution.\nSee :term:`the Glossary <warm_start>`.\n\nRepeatedly calling fit or partial_fit when warm_start is True can\nresult in a different solution than when calling fit a single time\nbecause of the way the data is shuffled."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "when warm_start is True"
        },
        "hasAction": {
          "action": "Repeatedly calling fit or partial_fit"
        }
      }
    ]
  },
  "sklearn/sklearn.linear_model._passive_aggressive/PassiveAggressiveClassifier/partial_fit": {},
  "sklearn/sklearn.linear_model._passive_aggressive/PassiveAggressiveClassifier/fit": {},
  "sklearn/sklearn.linear_model._passive_aggressive/PassiveAggressiveRegressor/__init__": {
    "validation_fraction": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._passive_aggressive/PassiveAggressiveRegressor/__init__/validation_fraction",
          "name": "validation_fraction",
          "qname": "sklearn.linear_model._passive_aggressive.PassiveAggressiveRegressor.__init__.validation_fraction",
          "default_value": "0.1",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "0.1",
            "description": "The proportion of training data to set aside as validation set for\nearly stopping. Must be between 0 and 1.\nOnly used if early_stopping is True.\n\n.. versionadded:: 0.20"
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._passive_aggressive/PassiveAggressiveRegressor/__init__/early_stopping",
          "name": "early_stopping",
          "qname": "sklearn.linear_model._passive_aggressive.PassiveAggressiveRegressor.__init__.early_stopping",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "Whether to use early stopping to terminate training when validation.\nscore is not improving. If set to True, it will automatically set aside\na fraction of training data as validation and terminate\ntraining when validation score is not improving by at least tol for\nn_iter_no_change consecutive epochs.\n\n.. versionadded:: 0.20"
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "if early_stopping is True"
        },
        "hasAction": {
          "action": "Only used"
        }
      }
    ],
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._passive_aggressive/PassiveAggressiveRegressor/__init__/random_state",
          "name": "random_state",
          "qname": "sklearn.linear_model._passive_aggressive.PassiveAggressiveRegressor.__init__.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance",
            "default_value": "None",
            "description": "Used to shuffle the training data, when ``shuffle`` is set to\n``True``. Pass an int for reproducible output across multiple\nfunction calls.\nSee :term:`Glossary <random_state>`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._passive_aggressive/PassiveAggressiveRegressor/__init__/shuffle",
          "name": "shuffle",
          "qname": "sklearn.linear_model._passive_aggressive.PassiveAggressiveRegressor.__init__.shuffle",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Whether or not the training data should be shuffled after each epoch."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "when shuffle is set to True"
        },
        "hasAction": {
          "action": "Used to shuffle the training data ,"
        }
      }
    ],
    "warm_start": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._passive_aggressive/PassiveAggressiveRegressor/__init__/warm_start",
          "name": "warm_start",
          "qname": "sklearn.linear_model._passive_aggressive.PassiveAggressiveRegressor.__init__.warm_start",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "When set to True, reuse the solution of the previous call to fit as\ninitialization, otherwise, just erase the previous solution.\nSee :term:`the Glossary <warm_start>`.\n\nRepeatedly calling fit or partial_fit when warm_start is True can\nresult in a different solution than when calling fit a single time\nbecause of the way the data is shuffled."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._passive_aggressive/PassiveAggressiveRegressor/__init__/warm_start",
          "name": "warm_start",
          "qname": "sklearn.linear_model._passive_aggressive.PassiveAggressiveRegressor.__init__.warm_start",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "When set to True, reuse the solution of the previous call to fit as\ninitialization, otherwise, just erase the previous solution.\nSee :term:`the Glossary <warm_start>`.\n\nRepeatedly calling fit or partial_fit when warm_start is True can\nresult in a different solution than when calling fit a single time\nbecause of the way the data is shuffled."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "when warm_start is True"
        },
        "hasAction": {
          "action": "Repeatedly calling fit or partial_fit"
        }
      }
    ]
  },
  "sklearn/sklearn.linear_model._passive_aggressive/PassiveAggressiveRegressor/partial_fit": {},
  "sklearn/sklearn.linear_model._passive_aggressive/PassiveAggressiveRegressor/fit": {},
  "sklearn/sklearn.linear_model._perceptron/Perceptron/__init__": {
    "l1_ratio": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._perceptron/Perceptron/__init__/l1_ratio",
          "name": "l1_ratio",
          "qname": "sklearn.linear_model._perceptron.Perceptron.__init__.l1_ratio",
          "default_value": "0.15",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "0.15",
            "description": "The Elastic Net mixing parameter, with `0 <= l1_ratio <= 1`.\n`l1_ratio=0` corresponds to L2 penalty, `l1_ratio=1` to L1.\nOnly used if `penalty='elasticnet'`.\n\n.. versionadded:: 0.24"
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._perceptron/Perceptron/__init__/penalty",
          "name": "penalty",
          "qname": "sklearn.linear_model._perceptron.Perceptron.__init__.penalty",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'l2','l1','elasticnet'}",
            "default_value": "None",
            "description": "The penalty (aka regularization term) to be used."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "elasticnet",
              "l1",
              "l2"
            ]
          }
        },
        "hasCondition": {
          "condition": "if penalty equals elasticnet"
        },
        "hasAction": {
          "action": "Only used"
        }
      }
    ],
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._perceptron/Perceptron/__init__/random_state",
          "name": "random_state",
          "qname": "sklearn.linear_model._perceptron.Perceptron.__init__.random_state",
          "default_value": "0",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance or None",
            "default_value": "0",
            "description": "Used to shuffle the training data, when ``shuffle`` is set to\n``True``. Pass an int for reproducible output across multiple\nfunction calls.\nSee :term:`Glossary <random_state>`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._perceptron/Perceptron/__init__/shuffle",
          "name": "shuffle",
          "qname": "sklearn.linear_model._perceptron.Perceptron.__init__.shuffle",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Whether or not the training data should be shuffled after each epoch."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "when shuffle is set to True"
        },
        "hasAction": {
          "action": "Used to shuffle the training data ,"
        }
      }
    ],
    "validation_fraction": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._perceptron/Perceptron/__init__/validation_fraction",
          "name": "validation_fraction",
          "qname": "sklearn.linear_model._perceptron.Perceptron.__init__.validation_fraction",
          "default_value": "0.1",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "0.1",
            "description": "The proportion of training data to set aside as validation set for\nearly stopping. Must be between 0 and 1.\nOnly used if early_stopping is True.\n\n.. versionadded:: 0.20"
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._perceptron/Perceptron/__init__/early_stopping",
          "name": "early_stopping",
          "qname": "sklearn.linear_model._perceptron.Perceptron.__init__.early_stopping",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "Whether to use early stopping to terminate training when validation.\nscore is not improving. If set to True, it will automatically set aside\na stratified fraction of training data as validation and terminate\ntraining when validation score is not improving by at least tol for\nn_iter_no_change consecutive epochs.\n\n.. versionadded:: 0.20"
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "if early_stopping is True"
        },
        "hasAction": {
          "action": "Only used"
        }
      }
    ]
  },
  "sklearn/sklearn.linear_model._quantile/QuantileRegressor/__init__": {},
  "sklearn/sklearn.linear_model._quantile/QuantileRegressor/fit": {},
  "sklearn/sklearn.linear_model._ransac/_dynamic_max_trials": {},
  "sklearn/sklearn.linear_model._ransac/RANSACRegressor/__init__": {
    "loss": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._ransac/RANSACRegressor/__init__/loss",
          "name": "loss",
          "qname": "sklearn.linear_model._ransac.RANSACRegressor.__init__.loss",
          "default_value": "'absolute_error'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str, callable",
            "default_value": "'absolute_error'",
            "description": "String inputs, 'absolute_error' and 'squared_error' are supported which\nfind the absolute error and squared error per sample respectively.\n\nIf ``loss`` is a callable, then it should be a function that takes\ntwo arrays as inputs, the true and predicted value and returns a 1-D\narray with the i-th value of the array corresponding to the loss\non ``X[i]``.\n\nIf the loss on a sample is greater than the ``residual_threshold``,\nthen this sample is classified as an outlier.\n\n.. versionadded:: 0.18"
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._ransac/RANSACRegressor/__init__/loss",
          "name": "loss",
          "qname": "sklearn.linear_model._ransac.RANSACRegressor.__init__.loss",
          "default_value": "'absolute_error'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str, callable",
            "default_value": "'absolute_error'",
            "description": "String inputs, 'absolute_error' and 'squared_error' are supported which\nfind the absolute error and squared error per sample respectively.\n\nIf ``loss`` is a callable, then it should be a function that takes\ntwo arrays as inputs, the true and predicted value and returns a 1-D\narray with the i-th value of the array corresponding to the loss\non ``X[i]``.\n\nIf the loss on a sample is greater than the ``residual_threshold``,\nthen this sample is classified as an outlier.\n\n.. versionadded:: 0.18"
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If the loss on a sample is greater than the residual_threshold"
        },
        "hasAction": {
          "action": ", then this sample is classified as an outlier"
        }
      }
    ]
  },
  "sklearn/sklearn.linear_model._ransac/RANSACRegressor/fit": {
    "sample_weight": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._ransac/RANSACRegressor/fit/sample_weight",
          "name": "sample_weight",
          "qname": "sklearn.linear_model._ransac.RANSACRegressor.fit.sample_weight",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of shape (n_samples,)",
            "default_value": "None",
            "description": "Individual weights for each sample\nraises error if sample_weight is passed and estimator\nfit method does not support it.\n\n.. versionadded:: 0.18"
          },
          "type": {
            "kind": "NamedType",
            "name": "array-like of shape (n_samples,)"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._ransac/RANSACRegressor/fit/sample_weight",
          "name": "sample_weight",
          "qname": "sklearn.linear_model._ransac.RANSACRegressor.fit.sample_weight",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of shape (n_samples,)",
            "default_value": "None",
            "description": "Individual weights for each sample\nraises error if sample_weight is passed and estimator\nfit method does not support it.\n\n.. versionadded:: 0.18"
          },
          "type": {
            "kind": "NamedType",
            "name": "array-like of shape (n_samples,)"
          }
        },
        "hasCondition": {
          "condition": "if sample_weight is passed and estimator fit method does not support it ."
        },
        "hasAction": {
          "action": "Individual weights for each sample raises error"
        }
      }
    ]
  },
  "sklearn/sklearn.linear_model._ransac/RANSACRegressor/predict": {},
  "sklearn/sklearn.linear_model._ransac/RANSACRegressor/score": {},
  "sklearn/sklearn.linear_model._ransac/RANSACRegressor/_more_tags": {},
  "sklearn/sklearn.linear_model._ridge/_get_rescaled_operator": {},
  "sklearn/sklearn.linear_model._ridge/_solve_sparse_cg": {},
  "sklearn/sklearn.linear_model._ridge/_solve_lsqr": {},
  "sklearn/sklearn.linear_model._ridge/_solve_cholesky": {},
  "sklearn/sklearn.linear_model._ridge/_solve_cholesky_kernel": {},
  "sklearn/sklearn.linear_model._ridge/_solve_svd": {},
  "sklearn/sklearn.linear_model._ridge/_solve_lbfgs": {},
  "sklearn/sklearn.linear_model._ridge/_get_valid_accept_sparse": {},
  "sklearn/sklearn.linear_model._ridge/ridge_regression": {
    "sample_weight": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._ridge/ridge_regression/sample_weight",
          "name": "sample_weight",
          "qname": "sklearn.linear_model._ridge.ridge_regression.sample_weight",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float or array-like of shape (n_samples,)",
            "default_value": "None",
            "description": "Individual weights for each sample. If given a float, every sample\nwill have the same weight. If sample_weight is not None and\nsolver='auto', the solver will be set to 'cholesky'.\n\n.. versionadded:: 0.17"
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "float"
              },
              {
                "kind": "NamedType",
                "name": "array-like of shape (n_samples,)"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._ridge/ridge_regression/sample_weight",
          "name": "sample_weight",
          "qname": "sklearn.linear_model._ridge.ridge_regression.sample_weight",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float or array-like of shape (n_samples,)",
            "default_value": "None",
            "description": "Individual weights for each sample. If given a float, every sample\nwill have the same weight. If sample_weight is not None and\nsolver='auto', the solver will be set to 'cholesky'.\n\n.. versionadded:: 0.17"
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "float"
              },
              {
                "kind": "NamedType",
                "name": "array-like of shape (n_samples,)"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If sample_weight is not None and solver equals auto"
        },
        "hasAction": {
          "action": ", the solver will be set to cholesky"
        }
      }
    ],
    "solver": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._ridge/ridge_regression/solver",
          "name": "solver",
          "qname": "sklearn.linear_model._ridge.ridge_regression.solver",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'auto', 'svd', 'cholesky', 'lsqr', 'sparse_cg',             'sag', 'saga', 'lbfgs'}",
            "default_value": "'auto'",
            "description": "Solver to use in the computational routines:\n\n- 'auto' chooses the solver automatically based on the type of data.\n\n- 'svd' uses a Singular Value Decomposition of X to compute the Ridge\n  coefficients. It is the most stable solver, in particular more stable\n  for singular matrices than 'cholesky' at the cost of being slower.\n\n- 'cholesky' uses the standard scipy.linalg.solve function to\n  obtain a closed-form solution via a Cholesky decomposition of\n  dot(X.T, X)\n\n- 'sparse_cg' uses the conjugate gradient solver as found in\n  scipy.sparse.linalg.cg. As an iterative algorithm, this solver is\n  more appropriate than 'cholesky' for large-scale data\n  (possibility to set `tol` and `max_iter`).\n\n- 'lsqr' uses the dedicated regularized least-squares routine\n  scipy.sparse.linalg.lsqr. It is the fastest and uses an iterative\n  procedure.\n\n- 'sag' uses a Stochastic Average Gradient descent, and 'saga' uses\n  its improved, unbiased version named SAGA. Both methods also use an\n  iterative procedure, and are often faster than other solvers when\n  both n_samples and n_features are large. Note that 'sag' and\n  'saga' fast convergence is only guaranteed on features with\n  approximately the same scale. You can preprocess the data with a\n  scaler from sklearn.preprocessing.\n\n- 'lbfgs' uses L-BFGS-B algorithm implemented in\n  `scipy.optimize.minimize`. It can be used only when `positive`\n  is True.\n\nAll solvers except 'svd' support both dense and sparse data. However, only\n'lsqr', 'sag', 'sparse_cg', and 'lbfgs' support sparse input when\n`fit_intercept` is True.\n\n.. versionadded:: 0.17\n   Stochastic Average Gradient descent solver.\n.. versionadded:: 0.19\n   SAGA solver."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "saga",
              "auto",
              "lbfgs",
              "svd",
              "sparse_cg",
              "lsqr",
              "cholesky",
              "sag"
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._ridge/ridge_regression/positive",
          "name": "positive",
          "qname": "sklearn.linear_model._ridge.ridge_regression.positive",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "When set to ``True``, forces the coefficients to be positive.\nOnly 'lbfgs' solver is supported in this case."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "only when positive is True"
        },
        "hasAction": {
          "action": "It can be used"
        }
      }
    ],
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._ridge/ridge_regression/random_state",
          "name": "random_state",
          "qname": "sklearn.linear_model._ridge.ridge_regression.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance",
            "default_value": "None",
            "description": "Used when ``solver`` == 'sag' or 'saga' to shuffle the data.\nSee :term:`Glossary <random_state>` for details."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._ridge/ridge_regression/solver",
          "name": "solver",
          "qname": "sklearn.linear_model._ridge.ridge_regression.solver",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'auto', 'svd', 'cholesky', 'lsqr', 'sparse_cg',             'sag', 'saga', 'lbfgs'}",
            "default_value": "'auto'",
            "description": "Solver to use in the computational routines:\n\n- 'auto' chooses the solver automatically based on the type of data.\n\n- 'svd' uses a Singular Value Decomposition of X to compute the Ridge\n  coefficients. It is the most stable solver, in particular more stable\n  for singular matrices than 'cholesky' at the cost of being slower.\n\n- 'cholesky' uses the standard scipy.linalg.solve function to\n  obtain a closed-form solution via a Cholesky decomposition of\n  dot(X.T, X)\n\n- 'sparse_cg' uses the conjugate gradient solver as found in\n  scipy.sparse.linalg.cg. As an iterative algorithm, this solver is\n  more appropriate than 'cholesky' for large-scale data\n  (possibility to set `tol` and `max_iter`).\n\n- 'lsqr' uses the dedicated regularized least-squares routine\n  scipy.sparse.linalg.lsqr. It is the fastest and uses an iterative\n  procedure.\n\n- 'sag' uses a Stochastic Average Gradient descent, and 'saga' uses\n  its improved, unbiased version named SAGA. Both methods also use an\n  iterative procedure, and are often faster than other solvers when\n  both n_samples and n_features are large. Note that 'sag' and\n  'saga' fast convergence is only guaranteed on features with\n  approximately the same scale. You can preprocess the data with a\n  scaler from sklearn.preprocessing.\n\n- 'lbfgs' uses L-BFGS-B algorithm implemented in\n  `scipy.optimize.minimize`. It can be used only when `positive`\n  is True.\n\nAll solvers except 'svd' support both dense and sparse data. However, only\n'lsqr', 'sag', 'sparse_cg', and 'lbfgs' support sparse input when\n`fit_intercept` is True.\n\n.. versionadded:: 0.17\n   Stochastic Average Gradient descent solver.\n.. versionadded:: 0.19\n   SAGA solver."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "saga",
              "auto",
              "lbfgs",
              "svd",
              "sparse_cg",
              "lsqr",
              "cholesky",
              "sag"
            ]
          }
        },
        "hasCondition": {
          "condition": "when solver equals sag or saga to shuffle the data"
        },
        "hasAction": {
          "action": "Used"
        }
      }
    ]
  },
  "sklearn/sklearn.linear_model._ridge/_ridge_regression": {},
  "sklearn/sklearn.linear_model._ridge/_BaseRidge/__init__": {},
  "sklearn/sklearn.linear_model._ridge/_BaseRidge/fit": {},
  "sklearn/sklearn.linear_model._ridge/Ridge/__init__": {
    "solver": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._ridge/Ridge/__init__/solver",
          "name": "solver",
          "qname": "sklearn.linear_model._ridge.Ridge.__init__.solver",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'auto', 'svd', 'cholesky', 'lsqr', 'sparse_cg',             'sag', 'saga', 'lbfgs'}",
            "default_value": "'auto'",
            "description": "Solver to use in the computational routines:\n\n- 'auto' chooses the solver automatically based on the type of data.\n\n- 'svd' uses a Singular Value Decomposition of X to compute the Ridge\n  coefficients. It is the most stable solver, in particular more stable\n  for singular matrices than 'cholesky' at the cost of being slower.\n\n- 'cholesky' uses the standard scipy.linalg.solve function to\n  obtain a closed-form solution.\n\n- 'sparse_cg' uses the conjugate gradient solver as found in\n  scipy.sparse.linalg.cg. As an iterative algorithm, this solver is\n  more appropriate than 'cholesky' for large-scale data\n  (possibility to set `tol` and `max_iter`).\n\n- 'lsqr' uses the dedicated regularized least-squares routine\n  scipy.sparse.linalg.lsqr. It is the fastest and uses an iterative\n  procedure.\n\n- 'sag' uses a Stochastic Average Gradient descent, and 'saga' uses\n  its improved, unbiased version named SAGA. Both methods also use an\n  iterative procedure, and are often faster than other solvers when\n  both n_samples and n_features are large. Note that 'sag' and\n  'saga' fast convergence is only guaranteed on features with\n  approximately the same scale. You can preprocess the data with a\n  scaler from sklearn.preprocessing.\n\n- 'lbfgs' uses L-BFGS-B algorithm implemented in\n  `scipy.optimize.minimize`. It can be used only when `positive`\n  is True.\n\nAll solvers except 'svd' support both dense and sparse data. However, only\n'lsqr', 'sag', 'sparse_cg', and 'lbfgs' support sparse input when\n`fit_intercept` is True.\n\n.. versionadded:: 0.17\n   Stochastic Average Gradient descent solver.\n.. versionadded:: 0.19\n   SAGA solver."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "saga",
              "auto",
              "lbfgs",
              "svd",
              "sparse_cg",
              "lsqr",
              "cholesky",
              "sag"
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._ridge/Ridge/__init__/positive",
          "name": "positive",
          "qname": "sklearn.linear_model._ridge.Ridge.__init__.positive",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "When set to ``True``, forces the coefficients to be positive.\nOnly 'lbfgs' solver is supported in this case."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "only when positive is True"
        },
        "hasAction": {
          "action": "It can be used"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._ridge/Ridge/__init__/solver",
          "name": "solver",
          "qname": "sklearn.linear_model._ridge.Ridge.__init__.solver",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'auto', 'svd', 'cholesky', 'lsqr', 'sparse_cg',             'sag', 'saga', 'lbfgs'}",
            "default_value": "'auto'",
            "description": "Solver to use in the computational routines:\n\n- 'auto' chooses the solver automatically based on the type of data.\n\n- 'svd' uses a Singular Value Decomposition of X to compute the Ridge\n  coefficients. It is the most stable solver, in particular more stable\n  for singular matrices than 'cholesky' at the cost of being slower.\n\n- 'cholesky' uses the standard scipy.linalg.solve function to\n  obtain a closed-form solution.\n\n- 'sparse_cg' uses the conjugate gradient solver as found in\n  scipy.sparse.linalg.cg. As an iterative algorithm, this solver is\n  more appropriate than 'cholesky' for large-scale data\n  (possibility to set `tol` and `max_iter`).\n\n- 'lsqr' uses the dedicated regularized least-squares routine\n  scipy.sparse.linalg.lsqr. It is the fastest and uses an iterative\n  procedure.\n\n- 'sag' uses a Stochastic Average Gradient descent, and 'saga' uses\n  its improved, unbiased version named SAGA. Both methods also use an\n  iterative procedure, and are often faster than other solvers when\n  both n_samples and n_features are large. Note that 'sag' and\n  'saga' fast convergence is only guaranteed on features with\n  approximately the same scale. You can preprocess the data with a\n  scaler from sklearn.preprocessing.\n\n- 'lbfgs' uses L-BFGS-B algorithm implemented in\n  `scipy.optimize.minimize`. It can be used only when `positive`\n  is True.\n\nAll solvers except 'svd' support both dense and sparse data. However, only\n'lsqr', 'sag', 'sparse_cg', and 'lbfgs' support sparse input when\n`fit_intercept` is True.\n\n.. versionadded:: 0.17\n   Stochastic Average Gradient descent solver.\n.. versionadded:: 0.19\n   SAGA solver."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "saga",
              "auto",
              "lbfgs",
              "svd",
              "sparse_cg",
              "lsqr",
              "cholesky",
              "sag"
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._ridge/Ridge/__init__/fit_intercept",
          "name": "fit_intercept",
          "qname": "sklearn.linear_model._ridge.Ridge.__init__.fit_intercept",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Whether to fit the intercept for this model. If set\nto false, no intercept will be used in calculations\n(i.e. ``X`` and ``y`` are expected to be centered)."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "when fit_intercept is True"
        },
        "hasAction": {
          "action": "lbfgs support sparse input"
        }
      }
    ],
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._ridge/Ridge/__init__/random_state",
          "name": "random_state",
          "qname": "sklearn.linear_model._ridge.Ridge.__init__.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance",
            "default_value": "None",
            "description": "Used when ``solver`` == 'sag' or 'saga' to shuffle the data.\nSee :term:`Glossary <random_state>` for details.\n\n.. versionadded:: 0.17\n   `random_state` to support Stochastic Average Gradient."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._ridge/Ridge/__init__/solver",
          "name": "solver",
          "qname": "sklearn.linear_model._ridge.Ridge.__init__.solver",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'auto', 'svd', 'cholesky', 'lsqr', 'sparse_cg',             'sag', 'saga', 'lbfgs'}",
            "default_value": "'auto'",
            "description": "Solver to use in the computational routines:\n\n- 'auto' chooses the solver automatically based on the type of data.\n\n- 'svd' uses a Singular Value Decomposition of X to compute the Ridge\n  coefficients. It is the most stable solver, in particular more stable\n  for singular matrices than 'cholesky' at the cost of being slower.\n\n- 'cholesky' uses the standard scipy.linalg.solve function to\n  obtain a closed-form solution.\n\n- 'sparse_cg' uses the conjugate gradient solver as found in\n  scipy.sparse.linalg.cg. As an iterative algorithm, this solver is\n  more appropriate than 'cholesky' for large-scale data\n  (possibility to set `tol` and `max_iter`).\n\n- 'lsqr' uses the dedicated regularized least-squares routine\n  scipy.sparse.linalg.lsqr. It is the fastest and uses an iterative\n  procedure.\n\n- 'sag' uses a Stochastic Average Gradient descent, and 'saga' uses\n  its improved, unbiased version named SAGA. Both methods also use an\n  iterative procedure, and are often faster than other solvers when\n  both n_samples and n_features are large. Note that 'sag' and\n  'saga' fast convergence is only guaranteed on features with\n  approximately the same scale. You can preprocess the data with a\n  scaler from sklearn.preprocessing.\n\n- 'lbfgs' uses L-BFGS-B algorithm implemented in\n  `scipy.optimize.minimize`. It can be used only when `positive`\n  is True.\n\nAll solvers except 'svd' support both dense and sparse data. However, only\n'lsqr', 'sag', 'sparse_cg', and 'lbfgs' support sparse input when\n`fit_intercept` is True.\n\n.. versionadded:: 0.17\n   Stochastic Average Gradient descent solver.\n.. versionadded:: 0.19\n   SAGA solver."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "saga",
              "auto",
              "lbfgs",
              "svd",
              "sparse_cg",
              "lsqr",
              "cholesky",
              "sag"
            ]
          }
        },
        "hasCondition": {
          "condition": "when solver equals sag or saga to shuffle the data"
        },
        "hasAction": {
          "action": "Used"
        }
      }
    ]
  },
  "sklearn/sklearn.linear_model._ridge/Ridge/fit": {},
  "sklearn/sklearn.linear_model._ridge/_RidgeClassifierMixin/_prepare_data": {},
  "sklearn/sklearn.linear_model._ridge/_RidgeClassifierMixin/predict": {},
  "sklearn/sklearn.linear_model._ridge/_RidgeClassifierMixin/classes_@getter": {},
  "sklearn/sklearn.linear_model._ridge/_RidgeClassifierMixin/_more_tags": {},
  "sklearn/sklearn.linear_model._ridge/RidgeClassifier/__init__": {
    "solver": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._ridge/RidgeClassifier/__init__/solver",
          "name": "solver",
          "qname": "sklearn.linear_model._ridge.RidgeClassifier.__init__.solver",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'auto', 'svd', 'cholesky', 'lsqr', 'sparse_cg',             'sag', 'saga', 'lbfgs'}",
            "default_value": "'auto'",
            "description": "Solver to use in the computational routines:\n\n- 'auto' chooses the solver automatically based on the type of data.\n\n- 'svd' uses a Singular Value Decomposition of X to compute the Ridge\n  coefficients. It is the most stable solver, in particular more stable\n  for singular matrices than 'cholesky' at the cost of being slower.\n\n- 'cholesky' uses the standard scipy.linalg.solve function to\n  obtain a closed-form solution.\n\n- 'sparse_cg' uses the conjugate gradient solver as found in\n  scipy.sparse.linalg.cg. As an iterative algorithm, this solver is\n  more appropriate than 'cholesky' for large-scale data\n  (possibility to set `tol` and `max_iter`).\n\n- 'lsqr' uses the dedicated regularized least-squares routine\n  scipy.sparse.linalg.lsqr. It is the fastest and uses an iterative\n  procedure.\n\n- 'sag' uses a Stochastic Average Gradient descent, and 'saga' uses\n  its unbiased and more flexible version named SAGA. Both methods\n  use an iterative procedure, and are often faster than other solvers\n  when both n_samples and n_features are large. Note that 'sag' and\n  'saga' fast convergence is only guaranteed on features with\n  approximately the same scale. You can preprocess the data with a\n  scaler from sklearn.preprocessing.\n\n  .. versionadded:: 0.17\n     Stochastic Average Gradient descent solver.\n  .. versionadded:: 0.19\n     SAGA solver.\n\n- 'lbfgs' uses L-BFGS-B algorithm implemented in\n  `scipy.optimize.minimize`. It can be used only when `positive`\n  is True."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "saga",
              "auto",
              "lbfgs",
              "svd",
              "sparse_cg",
              "lsqr",
              "cholesky",
              "sag"
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._ridge/RidgeClassifier/__init__/positive",
          "name": "positive",
          "qname": "sklearn.linear_model._ridge.RidgeClassifier.__init__.positive",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "When set to ``True``, forces the coefficients to be positive.\nOnly 'lbfgs' solver is supported in this case."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "only when positive is True"
        },
        "hasAction": {
          "action": "It can be used"
        }
      }
    ],
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._ridge/RidgeClassifier/__init__/random_state",
          "name": "random_state",
          "qname": "sklearn.linear_model._ridge.RidgeClassifier.__init__.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance",
            "default_value": "None",
            "description": "Used when ``solver`` == 'sag' or 'saga' to shuffle the data.\nSee :term:`Glossary <random_state>` for details."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._ridge/RidgeClassifier/__init__/solver",
          "name": "solver",
          "qname": "sklearn.linear_model._ridge.RidgeClassifier.__init__.solver",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'auto', 'svd', 'cholesky', 'lsqr', 'sparse_cg',             'sag', 'saga', 'lbfgs'}",
            "default_value": "'auto'",
            "description": "Solver to use in the computational routines:\n\n- 'auto' chooses the solver automatically based on the type of data.\n\n- 'svd' uses a Singular Value Decomposition of X to compute the Ridge\n  coefficients. It is the most stable solver, in particular more stable\n  for singular matrices than 'cholesky' at the cost of being slower.\n\n- 'cholesky' uses the standard scipy.linalg.solve function to\n  obtain a closed-form solution.\n\n- 'sparse_cg' uses the conjugate gradient solver as found in\n  scipy.sparse.linalg.cg. As an iterative algorithm, this solver is\n  more appropriate than 'cholesky' for large-scale data\n  (possibility to set `tol` and `max_iter`).\n\n- 'lsqr' uses the dedicated regularized least-squares routine\n  scipy.sparse.linalg.lsqr. It is the fastest and uses an iterative\n  procedure.\n\n- 'sag' uses a Stochastic Average Gradient descent, and 'saga' uses\n  its unbiased and more flexible version named SAGA. Both methods\n  use an iterative procedure, and are often faster than other solvers\n  when both n_samples and n_features are large. Note that 'sag' and\n  'saga' fast convergence is only guaranteed on features with\n  approximately the same scale. You can preprocess the data with a\n  scaler from sklearn.preprocessing.\n\n  .. versionadded:: 0.17\n     Stochastic Average Gradient descent solver.\n  .. versionadded:: 0.19\n     SAGA solver.\n\n- 'lbfgs' uses L-BFGS-B algorithm implemented in\n  `scipy.optimize.minimize`. It can be used only when `positive`\n  is True."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "saga",
              "auto",
              "lbfgs",
              "svd",
              "sparse_cg",
              "lsqr",
              "cholesky",
              "sag"
            ]
          }
        },
        "hasCondition": {
          "condition": "when solver equals sag or saga to shuffle the data"
        },
        "hasAction": {
          "action": "Used"
        }
      }
    ]
  },
  "sklearn/sklearn.linear_model._ridge/RidgeClassifier/fit": {},
  "sklearn/sklearn.linear_model._ridge/_check_gcv_mode": {},
  "sklearn/sklearn.linear_model._ridge/_find_smallest_angle": {},
  "sklearn/sklearn.linear_model._ridge/_X_CenterStackOp/__init__": {},
  "sklearn/sklearn.linear_model._ridge/_X_CenterStackOp/_matvec": {},
  "sklearn/sklearn.linear_model._ridge/_X_CenterStackOp/_matmat": {},
  "sklearn/sklearn.linear_model._ridge/_X_CenterStackOp/_transpose": {},
  "sklearn/sklearn.linear_model._ridge/_XT_CenterStackOp/__init__": {},
  "sklearn/sklearn.linear_model._ridge/_XT_CenterStackOp/_matvec": {},
  "sklearn/sklearn.linear_model._ridge/_XT_CenterStackOp/_matmat": {},
  "sklearn/sklearn.linear_model._ridge/_IdentityRegressor/decision_function": {},
  "sklearn/sklearn.linear_model._ridge/_IdentityRegressor/predict": {},
  "sklearn/sklearn.linear_model._ridge/_IdentityClassifier/__init__": {},
  "sklearn/sklearn.linear_model._ridge/_IdentityClassifier/decision_function": {},
  "sklearn/sklearn.linear_model._ridge/_RidgeGCV/__init__": {},
  "sklearn/sklearn.linear_model._ridge/_RidgeGCV/_decomp_diag": {},
  "sklearn/sklearn.linear_model._ridge/_RidgeGCV/_diag_dot": {},
  "sklearn/sklearn.linear_model._ridge/_RidgeGCV/_compute_gram": {},
  "sklearn/sklearn.linear_model._ridge/_RidgeGCV/_compute_covariance": {},
  "sklearn/sklearn.linear_model._ridge/_RidgeGCV/_sparse_multidot_diag": {},
  "sklearn/sklearn.linear_model._ridge/_RidgeGCV/_eigen_decompose_gram": {},
  "sklearn/sklearn.linear_model._ridge/_RidgeGCV/_solve_eigen_gram": {},
  "sklearn/sklearn.linear_model._ridge/_RidgeGCV/_eigen_decompose_covariance": {},
  "sklearn/sklearn.linear_model._ridge/_RidgeGCV/_solve_eigen_covariance_no_intercept": {},
  "sklearn/sklearn.linear_model._ridge/_RidgeGCV/_solve_eigen_covariance_intercept": {},
  "sklearn/sklearn.linear_model._ridge/_RidgeGCV/_solve_eigen_covariance": {},
  "sklearn/sklearn.linear_model._ridge/_RidgeGCV/_svd_decompose_design_matrix": {},
  "sklearn/sklearn.linear_model._ridge/_RidgeGCV/_solve_svd_design_matrix": {},
  "sklearn/sklearn.linear_model._ridge/_RidgeGCV/fit": {},
  "sklearn/sklearn.linear_model._ridge/_BaseRidgeCV/__init__": {},
  "sklearn/sklearn.linear_model._ridge/_BaseRidgeCV/fit": {},
  "sklearn/sklearn.linear_model._ridge/RidgeCV/fit": {},
  "sklearn/sklearn.linear_model._ridge/RidgeClassifierCV/__init__": {},
  "sklearn/sklearn.linear_model._ridge/RidgeClassifierCV/fit": {},
  "sklearn/sklearn.linear_model._ridge/RidgeClassifierCV/_more_tags": {},
  "sklearn/sklearn.linear_model._sag/get_auto_step_size": {},
  "sklearn/sklearn.linear_model._sag/sag_solver": {
    "y": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._sag/sag_solver/y",
          "name": "y",
          "qname": "sklearn.linear_model._sag.sag_solver.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "ndarray of shape (n_samples,)",
            "default_value": "",
            "description": "Target values. With loss='multinomial', y must be label encoded\n(see preprocessing.LabelEncoder)."
          },
          "type": {
            "kind": "NamedType",
            "name": "ndarray of shape (n_samples,)"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._sag/sag_solver/loss",
          "name": "loss",
          "qname": "sklearn.linear_model._sag.sag_solver.loss",
          "default_value": "'log'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "{'log', 'squared', 'multinomial'}",
            "default_value": "'log'",
            "description": "Loss function that will be optimized:\n-'log' is the binary logistic loss, as used in LogisticRegression.\n-'squared' is the squared loss, as used in Ridge.\n-'multinomial' is the multinomial logistic loss, as used in\n LogisticRegression.\n\n.. versionadded:: 0.18\n   *loss='multinomial'*"
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "log",
              "multinomial",
              "squared"
            ]
          }
        },
        "hasCondition": {
          "condition": "With loss equals multinomial"
        },
        "hasAction": {
          "action": ", y must be label encoded ( see preprocessing"
        }
      }
    ],
    "beta": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._sag/sag_solver/beta",
          "name": "beta",
          "qname": "sklearn.linear_model._sag.sag_solver.beta",
          "default_value": "0.0",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "float",
            "default_value": "0.",
            "description": "L1 regularization term in the objective function\n``(beta * || W ||_1)``. Only applied if ``is_saga`` is set to True."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._sag/sag_solver/is_saga",
          "name": "is_saga",
          "qname": "sklearn.linear_model._sag.sag_solver.is_saga",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "Whether to use the SAGA algorithm or the SAG algorithm. SAGA behaves\nbetter in the first epochs, and allow for l1 regularisation."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "if is_saga is set to True"
        },
        "hasAction": {
          "action": "Only applied"
        }
      }
    ]
  },
  "sklearn/sklearn.linear_model._stochastic_gradient/_ValidationScoreCallback/__init__": {},
  "sklearn/sklearn.linear_model._stochastic_gradient/_ValidationScoreCallback/__call__": {},
  "sklearn/sklearn.linear_model._stochastic_gradient/BaseSGD/__init__": {},
  "sklearn/sklearn.linear_model._stochastic_gradient/BaseSGD/fit": {},
  "sklearn/sklearn.linear_model._stochastic_gradient/BaseSGD/_more_validate_params": {},
  "sklearn/sklearn.linear_model._stochastic_gradient/BaseSGD/_get_loss_function": {},
  "sklearn/sklearn.linear_model._stochastic_gradient/BaseSGD/_get_learning_rate_type": {},
  "sklearn/sklearn.linear_model._stochastic_gradient/BaseSGD/_get_penalty_type": {},
  "sklearn/sklearn.linear_model._stochastic_gradient/BaseSGD/_allocate_parameter_mem": {},
  "sklearn/sklearn.linear_model._stochastic_gradient/BaseSGD/_make_validation_split": {},
  "sklearn/sklearn.linear_model._stochastic_gradient/BaseSGD/_make_validation_score_cb": {},
  "sklearn/sklearn.linear_model._stochastic_gradient/_prepare_fit_binary": {},
  "sklearn/sklearn.linear_model._stochastic_gradient/fit_binary": {},
  "sklearn/sklearn.linear_model._stochastic_gradient/BaseSGDClassifier/__init__": {},
  "sklearn/sklearn.linear_model._stochastic_gradient/BaseSGDClassifier/_partial_fit": {},
  "sklearn/sklearn.linear_model._stochastic_gradient/BaseSGDClassifier/_fit": {},
  "sklearn/sklearn.linear_model._stochastic_gradient/BaseSGDClassifier/_fit_binary": {},
  "sklearn/sklearn.linear_model._stochastic_gradient/BaseSGDClassifier/_fit_multiclass": {},
  "sklearn/sklearn.linear_model._stochastic_gradient/BaseSGDClassifier/partial_fit": {},
  "sklearn/sklearn.linear_model._stochastic_gradient/BaseSGDClassifier/fit": {},
  "sklearn/sklearn.linear_model._stochastic_gradient/SGDClassifier/__init__": {
    "l1_ratio": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._stochastic_gradient/SGDClassifier/__init__/l1_ratio",
          "name": "l1_ratio",
          "qname": "sklearn.linear_model._stochastic_gradient.SGDClassifier.__init__.l1_ratio",
          "default_value": "0.15",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "0.15",
            "description": "The Elastic Net mixing parameter, with 0 <= l1_ratio <= 1.\nl1_ratio=0 corresponds to L2 penalty, l1_ratio=1 to L1.\nOnly used if `penalty` is 'elasticnet'.\nValues must be in the range `[0.0, 1.0]`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "BoundaryType",
                "base_type": "float",
                "min": 0.0,
                "max": 1.0,
                "min_inclusive": true,
                "max_inclusive": true
              },
              {
                "kind": "NamedType",
                "name": "float"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._stochastic_gradient/SGDClassifier/__init__/penalty",
          "name": "penalty",
          "qname": "sklearn.linear_model._stochastic_gradient.SGDClassifier.__init__.penalty",
          "default_value": "'l2'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'l2', 'l1', 'elasticnet', None}",
            "default_value": "'l2'",
            "description": "The penalty (aka regularization term) to be used. Defaults to 'l2'\nwhich is the standard regularizer for linear SVM models. 'l1' and\n'elasticnet' might bring sparsity to the model (feature selection)\nnot achievable with 'l2'. No penalty is added when set to `None`."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "elasticnet",
              "l1",
              "l2"
            ]
          }
        },
        "hasCondition": {
          "condition": "if penalty is elasticnet"
        },
        "hasAction": {
          "action": "Only used"
        }
      }
    ],
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._stochastic_gradient/SGDClassifier/__init__/random_state",
          "name": "random_state",
          "qname": "sklearn.linear_model._stochastic_gradient.SGDClassifier.__init__.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance",
            "default_value": "None",
            "description": "Used for shuffling the data, when ``shuffle`` is set to ``True``.\nPass an int for reproducible output across multiple function calls.\nSee :term:`Glossary <random_state>`.\nInteger values must be in the range `[0, 2**32 - 1]`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._stochastic_gradient/SGDClassifier/__init__/shuffle",
          "name": "shuffle",
          "qname": "sklearn.linear_model._stochastic_gradient.SGDClassifier.__init__.shuffle",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Whether or not the training data should be shuffled after each epoch."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "when shuffle is set to True"
        },
        "hasAction": {
          "action": "Used for shuffling the data ,"
        }
      }
    ],
    "learning_rate": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._stochastic_gradient/SGDClassifier/__init__/learning_rate",
          "name": "learning_rate",
          "qname": "sklearn.linear_model._stochastic_gradient.SGDClassifier.__init__.learning_rate",
          "default_value": "'optimal'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "'optimal'",
            "description": "The learning rate schedule:\n\n- 'constant': `eta = eta0`\n- 'optimal': `eta = 1.0 / (alpha * (t + t0))`\n  where `t0` is chosen by a heuristic proposed by Leon Bottou.\n- 'invscaling': `eta = eta0 / pow(t, power_t)`\n- 'adaptive': `eta = eta0`, as long as the training keeps decreasing.\n  Each time n_iter_no_change consecutive epochs fail to decrease the\n  training loss by tol or fail to increase validation score by tol if\n  `early_stopping` is `True`, the current learning rate is divided by 5.\n\n    .. versionadded:: 0.20\n        Added 'adaptive' option"
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._stochastic_gradient/SGDClassifier/__init__/early_stopping",
          "name": "early_stopping",
          "qname": "sklearn.linear_model._stochastic_gradient.SGDClassifier.__init__.early_stopping",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "Whether to use early stopping to terminate training when validation\nscore is not improving. If set to `True`, it will automatically set aside\na stratified fraction of training data as validation and terminate\ntraining when validation score returned by the `score` method is not\nimproving by at least tol for n_iter_no_change consecutive epochs.\n\n.. versionadded:: 0.20\n    Added 'early_stopping' option"
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "if early_stopping is True"
        },
        "hasAction": {
          "action": "to increase validation score by tol"
        }
      }
    ],
    "validation_fraction": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._stochastic_gradient/SGDClassifier/__init__/validation_fraction",
          "name": "validation_fraction",
          "qname": "sklearn.linear_model._stochastic_gradient.SGDClassifier.__init__.validation_fraction",
          "default_value": "0.1",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "0.1",
            "description": "The proportion of training data to set aside as validation set for\nearly stopping. Must be between 0 and 1.\nOnly used if `early_stopping` is True.\nValues must be in the range `(0.0, 1.0)`.\n\n.. versionadded:: 0.20\n    Added 'validation_fraction' option"
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "BoundaryType",
                "base_type": "float",
                "min": 0.0,
                "max": 1.0,
                "min_inclusive": false,
                "max_inclusive": false
              },
              {
                "kind": "NamedType",
                "name": "float"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._stochastic_gradient/SGDClassifier/__init__/early_stopping",
          "name": "early_stopping",
          "qname": "sklearn.linear_model._stochastic_gradient.SGDClassifier.__init__.early_stopping",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "Whether to use early stopping to terminate training when validation\nscore is not improving. If set to `True`, it will automatically set aside\na stratified fraction of training data as validation and terminate\ntraining when validation score returned by the `score` method is not\nimproving by at least tol for n_iter_no_change consecutive epochs.\n\n.. versionadded:: 0.20\n    Added 'early_stopping' option"
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "if early_stopping is True"
        },
        "hasAction": {
          "action": "Only used"
        }
      }
    ],
    "warm_start": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._stochastic_gradient/SGDClassifier/__init__/warm_start",
          "name": "warm_start",
          "qname": "sklearn.linear_model._stochastic_gradient.SGDClassifier.__init__.warm_start",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "When set to True, reuse the solution of the previous call to fit as\ninitialization, otherwise, just erase the previous solution.\nSee :term:`the Glossary <warm_start>`.\n\nRepeatedly calling fit or partial_fit when warm_start is True can\nresult in a different solution than when calling fit a single time\nbecause of the way the data is shuffled.\nIf a dynamic learning rate is used, the learning rate is adapted\ndepending on the number of samples already seen. Calling ``fit`` resets\nthis counter, while ``partial_fit`` will result in increasing the\nexisting counter."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._stochastic_gradient/SGDClassifier/__init__/warm_start",
          "name": "warm_start",
          "qname": "sklearn.linear_model._stochastic_gradient.SGDClassifier.__init__.warm_start",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "When set to True, reuse the solution of the previous call to fit as\ninitialization, otherwise, just erase the previous solution.\nSee :term:`the Glossary <warm_start>`.\n\nRepeatedly calling fit or partial_fit when warm_start is True can\nresult in a different solution than when calling fit a single time\nbecause of the way the data is shuffled.\nIf a dynamic learning rate is used, the learning rate is adapted\ndepending on the number of samples already seen. Calling ``fit`` resets\nthis counter, while ``partial_fit`` will result in increasing the\nexisting counter."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "when warm_start is True"
        },
        "hasAction": {
          "action": "Repeatedly calling fit or partial_fit"
        }
      }
    ]
  },
  "sklearn/sklearn.linear_model._stochastic_gradient/SGDClassifier/_check_proba": {},
  "sklearn/sklearn.linear_model._stochastic_gradient/SGDClassifier/predict_proba": {},
  "sklearn/sklearn.linear_model._stochastic_gradient/SGDClassifier/predict_log_proba": {},
  "sklearn/sklearn.linear_model._stochastic_gradient/SGDClassifier/_more_tags": {},
  "sklearn/sklearn.linear_model._stochastic_gradient/BaseSGDRegressor/__init__": {},
  "sklearn/sklearn.linear_model._stochastic_gradient/BaseSGDRegressor/_partial_fit": {},
  "sklearn/sklearn.linear_model._stochastic_gradient/BaseSGDRegressor/partial_fit": {},
  "sklearn/sklearn.linear_model._stochastic_gradient/BaseSGDRegressor/_fit": {},
  "sklearn/sklearn.linear_model._stochastic_gradient/BaseSGDRegressor/fit": {},
  "sklearn/sklearn.linear_model._stochastic_gradient/BaseSGDRegressor/_decision_function": {},
  "sklearn/sklearn.linear_model._stochastic_gradient/BaseSGDRegressor/predict": {},
  "sklearn/sklearn.linear_model._stochastic_gradient/BaseSGDRegressor/_fit_regressor": {},
  "sklearn/sklearn.linear_model._stochastic_gradient/SGDRegressor/__init__": {
    "l1_ratio": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._stochastic_gradient/SGDRegressor/__init__/l1_ratio",
          "name": "l1_ratio",
          "qname": "sklearn.linear_model._stochastic_gradient.SGDRegressor.__init__.l1_ratio",
          "default_value": "0.15",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "0.15",
            "description": "The Elastic Net mixing parameter, with 0 <= l1_ratio <= 1.\nl1_ratio=0 corresponds to L2 penalty, l1_ratio=1 to L1.\nOnly used if `penalty` is 'elasticnet'."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._stochastic_gradient/SGDRegressor/__init__/penalty",
          "name": "penalty",
          "qname": "sklearn.linear_model._stochastic_gradient.SGDRegressor.__init__.penalty",
          "default_value": "'l2'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'l2', 'l1', 'elasticnet', None}",
            "default_value": "'l2'",
            "description": "The penalty (aka regularization term) to be used. Defaults to 'l2'\nwhich is the standard regularizer for linear SVM models. 'l1' and\n'elasticnet' might bring sparsity to the model (feature selection)\nnot achievable with 'l2'. No penalty is added when set to `None`."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "elasticnet",
              "l1",
              "l2"
            ]
          }
        },
        "hasCondition": {
          "condition": "if penalty is elasticnet"
        },
        "hasAction": {
          "action": "Only used"
        }
      }
    ],
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._stochastic_gradient/SGDRegressor/__init__/random_state",
          "name": "random_state",
          "qname": "sklearn.linear_model._stochastic_gradient.SGDRegressor.__init__.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance",
            "default_value": "None",
            "description": "Used for shuffling the data, when ``shuffle`` is set to ``True``.\nPass an int for reproducible output across multiple function calls.\nSee :term:`Glossary <random_state>`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._stochastic_gradient/SGDRegressor/__init__/shuffle",
          "name": "shuffle",
          "qname": "sklearn.linear_model._stochastic_gradient.SGDRegressor.__init__.shuffle",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Whether or not the training data should be shuffled after each epoch."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "when shuffle is set to True"
        },
        "hasAction": {
          "action": "Used for shuffling the data ,"
        }
      }
    ],
    "learning_rate": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._stochastic_gradient/SGDRegressor/__init__/learning_rate",
          "name": "learning_rate",
          "qname": "sklearn.linear_model._stochastic_gradient.SGDRegressor.__init__.learning_rate",
          "default_value": "'invscaling'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "'invscaling'",
            "description": "The learning rate schedule:\n\n- 'constant': `eta = eta0`\n- 'optimal': `eta = 1.0 / (alpha * (t + t0))`\n  where t0 is chosen by a heuristic proposed by Leon Bottou.\n- 'invscaling': `eta = eta0 / pow(t, power_t)`\n- 'adaptive': eta = eta0, as long as the training keeps decreasing.\n  Each time n_iter_no_change consecutive epochs fail to decrease the\n  training loss by tol or fail to increase validation score by tol if\n  early_stopping is True, the current learning rate is divided by 5.\n\n    .. versionadded:: 0.20\n        Added 'adaptive' option"
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._stochastic_gradient/SGDRegressor/__init__/early_stopping",
          "name": "early_stopping",
          "qname": "sklearn.linear_model._stochastic_gradient.SGDRegressor.__init__.early_stopping",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "Whether to use early stopping to terminate training when validation\nscore is not improving. If set to True, it will automatically set aside\na fraction of training data as validation and terminate\ntraining when validation score returned by the `score` method is not\nimproving by at least `tol` for `n_iter_no_change` consecutive\nepochs.\n\n.. versionadded:: 0.20\n    Added 'early_stopping' option"
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "if early_stopping is True"
        },
        "hasAction": {
          "action": "to increase validation score by tol"
        }
      }
    ],
    "validation_fraction": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._stochastic_gradient/SGDRegressor/__init__/validation_fraction",
          "name": "validation_fraction",
          "qname": "sklearn.linear_model._stochastic_gradient.SGDRegressor.__init__.validation_fraction",
          "default_value": "0.1",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "0.1",
            "description": "The proportion of training data to set aside as validation set for\nearly stopping. Must be between 0 and 1.\nOnly used if `early_stopping` is True.\n\n.. versionadded:: 0.20\n    Added 'validation_fraction' option"
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._stochastic_gradient/SGDRegressor/__init__/early_stopping",
          "name": "early_stopping",
          "qname": "sklearn.linear_model._stochastic_gradient.SGDRegressor.__init__.early_stopping",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "Whether to use early stopping to terminate training when validation\nscore is not improving. If set to True, it will automatically set aside\na fraction of training data as validation and terminate\ntraining when validation score returned by the `score` method is not\nimproving by at least `tol` for `n_iter_no_change` consecutive\nepochs.\n\n.. versionadded:: 0.20\n    Added 'early_stopping' option"
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "if early_stopping is True"
        },
        "hasAction": {
          "action": "Only used"
        }
      }
    ],
    "warm_start": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._stochastic_gradient/SGDRegressor/__init__/warm_start",
          "name": "warm_start",
          "qname": "sklearn.linear_model._stochastic_gradient.SGDRegressor.__init__.warm_start",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "When set to True, reuse the solution of the previous call to fit as\ninitialization, otherwise, just erase the previous solution.\nSee :term:`the Glossary <warm_start>`.\n\nRepeatedly calling fit or partial_fit when warm_start is True can\nresult in a different solution than when calling fit a single time\nbecause of the way the data is shuffled.\nIf a dynamic learning rate is used, the learning rate is adapted\ndepending on the number of samples already seen. Calling ``fit`` resets\nthis counter, while ``partial_fit``  will result in increasing the\nexisting counter."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._stochastic_gradient/SGDRegressor/__init__/warm_start",
          "name": "warm_start",
          "qname": "sklearn.linear_model._stochastic_gradient.SGDRegressor.__init__.warm_start",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "When set to True, reuse the solution of the previous call to fit as\ninitialization, otherwise, just erase the previous solution.\nSee :term:`the Glossary <warm_start>`.\n\nRepeatedly calling fit or partial_fit when warm_start is True can\nresult in a different solution than when calling fit a single time\nbecause of the way the data is shuffled.\nIf a dynamic learning rate is used, the learning rate is adapted\ndepending on the number of samples already seen. Calling ``fit`` resets\nthis counter, while ``partial_fit``  will result in increasing the\nexisting counter."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "when warm_start is True"
        },
        "hasAction": {
          "action": "Repeatedly calling fit or partial_fit"
        }
      }
    ]
  },
  "sklearn/sklearn.linear_model._stochastic_gradient/SGDRegressor/_more_tags": {},
  "sklearn/sklearn.linear_model._stochastic_gradient/SGDOneClassSVM/__init__": {
    "warm_start": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._stochastic_gradient/SGDOneClassSVM/__init__/warm_start",
          "name": "warm_start",
          "qname": "sklearn.linear_model._stochastic_gradient.SGDOneClassSVM.__init__.warm_start",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "When set to True, reuse the solution of the previous call to fit as\ninitialization, otherwise, just erase the previous solution.\nSee :term:`the Glossary <warm_start>`.\n\nRepeatedly calling fit or partial_fit when warm_start is True can\nresult in a different solution than when calling fit a single time\nbecause of the way the data is shuffled.\nIf a dynamic learning rate is used, the learning rate is adapted\ndepending on the number of samples already seen. Calling ``fit`` resets\nthis counter, while ``partial_fit``  will result in increasing the\nexisting counter."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._stochastic_gradient/SGDOneClassSVM/__init__/warm_start",
          "name": "warm_start",
          "qname": "sklearn.linear_model._stochastic_gradient.SGDOneClassSVM.__init__.warm_start",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "When set to True, reuse the solution of the previous call to fit as\ninitialization, otherwise, just erase the previous solution.\nSee :term:`the Glossary <warm_start>`.\n\nRepeatedly calling fit or partial_fit when warm_start is True can\nresult in a different solution than when calling fit a single time\nbecause of the way the data is shuffled.\nIf a dynamic learning rate is used, the learning rate is adapted\ndepending on the number of samples already seen. Calling ``fit`` resets\nthis counter, while ``partial_fit``  will result in increasing the\nexisting counter."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "when warm_start is True"
        },
        "hasAction": {
          "action": "Repeatedly calling fit or partial_fit"
        }
      }
    ]
  },
  "sklearn/sklearn.linear_model._stochastic_gradient/SGDOneClassSVM/_fit_one_class": {},
  "sklearn/sklearn.linear_model._stochastic_gradient/SGDOneClassSVM/_partial_fit": {},
  "sklearn/sklearn.linear_model._stochastic_gradient/SGDOneClassSVM/partial_fit": {},
  "sklearn/sklearn.linear_model._stochastic_gradient/SGDOneClassSVM/_fit": {},
  "sklearn/sklearn.linear_model._stochastic_gradient/SGDOneClassSVM/fit": {},
  "sklearn/sklearn.linear_model._stochastic_gradient/SGDOneClassSVM/decision_function": {},
  "sklearn/sklearn.linear_model._stochastic_gradient/SGDOneClassSVM/score_samples": {},
  "sklearn/sklearn.linear_model._stochastic_gradient/SGDOneClassSVM/predict": {},
  "sklearn/sklearn.linear_model._stochastic_gradient/SGDOneClassSVM/_more_tags": {},
  "sklearn/sklearn.linear_model._theil_sen/_modified_weiszfeld_step": {},
  "sklearn/sklearn.linear_model._theil_sen/_spatial_median": {},
  "sklearn/sklearn.linear_model._theil_sen/_breakdown_point": {},
  "sklearn/sklearn.linear_model._theil_sen/_lstsq": {},
  "sklearn/sklearn.linear_model._theil_sen/TheilSenRegressor/__init__": {
    "max_subpopulation": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.linear_model._theil_sen/TheilSenRegressor/__init__/max_subpopulation",
          "name": "max_subpopulation",
          "qname": "sklearn.linear_model._theil_sen.TheilSenRegressor.__init__.max_subpopulation",
          "default_value": "10000.0",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "1e4",
            "description": "Instead of computing with a set of cardinality 'n choose k', where n is\nthe number of samples and k is the number of subsamples (at least\nnumber of features), consider only a stochastic subpopulation of a\ngiven maximal size if 'n choose k' is larger than max_subpopulation.\nFor other than small problem sizes this parameter will determine\nmemory usage and runtime if n_subsamples is not changed. Note that the\ndata type should be int but floats such as 1e4 can be accepted too."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.linear_model._theil_sen/TheilSenRegressor/__init__/n_subsamples",
          "name": "n_subsamples",
          "qname": "sklearn.linear_model._theil_sen.TheilSenRegressor.__init__.n_subsamples",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "None",
            "description": "Number of samples to calculate the parameters. This is at least the\nnumber of features (plus 1 if fit_intercept=True) and the number of\nsamples as a maximum. A lower number leads to a higher breakdown\npoint and a low efficiency while a high number leads to a low\nbreakdown point and a high efficiency. If None, take the\nminimum number of subsamples leading to maximal robustness.\nIf n_subsamples is set to n_samples, Theil-Sen is identical to least\nsquares."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "hasCondition": {
          "condition": "if n_subsamples is not changed"
        },
        "hasAction": {
          "action": "this parameter will determine memory usage and runtime"
        }
      }
    ]
  },
  "sklearn/sklearn.linear_model._theil_sen/TheilSenRegressor/_check_subparams": {},
  "sklearn/sklearn.linear_model._theil_sen/TheilSenRegressor/fit": {},
  "sklearn/sklearn.linear_model._glm.glm/_GeneralizedLinearRegressor/__init__": {},
  "sklearn/sklearn.linear_model._glm.glm/_GeneralizedLinearRegressor/fit": {},
  "sklearn/sklearn.linear_model._glm.glm/_GeneralizedLinearRegressor/_linear_predictor": {},
  "sklearn/sklearn.linear_model._glm.glm/_GeneralizedLinearRegressor/predict": {},
  "sklearn/sklearn.linear_model._glm.glm/_GeneralizedLinearRegressor/score": {},
  "sklearn/sklearn.linear_model._glm.glm/_GeneralizedLinearRegressor/_more_tags": {},
  "sklearn/sklearn.linear_model._glm.glm/_GeneralizedLinearRegressor/_get_loss": {},
  "sklearn/sklearn.linear_model._glm.glm/_GeneralizedLinearRegressor/family@getter": {},
  "sklearn/sklearn.linear_model._glm.glm/PoissonRegressor/__init__": {},
  "sklearn/sklearn.linear_model._glm.glm/PoissonRegressor/_get_loss": {},
  "sklearn/sklearn.linear_model._glm.glm/GammaRegressor/__init__": {},
  "sklearn/sklearn.linear_model._glm.glm/GammaRegressor/_get_loss": {},
  "sklearn/sklearn.linear_model._glm.glm/TweedieRegressor/__init__": {},
  "sklearn/sklearn.linear_model._glm.glm/TweedieRegressor/_get_loss": {},
  "sklearn/sklearn.linear_model._glm._newton_solver/NewtonSolver/__init__": {},
  "sklearn/sklearn.linear_model._glm._newton_solver/NewtonSolver/setup": {},
  "sklearn/sklearn.linear_model._glm._newton_solver/NewtonSolver/update_gradient_hessian": {},
  "sklearn/sklearn.linear_model._glm._newton_solver/NewtonSolver/inner_solve": {},
  "sklearn/sklearn.linear_model._glm._newton_solver/NewtonSolver/fallback_lbfgs_solve": {},
  "sklearn/sklearn.linear_model._glm._newton_solver/NewtonSolver/line_search": {},
  "sklearn/sklearn.linear_model._glm._newton_solver/NewtonSolver/check_convergence": {},
  "sklearn/sklearn.linear_model._glm._newton_solver/NewtonSolver/finalize": {},
  "sklearn/sklearn.linear_model._glm._newton_solver/NewtonSolver/solve": {},
  "sklearn/sklearn.linear_model._glm._newton_solver/NewtonCholeskySolver/setup": {},
  "sklearn/sklearn.linear_model._glm._newton_solver/NewtonCholeskySolver/update_gradient_hessian": {},
  "sklearn/sklearn.linear_model._glm._newton_solver/NewtonCholeskySolver/inner_solve": {},
  "sklearn/sklearn.manifold._isomap/Isomap/__init__": {
    "radius": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.manifold._isomap/Isomap/__init__/radius",
          "name": "radius",
          "qname": "sklearn.manifold._isomap.Isomap.__init__.radius",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float or None",
            "default_value": "None",
            "description": "Limiting distance of neighbors to return. If `radius` is a float,\nthen `n_neighbors` must be set to `None`.\n\n.. versionadded:: 1.1"
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "float"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.manifold._isomap/Isomap/__init__/radius",
          "name": "radius",
          "qname": "sklearn.manifold._isomap.Isomap.__init__.radius",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float or None",
            "default_value": "None",
            "description": "Limiting distance of neighbors to return. If `radius` is a float,\nthen `n_neighbors` must be set to `None`.\n\n.. versionadded:: 1.1"
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "float"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If radius is a float"
        },
        "hasAction": {
          "action": ", then n_neighbors must be set to None . .."
        }
      }
    ],
    "tol": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.manifold._isomap/Isomap/__init__/tol",
          "name": "tol",
          "qname": "sklearn.manifold._isomap.Isomap.__init__.tol",
          "default_value": "0",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "0",
            "description": "Convergence tolerance passed to arpack or lobpcg.\nnot used if eigen_solver == 'dense'."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.manifold._isomap/Isomap/__init__/eigen_solver",
          "name": "eigen_solver",
          "qname": "sklearn.manifold._isomap.Isomap.__init__.eigen_solver",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'auto', 'arpack', 'dense'}",
            "default_value": "'auto'",
            "description": "'auto' : Attempt to choose the most efficient solver\nfor the given problem.\n\n'arpack' : Use Arnoldi decomposition to find the eigenvalues\nand eigenvectors.\n\n'dense' : Use a direct solver (i.e. LAPACK)\nfor the eigenvalue decomposition."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "arpack",
              "auto",
              "dense"
            ]
          }
        },
        "hasCondition": {
          "condition": "if eigen_solver equals dense"
        },
        "hasAction": {
          "action": "not used"
        }
      }
    ],
    "max_iter": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.manifold._isomap/Isomap/__init__/max_iter",
          "name": "max_iter",
          "qname": "sklearn.manifold._isomap.Isomap.__init__.max_iter",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "None",
            "description": "Maximum number of iterations for the arpack solver.\nnot used if eigen_solver == 'dense'."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.manifold._isomap/Isomap/__init__/eigen_solver",
          "name": "eigen_solver",
          "qname": "sklearn.manifold._isomap.Isomap.__init__.eigen_solver",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'auto', 'arpack', 'dense'}",
            "default_value": "'auto'",
            "description": "'auto' : Attempt to choose the most efficient solver\nfor the given problem.\n\n'arpack' : Use Arnoldi decomposition to find the eigenvalues\nand eigenvectors.\n\n'dense' : Use a direct solver (i.e. LAPACK)\nfor the eigenvalue decomposition."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "arpack",
              "auto",
              "dense"
            ]
          }
        },
        "hasCondition": {
          "condition": "if eigen_solver equals dense"
        },
        "hasAction": {
          "action": "not used"
        }
      }
    ],
    "metric": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.manifold._isomap/Isomap/__init__/metric",
          "name": "metric",
          "qname": "sklearn.manifold._isomap.Isomap.__init__.metric",
          "default_value": "'minkowski'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str, or callable",
            "default_value": "\"minkowski\"",
            "description": "The metric to use when calculating distance between instances in a\nfeature array. If metric is a string or callable, it must be one of\nthe options allowed by :func:`sklearn.metrics.pairwise_distances` for\nits metric parameter.\nIf metric is \"precomputed\", X is assumed to be a distance matrix and\nmust be square. X may be a :term:`Glossary <sparse graph>`.\n\n.. versionadded:: 0.22"
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.manifold._isomap/Isomap/__init__/metric",
          "name": "metric",
          "qname": "sklearn.manifold._isomap.Isomap.__init__.metric",
          "default_value": "'minkowski'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str, or callable",
            "default_value": "\"minkowski\"",
            "description": "The metric to use when calculating distance between instances in a\nfeature array. If metric is a string or callable, it must be one of\nthe options allowed by :func:`sklearn.metrics.pairwise_distances` for\nits metric parameter.\nIf metric is \"precomputed\", X is assumed to be a distance matrix and\nmust be square. X may be a :term:`Glossary <sparse graph>`.\n\n.. versionadded:: 0.22"
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If metric is precomputed"
        },
        "hasAction": {
          "action": ", X is assumed to be a distance matrix and must be square"
        }
      }
    ]
  },
  "sklearn/sklearn.manifold._isomap/Isomap/_fit_transform": {},
  "sklearn/sklearn.manifold._isomap/Isomap/reconstruction_error": {},
  "sklearn/sklearn.manifold._isomap/Isomap/fit": {},
  "sklearn/sklearn.manifold._isomap/Isomap/fit_transform": {},
  "sklearn/sklearn.manifold._isomap/Isomap/transform": {},
  "sklearn/sklearn.manifold._isomap/Isomap/_more_tags": {},
  "sklearn/sklearn.manifold._locally_linear/barycenter_weights": {},
  "sklearn/sklearn.manifold._locally_linear/barycenter_kneighbors_graph": {},
  "sklearn/sklearn.manifold._locally_linear/null_space": {
    "tol": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.manifold._locally_linear/null_space/tol",
          "name": "tol",
          "qname": "sklearn.manifold._locally_linear.null_space.tol",
          "default_value": "1e-06",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "float",
            "default_value": "1e-6",
            "description": "Tolerance for 'arpack' method.\nNot used if eigen_solver=='dense'."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.manifold._locally_linear/null_space/eigen_solver",
          "name": "eigen_solver",
          "qname": "sklearn.manifold._locally_linear.null_space.eigen_solver",
          "default_value": "'arpack'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "{'auto', 'arpack', 'dense'}",
            "default_value": "'arpack'",
            "description": "auto : algorithm will attempt to choose the best method for input data\narpack : use arnoldi iteration in shift-invert mode.\n            For this method, M may be a dense matrix, sparse matrix,\n            or general linear operator.\n            Warning: ARPACK can be unstable for some problems.  It is\n            best to try several random seeds in order to check results.\ndense  : use standard dense matrix operations for the eigenvalue\n            decomposition.  For this method, M must be an array\n            or matrix type.  This method should be avoided for\n            large problems."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "arpack",
              "auto",
              "dense"
            ]
          }
        },
        "hasCondition": {
          "condition": "if eigen_solver equals dense"
        },
        "hasAction": {
          "action": "Not used"
        }
      }
    ],
    "max_iter": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.manifold._locally_linear/null_space/max_iter",
          "name": "max_iter",
          "qname": "sklearn.manifold._locally_linear.null_space.max_iter",
          "default_value": "100",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "int",
            "default_value": "100",
            "description": "Maximum number of iterations for 'arpack' method.\nNot used if eigen_solver=='dense'"
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.manifold._locally_linear/null_space/eigen_solver",
          "name": "eigen_solver",
          "qname": "sklearn.manifold._locally_linear.null_space.eigen_solver",
          "default_value": "'arpack'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "{'auto', 'arpack', 'dense'}",
            "default_value": "'arpack'",
            "description": "auto : algorithm will attempt to choose the best method for input data\narpack : use arnoldi iteration in shift-invert mode.\n            For this method, M may be a dense matrix, sparse matrix,\n            or general linear operator.\n            Warning: ARPACK can be unstable for some problems.  It is\n            best to try several random seeds in order to check results.\ndense  : use standard dense matrix operations for the eigenvalue\n            decomposition.  For this method, M must be an array\n            or matrix type.  This method should be avoided for\n            large problems."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "arpack",
              "auto",
              "dense"
            ]
          }
        },
        "hasCondition": {
          "condition": "if eigen_solver equals dense"
        },
        "hasAction": {
          "action": "Not used"
        }
      }
    ]
  },
  "sklearn/sklearn.manifold._locally_linear/locally_linear_embedding": {
    "tol": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.manifold._locally_linear/locally_linear_embedding/tol",
          "name": "tol",
          "qname": "sklearn.manifold._locally_linear.locally_linear_embedding.tol",
          "default_value": "1e-06",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "1e-6",
            "description": "Tolerance for 'arpack' method\nNot used if eigen_solver=='dense'."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.manifold._locally_linear/locally_linear_embedding/eigen_solver",
          "name": "eigen_solver",
          "qname": "sklearn.manifold._locally_linear.locally_linear_embedding.eigen_solver",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'auto', 'arpack', 'dense'}",
            "default_value": "'auto'",
            "description": "auto : algorithm will attempt to choose the best method for input data\n\narpack : use arnoldi iteration in shift-invert mode.\n            For this method, M may be a dense matrix, sparse matrix,\n            or general linear operator.\n            Warning: ARPACK can be unstable for some problems.  It is\n            best to try several random seeds in order to check results.\n\ndense  : use standard dense matrix operations for the eigenvalue\n            decomposition.  For this method, M must be an array\n            or matrix type.  This method should be avoided for\n            large problems."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "arpack",
              "auto",
              "dense"
            ]
          }
        },
        "hasCondition": {
          "condition": "if eigen_solver equals dense"
        },
        "hasAction": {
          "action": "Not used"
        }
      }
    ],
    "hessian_tol": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.manifold._locally_linear/locally_linear_embedding/hessian_tol",
          "name": "hessian_tol",
          "qname": "sklearn.manifold._locally_linear.locally_linear_embedding.hessian_tol",
          "default_value": "0.0001",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "1e-4",
            "description": "Tolerance for Hessian eigenmapping method.\nOnly used if method == 'hessian'."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.manifold._locally_linear/locally_linear_embedding/method",
          "name": "method",
          "qname": "sklearn.manifold._locally_linear.locally_linear_embedding.method",
          "default_value": "'standard'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'standard', 'hessian', 'modified', 'ltsa'}",
            "default_value": "'standard'",
            "description": "standard : use the standard locally linear embedding algorithm.\n           see reference [1]_\nhessian  : use the Hessian eigenmap method.  This method requires\n           n_neighbors > n_components * (1 + (n_components + 1) / 2.\n           see reference [2]_\nmodified : use the modified locally linear embedding algorithm.\n           see reference [3]_\nltsa     : use local tangent space alignment algorithm\n           see reference [4]_"
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "ltsa",
              "modified",
              "standard",
              "hessian"
            ]
          }
        },
        "hasCondition": {
          "condition": "if method equals hessian"
        },
        "hasAction": {
          "action": "Only used"
        }
      }
    ],
    "modified_tol": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.manifold._locally_linear/locally_linear_embedding/modified_tol",
          "name": "modified_tol",
          "qname": "sklearn.manifold._locally_linear.locally_linear_embedding.modified_tol",
          "default_value": "1e-12",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "1e-12",
            "description": "Tolerance for modified LLE method.\nOnly used if method == 'modified'."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.manifold._locally_linear/locally_linear_embedding/method",
          "name": "method",
          "qname": "sklearn.manifold._locally_linear.locally_linear_embedding.method",
          "default_value": "'standard'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'standard', 'hessian', 'modified', 'ltsa'}",
            "default_value": "'standard'",
            "description": "standard : use the standard locally linear embedding algorithm.\n           see reference [1]_\nhessian  : use the Hessian eigenmap method.  This method requires\n           n_neighbors > n_components * (1 + (n_components + 1) / 2.\n           see reference [2]_\nmodified : use the modified locally linear embedding algorithm.\n           see reference [3]_\nltsa     : use local tangent space alignment algorithm\n           see reference [4]_"
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "ltsa",
              "modified",
              "standard",
              "hessian"
            ]
          }
        },
        "hasCondition": {
          "condition": "if method equals modified"
        },
        "hasAction": {
          "action": "Only used"
        }
      }
    ]
  },
  "sklearn/sklearn.manifold._locally_linear/LocallyLinearEmbedding/__init__": {
    "tol": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.manifold._locally_linear/LocallyLinearEmbedding/__init__/tol",
          "name": "tol",
          "qname": "sklearn.manifold._locally_linear.LocallyLinearEmbedding.__init__.tol",
          "default_value": "1e-06",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "1e-6",
            "description": "Tolerance for 'arpack' method\nNot used if eigen_solver=='dense'."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.manifold._locally_linear/LocallyLinearEmbedding/__init__/eigen_solver",
          "name": "eigen_solver",
          "qname": "sklearn.manifold._locally_linear.LocallyLinearEmbedding.__init__.eigen_solver",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'auto', 'arpack', 'dense'}",
            "default_value": "'auto'",
            "description": "The solver used to compute the eigenvectors. The available options are:\n\n- `'auto'` : algorithm will attempt to choose the best method for input\n  data.\n- `'arpack'` : use arnoldi iteration in shift-invert mode. For this\n  method, M may be a dense matrix, sparse matrix, or general linear\n  operator.\n- `'dense'`  : use standard dense matrix operations for the eigenvalue\n  decomposition. For this method, M must be an array or matrix type.\n  This method should be avoided for large problems.\n\n.. warning::\n   ARPACK can be unstable for some problems.  It is best to try several\n   random seeds in order to check results."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "arpack",
              "auto",
              "dense"
            ]
          }
        },
        "hasCondition": {
          "condition": "if eigen_solver equals dense"
        },
        "hasAction": {
          "action": "Not used"
        }
      }
    ],
    "max_iter": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.manifold._locally_linear/LocallyLinearEmbedding/__init__/max_iter",
          "name": "max_iter",
          "qname": "sklearn.manifold._locally_linear.LocallyLinearEmbedding.__init__.max_iter",
          "default_value": "100",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "100",
            "description": "Maximum number of iterations for the arpack solver.\nNot used if eigen_solver=='dense'."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.manifold._locally_linear/LocallyLinearEmbedding/__init__/eigen_solver",
          "name": "eigen_solver",
          "qname": "sklearn.manifold._locally_linear.LocallyLinearEmbedding.__init__.eigen_solver",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'auto', 'arpack', 'dense'}",
            "default_value": "'auto'",
            "description": "The solver used to compute the eigenvectors. The available options are:\n\n- `'auto'` : algorithm will attempt to choose the best method for input\n  data.\n- `'arpack'` : use arnoldi iteration in shift-invert mode. For this\n  method, M may be a dense matrix, sparse matrix, or general linear\n  operator.\n- `'dense'`  : use standard dense matrix operations for the eigenvalue\n  decomposition. For this method, M must be an array or matrix type.\n  This method should be avoided for large problems.\n\n.. warning::\n   ARPACK can be unstable for some problems.  It is best to try several\n   random seeds in order to check results."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "arpack",
              "auto",
              "dense"
            ]
          }
        },
        "hasCondition": {
          "condition": "if eigen_solver equals dense"
        },
        "hasAction": {
          "action": "Not used"
        }
      }
    ],
    "hessian_tol": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.manifold._locally_linear/LocallyLinearEmbedding/__init__/hessian_tol",
          "name": "hessian_tol",
          "qname": "sklearn.manifold._locally_linear.LocallyLinearEmbedding.__init__.hessian_tol",
          "default_value": "0.0001",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "1e-4",
            "description": "Tolerance for Hessian eigenmapping method.\nOnly used if ``method == 'hessian'``."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.manifold._locally_linear/LocallyLinearEmbedding/__init__/method",
          "name": "method",
          "qname": "sklearn.manifold._locally_linear.LocallyLinearEmbedding.__init__.method",
          "default_value": "'standard'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'standard', 'hessian', 'modified', 'ltsa'}",
            "default_value": "'standard'",
            "description": "- `standard`: use the standard locally linear embedding algorithm. see\n  reference [1]_\n- `hessian`: use the Hessian eigenmap method. This method requires\n  ``n_neighbors > n_components * (1 + (n_components + 1) / 2``. see\n  reference [2]_\n- `modified`: use the modified locally linear embedding algorithm.\n  see reference [3]_\n- `ltsa`: use local tangent space alignment algorithm. see\n  reference [4]_"
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "ltsa",
              "modified",
              "standard",
              "hessian"
            ]
          }
        },
        "hasCondition": {
          "condition": "if method equals hessian"
        },
        "hasAction": {
          "action": "Only used"
        }
      }
    ],
    "modified_tol": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.manifold._locally_linear/LocallyLinearEmbedding/__init__/modified_tol",
          "name": "modified_tol",
          "qname": "sklearn.manifold._locally_linear.LocallyLinearEmbedding.__init__.modified_tol",
          "default_value": "1e-12",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "1e-12",
            "description": "Tolerance for modified LLE method.\nOnly used if ``method == 'modified'``."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.manifold._locally_linear/LocallyLinearEmbedding/__init__/method",
          "name": "method",
          "qname": "sklearn.manifold._locally_linear.LocallyLinearEmbedding.__init__.method",
          "default_value": "'standard'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'standard', 'hessian', 'modified', 'ltsa'}",
            "default_value": "'standard'",
            "description": "- `standard`: use the standard locally linear embedding algorithm. see\n  reference [1]_\n- `hessian`: use the Hessian eigenmap method. This method requires\n  ``n_neighbors > n_components * (1 + (n_components + 1) / 2``. see\n  reference [2]_\n- `modified`: use the modified locally linear embedding algorithm.\n  see reference [3]_\n- `ltsa`: use local tangent space alignment algorithm. see\n  reference [4]_"
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "ltsa",
              "modified",
              "standard",
              "hessian"
            ]
          }
        },
        "hasCondition": {
          "condition": "if method equals modified"
        },
        "hasAction": {
          "action": "Only used"
        }
      }
    ]
  },
  "sklearn/sklearn.manifold._locally_linear/LocallyLinearEmbedding/_fit_transform": {},
  "sklearn/sklearn.manifold._locally_linear/LocallyLinearEmbedding/fit": {},
  "sklearn/sklearn.manifold._locally_linear/LocallyLinearEmbedding/fit_transform": {},
  "sklearn/sklearn.manifold._locally_linear/LocallyLinearEmbedding/transform": {},
  "sklearn/sklearn.manifold._mds/_smacof_single": {},
  "sklearn/sklearn.manifold._mds/smacof": {},
  "sklearn/sklearn.manifold._mds/MDS/__init__": {},
  "sklearn/sklearn.manifold._mds/MDS/_more_tags": {},
  "sklearn/sklearn.manifold._mds/MDS/fit": {},
  "sklearn/sklearn.manifold._mds/MDS/fit_transform": {},
  "sklearn/sklearn.manifold._spectral_embedding/_graph_connected_component": {},
  "sklearn/sklearn.manifold._spectral_embedding/_graph_is_connected": {},
  "sklearn/sklearn.manifold._spectral_embedding/_set_diag": {},
  "sklearn/sklearn.manifold._spectral_embedding/spectral_embedding": {
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.manifold._spectral_embedding/spectral_embedding/random_state",
          "name": "random_state",
          "qname": "sklearn.manifold._spectral_embedding.spectral_embedding.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance or None",
            "default_value": "None",
            "description": "A pseudo random number generator used for the initialization\nof the lobpcg eigen vectors decomposition when `eigen_solver ==\n'amg'`, and for the K-Means initialization. Use an int to make\nthe results deterministic across calls (See\n:term:`Glossary <random_state>`).\n\n.. note::\n    When using `eigen_solver == 'amg'`,\n    it is necessary to also fix the global numpy seed with\n    `np.random.seed(int)` to get deterministic results. See\n    https://github.com/pyamg/pyamg/issues/139 for further\n    information."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.manifold._spectral_embedding/spectral_embedding/eigen_solver",
          "name": "eigen_solver",
          "qname": "sklearn.manifold._spectral_embedding.spectral_embedding.eigen_solver",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'arpack', 'lobpcg', 'amg'}",
            "default_value": "None",
            "description": "The eigenvalue decomposition strategy to use. AMG requires pyamg\nto be installed. It can be faster on very large, sparse problems,\nbut may also lead to instabilities. If None, then ``'arpack'`` is\nused."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "amg",
              "arpack",
              "lobpcg"
            ]
          }
        },
        "hasCondition": {
          "condition": "when eigen_solver equals amg"
        },
        "hasAction": {
          "action": "used for the initialization of the lobpcg eigen vectors decomposition"
        }
      }
    ],
    "eigen_tol": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.manifold._spectral_embedding/spectral_embedding/eigen_tol",
          "name": "eigen_tol",
          "qname": "sklearn.manifold._spectral_embedding.spectral_embedding.eigen_tol",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "\"auto\"",
            "description": "Stopping criterion for eigendecomposition of the Laplacian matrix.\nIf `eigen_tol=\"auto\"` then the passed tolerance will depend on the\n`eigen_solver`:\n\n- If `eigen_solver=\"arpack\"`, then `eigen_tol=0.0`;\n- If `eigen_solver=\"lobpcg\"` or `eigen_solver=\"amg\"`, then\n  `eigen_tol=None` which configures the underlying `lobpcg` solver to\n  automatically resolve the value according to their heuristics. See,\n  :func:`scipy.sparse.linalg.lobpcg` for details.\n\nNote that when using `eigen_solver=\"amg\"` values of `tol<1e-5` may lead\nto convergence issues and should be avoided.\n\n.. versionadded:: 1.2\n   Added 'auto' option."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.manifold._spectral_embedding/spectral_embedding/eigen_tol",
          "name": "eigen_tol",
          "qname": "sklearn.manifold._spectral_embedding.spectral_embedding.eigen_tol",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "\"auto\"",
            "description": "Stopping criterion for eigendecomposition of the Laplacian matrix.\nIf `eigen_tol=\"auto\"` then the passed tolerance will depend on the\n`eigen_solver`:\n\n- If `eigen_solver=\"arpack\"`, then `eigen_tol=0.0`;\n- If `eigen_solver=\"lobpcg\"` or `eigen_solver=\"amg\"`, then\n  `eigen_tol=None` which configures the underlying `lobpcg` solver to\n  automatically resolve the value according to their heuristics. See,\n  :func:`scipy.sparse.linalg.lobpcg` for details.\n\nNote that when using `eigen_solver=\"amg\"` values of `tol<1e-5` may lead\nto convergence issues and should be avoided.\n\n.. versionadded:: 1.2\n   Added 'auto' option."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "hasCondition": {
          "condition": "If eigen_tol equals auto"
        },
        "hasAction": {
          "action": "then the passed tolerance will depend on the eigen_solver : -"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.manifold._spectral_embedding/spectral_embedding/eigen_tol",
          "name": "eigen_tol",
          "qname": "sklearn.manifold._spectral_embedding.spectral_embedding.eigen_tol",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "\"auto\"",
            "description": "Stopping criterion for eigendecomposition of the Laplacian matrix.\nIf `eigen_tol=\"auto\"` then the passed tolerance will depend on the\n`eigen_solver`:\n\n- If `eigen_solver=\"arpack\"`, then `eigen_tol=0.0`;\n- If `eigen_solver=\"lobpcg\"` or `eigen_solver=\"amg\"`, then\n  `eigen_tol=None` which configures the underlying `lobpcg` solver to\n  automatically resolve the value according to their heuristics. See,\n  :func:`scipy.sparse.linalg.lobpcg` for details.\n\nNote that when using `eigen_solver=\"amg\"` values of `tol<1e-5` may lead\nto convergence issues and should be avoided.\n\n.. versionadded:: 1.2\n   Added 'auto' option."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.manifold._spectral_embedding/spectral_embedding/eigen_solver",
          "name": "eigen_solver",
          "qname": "sklearn.manifold._spectral_embedding.spectral_embedding.eigen_solver",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'arpack', 'lobpcg', 'amg'}",
            "default_value": "None",
            "description": "The eigenvalue decomposition strategy to use. AMG requires pyamg\nto be installed. It can be faster on very large, sparse problems,\nbut may also lead to instabilities. If None, then ``'arpack'`` is\nused."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "amg",
              "arpack",
              "lobpcg"
            ]
          }
        },
        "hasCondition": {
          "condition": "If eigen_solver equals arpack"
        },
        "hasAction": {
          "action": "If eigen_tol equals auto then the passed tolerance will depend on the eigen_solver : - , then eigen_tol equals 0.0 ; - If eigen_solver equals lobpcg or eigen_solver equals amg"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.manifold._spectral_embedding/spectral_embedding/eigen_tol",
          "name": "eigen_tol",
          "qname": "sklearn.manifold._spectral_embedding.spectral_embedding.eigen_tol",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "\"auto\"",
            "description": "Stopping criterion for eigendecomposition of the Laplacian matrix.\nIf `eigen_tol=\"auto\"` then the passed tolerance will depend on the\n`eigen_solver`:\n\n- If `eigen_solver=\"arpack\"`, then `eigen_tol=0.0`;\n- If `eigen_solver=\"lobpcg\"` or `eigen_solver=\"amg\"`, then\n  `eigen_tol=None` which configures the underlying `lobpcg` solver to\n  automatically resolve the value according to their heuristics. See,\n  :func:`scipy.sparse.linalg.lobpcg` for details.\n\nNote that when using `eigen_solver=\"amg\"` values of `tol<1e-5` may lead\nto convergence issues and should be avoided.\n\n.. versionadded:: 1.2\n   Added 'auto' option."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.manifold._spectral_embedding/spectral_embedding/eigen_solver",
          "name": "eigen_solver",
          "qname": "sklearn.manifold._spectral_embedding.spectral_embedding.eigen_solver",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'arpack', 'lobpcg', 'amg'}",
            "default_value": "None",
            "description": "The eigenvalue decomposition strategy to use. AMG requires pyamg\nto be installed. It can be faster on very large, sparse problems,\nbut may also lead to instabilities. If None, then ``'arpack'`` is\nused."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "amg",
              "arpack",
              "lobpcg"
            ]
          }
        },
        "hasCondition": {
          "condition": "If eigen_solver equals lobpcg or eigen_solver"
        },
        "hasAction": {
          "action": "equals amg"
        }
      }
    ]
  },
  "sklearn/sklearn.manifold._spectral_embedding/SpectralEmbedding/__init__": {
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.manifold._spectral_embedding/SpectralEmbedding/__init__/random_state",
          "name": "random_state",
          "qname": "sklearn.manifold._spectral_embedding.SpectralEmbedding.__init__.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance or None",
            "default_value": "None",
            "description": "A pseudo random number generator used for the initialization\nof the lobpcg eigen vectors decomposition when `eigen_solver ==\n'amg'`, and for the K-Means initialization. Use an int to make\nthe results deterministic across calls (See\n:term:`Glossary <random_state>`).\n\n.. note::\n    When using `eigen_solver == 'amg'`,\n    it is necessary to also fix the global numpy seed with\n    `np.random.seed(int)` to get deterministic results. See\n    https://github.com/pyamg/pyamg/issues/139 for further\n    information."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.manifold._spectral_embedding/SpectralEmbedding/__init__/eigen_solver",
          "name": "eigen_solver",
          "qname": "sklearn.manifold._spectral_embedding.SpectralEmbedding.__init__.eigen_solver",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'arpack', 'lobpcg', 'amg'}",
            "default_value": "None",
            "description": "The eigenvalue decomposition strategy to use. AMG requires pyamg\nto be installed. It can be faster on very large, sparse problems.\nIf None, then ``'arpack'`` is used."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "amg",
              "arpack",
              "lobpcg"
            ]
          }
        },
        "hasCondition": {
          "condition": "when eigen_solver equals amg"
        },
        "hasAction": {
          "action": "used for the initialization of the lobpcg eigen vectors decomposition"
        }
      }
    ],
    "eigen_tol": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.manifold._spectral_embedding/SpectralEmbedding/__init__/eigen_tol",
          "name": "eigen_tol",
          "qname": "sklearn.manifold._spectral_embedding.SpectralEmbedding.__init__.eigen_tol",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "\"auto\"",
            "description": "Stopping criterion for eigendecomposition of the Laplacian matrix.\nIf `eigen_tol=\"auto\"` then the passed tolerance will depend on the\n`eigen_solver`:\n\n- If `eigen_solver=\"arpack\"`, then `eigen_tol=0.0`;\n- If `eigen_solver=\"lobpcg\"` or `eigen_solver=\"amg\"`, then\n  `eigen_tol=None` which configures the underlying `lobpcg` solver to\n  automatically resolve the value according to their heuristics. See,\n  :func:`scipy.sparse.linalg.lobpcg` for details.\n\nNote that when using `eigen_solver=\"lobpcg\"` or `eigen_solver=\"amg\"`\nvalues of `tol<1e-5` may lead to convergence issues and should be\navoided.\n\n.. versionadded:: 1.2"
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.manifold._spectral_embedding/SpectralEmbedding/__init__/eigen_tol",
          "name": "eigen_tol",
          "qname": "sklearn.manifold._spectral_embedding.SpectralEmbedding.__init__.eigen_tol",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "\"auto\"",
            "description": "Stopping criterion for eigendecomposition of the Laplacian matrix.\nIf `eigen_tol=\"auto\"` then the passed tolerance will depend on the\n`eigen_solver`:\n\n- If `eigen_solver=\"arpack\"`, then `eigen_tol=0.0`;\n- If `eigen_solver=\"lobpcg\"` or `eigen_solver=\"amg\"`, then\n  `eigen_tol=None` which configures the underlying `lobpcg` solver to\n  automatically resolve the value according to their heuristics. See,\n  :func:`scipy.sparse.linalg.lobpcg` for details.\n\nNote that when using `eigen_solver=\"lobpcg\"` or `eigen_solver=\"amg\"`\nvalues of `tol<1e-5` may lead to convergence issues and should be\navoided.\n\n.. versionadded:: 1.2"
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "hasCondition": {
          "condition": "If eigen_tol equals auto"
        },
        "hasAction": {
          "action": "then the passed tolerance will depend on the eigen_solver : -"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.manifold._spectral_embedding/SpectralEmbedding/__init__/eigen_tol",
          "name": "eigen_tol",
          "qname": "sklearn.manifold._spectral_embedding.SpectralEmbedding.__init__.eigen_tol",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "\"auto\"",
            "description": "Stopping criterion for eigendecomposition of the Laplacian matrix.\nIf `eigen_tol=\"auto\"` then the passed tolerance will depend on the\n`eigen_solver`:\n\n- If `eigen_solver=\"arpack\"`, then `eigen_tol=0.0`;\n- If `eigen_solver=\"lobpcg\"` or `eigen_solver=\"amg\"`, then\n  `eigen_tol=None` which configures the underlying `lobpcg` solver to\n  automatically resolve the value according to their heuristics. See,\n  :func:`scipy.sparse.linalg.lobpcg` for details.\n\nNote that when using `eigen_solver=\"lobpcg\"` or `eigen_solver=\"amg\"`\nvalues of `tol<1e-5` may lead to convergence issues and should be\navoided.\n\n.. versionadded:: 1.2"
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.manifold._spectral_embedding/SpectralEmbedding/__init__/eigen_solver",
          "name": "eigen_solver",
          "qname": "sklearn.manifold._spectral_embedding.SpectralEmbedding.__init__.eigen_solver",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'arpack', 'lobpcg', 'amg'}",
            "default_value": "None",
            "description": "The eigenvalue decomposition strategy to use. AMG requires pyamg\nto be installed. It can be faster on very large, sparse problems.\nIf None, then ``'arpack'`` is used."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "amg",
              "arpack",
              "lobpcg"
            ]
          }
        },
        "hasCondition": {
          "condition": "If eigen_solver equals arpack"
        },
        "hasAction": {
          "action": "If eigen_tol equals auto then the passed tolerance will depend on the eigen_solver : - , then eigen_tol equals 0.0 ; - If eigen_solver equals lobpcg or eigen_solver equals amg"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.manifold._spectral_embedding/SpectralEmbedding/__init__/eigen_tol",
          "name": "eigen_tol",
          "qname": "sklearn.manifold._spectral_embedding.SpectralEmbedding.__init__.eigen_tol",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "\"auto\"",
            "description": "Stopping criterion for eigendecomposition of the Laplacian matrix.\nIf `eigen_tol=\"auto\"` then the passed tolerance will depend on the\n`eigen_solver`:\n\n- If `eigen_solver=\"arpack\"`, then `eigen_tol=0.0`;\n- If `eigen_solver=\"lobpcg\"` or `eigen_solver=\"amg\"`, then\n  `eigen_tol=None` which configures the underlying `lobpcg` solver to\n  automatically resolve the value according to their heuristics. See,\n  :func:`scipy.sparse.linalg.lobpcg` for details.\n\nNote that when using `eigen_solver=\"lobpcg\"` or `eigen_solver=\"amg\"`\nvalues of `tol<1e-5` may lead to convergence issues and should be\navoided.\n\n.. versionadded:: 1.2"
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.manifold._spectral_embedding/SpectralEmbedding/__init__/eigen_solver",
          "name": "eigen_solver",
          "qname": "sklearn.manifold._spectral_embedding.SpectralEmbedding.__init__.eigen_solver",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'arpack', 'lobpcg', 'amg'}",
            "default_value": "None",
            "description": "The eigenvalue decomposition strategy to use. AMG requires pyamg\nto be installed. It can be faster on very large, sparse problems.\nIf None, then ``'arpack'`` is used."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "amg",
              "arpack",
              "lobpcg"
            ]
          }
        },
        "hasCondition": {
          "condition": "If eigen_solver equals lobpcg or eigen_solver"
        },
        "hasAction": {
          "action": "equals amg"
        }
      }
    ]
  },
  "sklearn/sklearn.manifold._spectral_embedding/SpectralEmbedding/_more_tags": {},
  "sklearn/sklearn.manifold._spectral_embedding/SpectralEmbedding/_get_affinity_matrix": {},
  "sklearn/sklearn.manifold._spectral_embedding/SpectralEmbedding/fit": {},
  "sklearn/sklearn.manifold._spectral_embedding/SpectralEmbedding/fit_transform": {},
  "sklearn/sklearn.manifold._t_sne/_joint_probabilities": {},
  "sklearn/sklearn.manifold._t_sne/_joint_probabilities_nn": {},
  "sklearn/sklearn.manifold._t_sne/_kl_divergence": {},
  "sklearn/sklearn.manifold._t_sne/_kl_divergence_bh": {},
  "sklearn/sklearn.manifold._t_sne/_gradient_descent": {},
  "sklearn/sklearn.manifold._t_sne/trustworthiness": {},
  "sklearn/sklearn.manifold._t_sne/TSNE/__init__": {
    "metric": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.manifold._t_sne/TSNE/__init__/metric",
          "name": "metric",
          "qname": "sklearn.manifold._t_sne.TSNE.__init__.metric",
          "default_value": "'euclidean'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'euclidean'",
            "description": "The metric to use when calculating distance between instances in a\nfeature array. If metric is a string, it must be one of the options\nallowed by scipy.spatial.distance.pdist for its metric parameter, or\na metric listed in pairwise.PAIRWISE_DISTANCE_FUNCTIONS.\nIf metric is \"precomputed\", X is assumed to be a distance matrix.\nAlternatively, if metric is a callable function, it is called on each\npair of instances (rows) and the resulting value recorded. The callable\nshould take two arrays from X as input and return a value indicating\nthe distance between them. The default is \"euclidean\" which is\ninterpreted as squared euclidean distance."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.manifold._t_sne/TSNE/__init__/metric",
          "name": "metric",
          "qname": "sklearn.manifold._t_sne.TSNE.__init__.metric",
          "default_value": "'euclidean'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'euclidean'",
            "description": "The metric to use when calculating distance between instances in a\nfeature array. If metric is a string, it must be one of the options\nallowed by scipy.spatial.distance.pdist for its metric parameter, or\na metric listed in pairwise.PAIRWISE_DISTANCE_FUNCTIONS.\nIf metric is \"precomputed\", X is assumed to be a distance matrix.\nAlternatively, if metric is a callable function, it is called on each\npair of instances (rows) and the resulting value recorded. The callable\nshould take two arrays from X as input and return a value indicating\nthe distance between them. The default is \"euclidean\" which is\ninterpreted as squared euclidean distance."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If metric is precomputed"
        },
        "hasAction": {
          "action": ", X is assumed to be a distance matrix"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.manifold._t_sne/TSNE/__init__/metric",
          "name": "metric",
          "qname": "sklearn.manifold._t_sne.TSNE.__init__.metric",
          "default_value": "'euclidean'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'euclidean'",
            "description": "The metric to use when calculating distance between instances in a\nfeature array. If metric is a string, it must be one of the options\nallowed by scipy.spatial.distance.pdist for its metric parameter, or\na metric listed in pairwise.PAIRWISE_DISTANCE_FUNCTIONS.\nIf metric is \"precomputed\", X is assumed to be a distance matrix.\nAlternatively, if metric is a callable function, it is called on each\npair of instances (rows) and the resulting value recorded. The callable\nshould take two arrays from X as input and return a value indicating\nthe distance between them. The default is \"euclidean\" which is\ninterpreted as squared euclidean distance."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.manifold._t_sne/TSNE/__init__/metric",
          "name": "metric",
          "qname": "sklearn.manifold._t_sne.TSNE.__init__.metric",
          "default_value": "'euclidean'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'euclidean'",
            "description": "The metric to use when calculating distance between instances in a\nfeature array. If metric is a string, it must be one of the options\nallowed by scipy.spatial.distance.pdist for its metric parameter, or\na metric listed in pairwise.PAIRWISE_DISTANCE_FUNCTIONS.\nIf metric is \"precomputed\", X is assumed to be a distance matrix.\nAlternatively, if metric is a callable function, it is called on each\npair of instances (rows) and the resulting value recorded. The callable\nshould take two arrays from X as input and return a value indicating\nthe distance between them. The default is \"euclidean\" which is\ninterpreted as squared euclidean distance."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "if metric is a callable function"
        },
        "hasAction": {
          "action": "Alternatively , , it is called on each pair of instances ( rows ) and the resulting value recorded"
        }
      }
    ],
    "angle": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.manifold._t_sne/TSNE/__init__/angle",
          "name": "angle",
          "qname": "sklearn.manifold._t_sne.TSNE.__init__.angle",
          "default_value": "0.5",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "0.5",
            "description": "Only used if method='barnes_hut'\nThis is the trade-off between speed and accuracy for Barnes-Hut T-SNE.\n'angle' is the angular size (referred to as theta in [3]) of a distant\nnode as measured from a point. If this size is below 'angle' then it is\nused as a summary node of all points contained within it.\nThis method is not very sensitive to changes in this parameter\nin the range of 0.2 - 0.8. Angle less than 0.2 has quickly increasing\ncomputation time and angle greater 0.8 has quickly increasing error."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.manifold._t_sne/TSNE/__init__/method",
          "name": "method",
          "qname": "sklearn.manifold._t_sne.TSNE.__init__.method",
          "default_value": "'barnes_hut'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'barnes_hut', 'exact'}",
            "default_value": "'barnes_hut'",
            "description": "By default the gradient calculation algorithm uses Barnes-Hut\napproximation running in O(NlogN) time. method='exact'\nwill run on the slower, but exact, algorithm in O(N^2) time. The\nexact algorithm should be used when nearest-neighbor errors need\nto be better than 3%. However, the exact method cannot scale to\nmillions of examples.\n\n.. versionadded:: 0.17\n   Approximate optimization *method* via the Barnes-Hut."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "barnes_hut",
              "exact"
            ]
          }
        },
        "hasCondition": {
          "condition": "if method equals barnes_hut"
        },
        "hasAction": {
          "action": "Only used"
        }
      }
    ]
  },
  "sklearn/sklearn.manifold._t_sne/TSNE/_check_params_vs_input": {},
  "sklearn/sklearn.manifold._t_sne/TSNE/_fit": {},
  "sklearn/sklearn.manifold._t_sne/TSNE/_tsne": {},
  "sklearn/sklearn.manifold._t_sne/TSNE/fit_transform": {},
  "sklearn/sklearn.manifold._t_sne/TSNE/fit": {},
  "sklearn/sklearn.manifold._t_sne/TSNE/_more_tags": {},
  "sklearn/sklearn.metrics.pairwise/_return_float_dtype": {},
  "sklearn/sklearn.metrics.pairwise/check_pairwise_arrays": {
    "copy": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics.pairwise/check_pairwise_arrays/copy",
          "name": "copy",
          "qname": "sklearn.metrics.pairwise.check_pairwise_arrays.copy",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "Whether a forced copy will be triggered. If copy=False, a copy might\nbe triggered by a conversion.\n\n.. versionadded:: 0.22"
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics.pairwise/check_pairwise_arrays/copy",
          "name": "copy",
          "qname": "sklearn.metrics.pairwise.check_pairwise_arrays.copy",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "Whether a forced copy will be triggered. If copy=False, a copy might\nbe triggered by a conversion.\n\n.. versionadded:: 0.22"
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "If copy equals False"
        },
        "hasAction": {
          "action": ", a copy might be triggered by a conversion"
        }
      }
    ]
  },
  "sklearn/sklearn.metrics.pairwise/check_paired_arrays": {},
  "sklearn/sklearn.metrics.pairwise/euclidean_distances": {},
  "sklearn/sklearn.metrics.pairwise/_euclidean_distances": {},
  "sklearn/sklearn.metrics.pairwise/nan_euclidean_distances": {},
  "sklearn/sklearn.metrics.pairwise/_euclidean_distances_upcast": {},
  "sklearn/sklearn.metrics.pairwise/_argmin_min_reduce": {},
  "sklearn/sklearn.metrics.pairwise/_argmin_reduce": {},
  "sklearn/sklearn.metrics.pairwise/pairwise_distances_argmin_min": {
    "metric": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics.pairwise/pairwise_distances_argmin_min/metric",
          "name": "metric",
          "qname": "sklearn.metrics.pairwise.pairwise_distances_argmin_min.metric",
          "default_value": "'euclidean'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'euclidean'",
            "description": "Metric to use for distance computation. Any metric from scikit-learn\nor scipy.spatial.distance can be used.\n\nIf metric is a callable function, it is called on each\npair of instances (rows) and the resulting value recorded. The callable\nshould take two arrays as input and return one value indicating the\ndistance between them. This works for Scipy's metrics, but is less\nefficient than passing the metric name as a string.\n\nDistance matrices are not supported.\n\nValid values for metric are:\n\n- from scikit-learn: ['cityblock', 'cosine', 'euclidean', 'l1', 'l2',\n  'manhattan']\n\n- from scipy.spatial.distance: ['braycurtis', 'canberra', 'chebyshev',\n  'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski',\n  'mahalanobis', 'minkowski', 'rogerstanimoto', 'russellrao',\n  'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean',\n  'yule']\n\nSee the documentation for scipy.spatial.distance for details on these\nmetrics."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics.pairwise/pairwise_distances_argmin_min/metric",
          "name": "metric",
          "qname": "sklearn.metrics.pairwise.pairwise_distances_argmin_min.metric",
          "default_value": "'euclidean'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'euclidean'",
            "description": "Metric to use for distance computation. Any metric from scikit-learn\nor scipy.spatial.distance can be used.\n\nIf metric is a callable function, it is called on each\npair of instances (rows) and the resulting value recorded. The callable\nshould take two arrays as input and return one value indicating the\ndistance between them. This works for Scipy's metrics, but is less\nefficient than passing the metric name as a string.\n\nDistance matrices are not supported.\n\nValid values for metric are:\n\n- from scikit-learn: ['cityblock', 'cosine', 'euclidean', 'l1', 'l2',\n  'manhattan']\n\n- from scipy.spatial.distance: ['braycurtis', 'canberra', 'chebyshev',\n  'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski',\n  'mahalanobis', 'minkowski', 'rogerstanimoto', 'russellrao',\n  'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean',\n  'yule']\n\nSee the documentation for scipy.spatial.distance for details on these\nmetrics."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If metric is a callable function"
        },
        "hasAction": {
          "action": ", it is called on each pair of instances ( rows ) and the resulting value recorded"
        }
      }
    ]
  },
  "sklearn/sklearn.metrics.pairwise/pairwise_distances_argmin": {
    "metric": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics.pairwise/pairwise_distances_argmin/metric",
          "name": "metric",
          "qname": "sklearn.metrics.pairwise.pairwise_distances_argmin.metric",
          "default_value": "'euclidean'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "\"euclidean\"",
            "description": "Metric to use for distance computation. Any metric from scikit-learn\nor scipy.spatial.distance can be used.\n\nIf metric is a callable function, it is called on each\npair of instances (rows) and the resulting value recorded. The callable\nshould take two arrays as input and return one value indicating the\ndistance between them. This works for Scipy's metrics, but is less\nefficient than passing the metric name as a string.\n\nDistance matrices are not supported.\n\nValid values for metric are:\n\n- from scikit-learn: ['cityblock', 'cosine', 'euclidean', 'l1', 'l2',\n  'manhattan']\n\n- from scipy.spatial.distance: ['braycurtis', 'canberra', 'chebyshev',\n  'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski',\n  'mahalanobis', 'minkowski', 'rogerstanimoto', 'russellrao',\n  'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean',\n  'yule']\n\nSee the documentation for scipy.spatial.distance for details on these\nmetrics."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics.pairwise/pairwise_distances_argmin/metric",
          "name": "metric",
          "qname": "sklearn.metrics.pairwise.pairwise_distances_argmin.metric",
          "default_value": "'euclidean'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "\"euclidean\"",
            "description": "Metric to use for distance computation. Any metric from scikit-learn\nor scipy.spatial.distance can be used.\n\nIf metric is a callable function, it is called on each\npair of instances (rows) and the resulting value recorded. The callable\nshould take two arrays as input and return one value indicating the\ndistance between them. This works for Scipy's metrics, but is less\nefficient than passing the metric name as a string.\n\nDistance matrices are not supported.\n\nValid values for metric are:\n\n- from scikit-learn: ['cityblock', 'cosine', 'euclidean', 'l1', 'l2',\n  'manhattan']\n\n- from scipy.spatial.distance: ['braycurtis', 'canberra', 'chebyshev',\n  'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski',\n  'mahalanobis', 'minkowski', 'rogerstanimoto', 'russellrao',\n  'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean',\n  'yule']\n\nSee the documentation for scipy.spatial.distance for details on these\nmetrics."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If metric is a callable function"
        },
        "hasAction": {
          "action": ", it is called on each pair of instances ( rows ) and the resulting value recorded"
        }
      }
    ]
  },
  "sklearn/sklearn.metrics.pairwise/haversine_distances": {},
  "sklearn/sklearn.metrics.pairwise/manhattan_distances": {},
  "sklearn/sklearn.metrics.pairwise/cosine_distances": {},
  "sklearn/sklearn.metrics.pairwise/paired_euclidean_distances": {},
  "sklearn/sklearn.metrics.pairwise/paired_manhattan_distances": {},
  "sklearn/sklearn.metrics.pairwise/paired_cosine_distances": {},
  "sklearn/sklearn.metrics.pairwise/paired_distances": {
    "metric": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics.pairwise/paired_distances/metric",
          "name": "metric",
          "qname": "sklearn.metrics.pairwise.paired_distances.metric",
          "default_value": "'euclidean'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "\"euclidean\"",
            "description": "The metric to use when calculating distance between instances in a\nfeature array. If metric is a string, it must be one of the options\nspecified in PAIRED_DISTANCES, including \"euclidean\",\n\"manhattan\", or \"cosine\".\nAlternatively, if metric is a callable function, it is called on each\npair of instances (rows) and the resulting value recorded. The callable\nshould take two arrays from `X` as input and return a value indicating\nthe distance between them."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics.pairwise/paired_distances/metric",
          "name": "metric",
          "qname": "sklearn.metrics.pairwise.paired_distances.metric",
          "default_value": "'euclidean'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "\"euclidean\"",
            "description": "The metric to use when calculating distance between instances in a\nfeature array. If metric is a string, it must be one of the options\nspecified in PAIRED_DISTANCES, including \"euclidean\",\n\"manhattan\", or \"cosine\".\nAlternatively, if metric is a callable function, it is called on each\npair of instances (rows) and the resulting value recorded. The callable\nshould take two arrays from `X` as input and return a value indicating\nthe distance between them."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "if metric is a callable function"
        },
        "hasAction": {
          "action": "Alternatively , , it is called on each pair of instances ( rows ) and the resulting value recorded"
        }
      }
    ]
  },
  "sklearn/sklearn.metrics.pairwise/linear_kernel": {},
  "sklearn/sklearn.metrics.pairwise/polynomial_kernel": {},
  "sklearn/sklearn.metrics.pairwise/sigmoid_kernel": {},
  "sklearn/sklearn.metrics.pairwise/rbf_kernel": {},
  "sklearn/sklearn.metrics.pairwise/laplacian_kernel": {},
  "sklearn/sklearn.metrics.pairwise/cosine_similarity": {},
  "sklearn/sklearn.metrics.pairwise/additive_chi2_kernel": {},
  "sklearn/sklearn.metrics.pairwise/chi2_kernel": {},
  "sklearn/sklearn.metrics.pairwise/distance_metrics": {},
  "sklearn/sklearn.metrics.pairwise/_dist_wrapper": {},
  "sklearn/sklearn.metrics.pairwise/_parallel_pairwise": {},
  "sklearn/sklearn.metrics.pairwise/_pairwise_callable": {},
  "sklearn/sklearn.metrics.pairwise/_check_chunk_size": {},
  "sklearn/sklearn.metrics.pairwise/_precompute_metric_params": {},
  "sklearn/sklearn.metrics.pairwise/pairwise_distances_chunked": {
    "metric": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics.pairwise/pairwise_distances_chunked/metric",
          "name": "metric",
          "qname": "sklearn.metrics.pairwise.pairwise_distances_chunked.metric",
          "default_value": "'euclidean'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'euclidean'",
            "description": "The metric to use when calculating distance between instances in a\nfeature array. If metric is a string, it must be one of the options\nallowed by scipy.spatial.distance.pdist for its metric parameter,\nor a metric listed in pairwise.PAIRWISE_DISTANCE_FUNCTIONS.\nIf metric is \"precomputed\", X is assumed to be a distance matrix.\nAlternatively, if metric is a callable function, it is called on\neach pair of instances (rows) and the resulting value recorded.\nThe callable should take two arrays from X as input and return a\nvalue indicating the distance between them."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics.pairwise/pairwise_distances_chunked/metric",
          "name": "metric",
          "qname": "sklearn.metrics.pairwise.pairwise_distances_chunked.metric",
          "default_value": "'euclidean'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'euclidean'",
            "description": "The metric to use when calculating distance between instances in a\nfeature array. If metric is a string, it must be one of the options\nallowed by scipy.spatial.distance.pdist for its metric parameter,\nor a metric listed in pairwise.PAIRWISE_DISTANCE_FUNCTIONS.\nIf metric is \"precomputed\", X is assumed to be a distance matrix.\nAlternatively, if metric is a callable function, it is called on\neach pair of instances (rows) and the resulting value recorded.\nThe callable should take two arrays from X as input and return a\nvalue indicating the distance between them."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If metric is precomputed"
        },
        "hasAction": {
          "action": ", X is assumed to be a distance matrix"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics.pairwise/pairwise_distances_chunked/metric",
          "name": "metric",
          "qname": "sklearn.metrics.pairwise.pairwise_distances_chunked.metric",
          "default_value": "'euclidean'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'euclidean'",
            "description": "The metric to use when calculating distance between instances in a\nfeature array. If metric is a string, it must be one of the options\nallowed by scipy.spatial.distance.pdist for its metric parameter,\nor a metric listed in pairwise.PAIRWISE_DISTANCE_FUNCTIONS.\nIf metric is \"precomputed\", X is assumed to be a distance matrix.\nAlternatively, if metric is a callable function, it is called on\neach pair of instances (rows) and the resulting value recorded.\nThe callable should take two arrays from X as input and return a\nvalue indicating the distance between them."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics.pairwise/pairwise_distances_chunked/metric",
          "name": "metric",
          "qname": "sklearn.metrics.pairwise.pairwise_distances_chunked.metric",
          "default_value": "'euclidean'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'euclidean'",
            "description": "The metric to use when calculating distance between instances in a\nfeature array. If metric is a string, it must be one of the options\nallowed by scipy.spatial.distance.pdist for its metric parameter,\nor a metric listed in pairwise.PAIRWISE_DISTANCE_FUNCTIONS.\nIf metric is \"precomputed\", X is assumed to be a distance matrix.\nAlternatively, if metric is a callable function, it is called on\neach pair of instances (rows) and the resulting value recorded.\nThe callable should take two arrays from X as input and return a\nvalue indicating the distance between them."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "if metric is a callable function"
        },
        "hasAction": {
          "action": "Alternatively , , it is called on each pair of instances ( rows ) and the resulting value recorded"
        }
      }
    ]
  },
  "sklearn/sklearn.metrics.pairwise/pairwise_distances": {
    "metric": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics.pairwise/pairwise_distances/metric",
          "name": "metric",
          "qname": "sklearn.metrics.pairwise.pairwise_distances.metric",
          "default_value": "'euclidean'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'euclidean'",
            "description": "The metric to use when calculating distance between instances in a\nfeature array. If metric is a string, it must be one of the options\nallowed by scipy.spatial.distance.pdist for its metric parameter, or\na metric listed in ``pairwise.PAIRWISE_DISTANCE_FUNCTIONS``.\nIf metric is \"precomputed\", X is assumed to be a distance matrix.\nAlternatively, if metric is a callable function, it is called on each\npair of instances (rows) and the resulting value recorded. The callable\nshould take two arrays from X as input and return a value indicating\nthe distance between them."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics.pairwise/pairwise_distances/metric",
          "name": "metric",
          "qname": "sklearn.metrics.pairwise.pairwise_distances.metric",
          "default_value": "'euclidean'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'euclidean'",
            "description": "The metric to use when calculating distance between instances in a\nfeature array. If metric is a string, it must be one of the options\nallowed by scipy.spatial.distance.pdist for its metric parameter, or\na metric listed in ``pairwise.PAIRWISE_DISTANCE_FUNCTIONS``.\nIf metric is \"precomputed\", X is assumed to be a distance matrix.\nAlternatively, if metric is a callable function, it is called on each\npair of instances (rows) and the resulting value recorded. The callable\nshould take two arrays from X as input and return a value indicating\nthe distance between them."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If metric is precomputed"
        },
        "hasAction": {
          "action": ", X is assumed to be a distance matrix"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics.pairwise/pairwise_distances/metric",
          "name": "metric",
          "qname": "sklearn.metrics.pairwise.pairwise_distances.metric",
          "default_value": "'euclidean'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'euclidean'",
            "description": "The metric to use when calculating distance between instances in a\nfeature array. If metric is a string, it must be one of the options\nallowed by scipy.spatial.distance.pdist for its metric parameter, or\na metric listed in ``pairwise.PAIRWISE_DISTANCE_FUNCTIONS``.\nIf metric is \"precomputed\", X is assumed to be a distance matrix.\nAlternatively, if metric is a callable function, it is called on each\npair of instances (rows) and the resulting value recorded. The callable\nshould take two arrays from X as input and return a value indicating\nthe distance between them."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics.pairwise/pairwise_distances/metric",
          "name": "metric",
          "qname": "sklearn.metrics.pairwise.pairwise_distances.metric",
          "default_value": "'euclidean'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'euclidean'",
            "description": "The metric to use when calculating distance between instances in a\nfeature array. If metric is a string, it must be one of the options\nallowed by scipy.spatial.distance.pdist for its metric parameter, or\na metric listed in ``pairwise.PAIRWISE_DISTANCE_FUNCTIONS``.\nIf metric is \"precomputed\", X is assumed to be a distance matrix.\nAlternatively, if metric is a callable function, it is called on each\npair of instances (rows) and the resulting value recorded. The callable\nshould take two arrays from X as input and return a value indicating\nthe distance between them."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "if metric is a callable function"
        },
        "hasAction": {
          "action": "Alternatively , , it is called on each pair of instances ( rows ) and the resulting value recorded"
        }
      }
    ]
  },
  "sklearn/sklearn.metrics.pairwise/kernel_metrics": {},
  "sklearn/sklearn.metrics.pairwise/pairwise_kernels": {
    "metric": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics.pairwise/pairwise_kernels/metric",
          "name": "metric",
          "qname": "sklearn.metrics.pairwise.pairwise_kernels.metric",
          "default_value": "'linear'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "\"linear\"",
            "description": "The metric to use when calculating kernel between instances in a\nfeature array. If metric is a string, it must be one of the metrics\nin pairwise.PAIRWISE_KERNEL_FUNCTIONS.\nIf metric is \"precomputed\", X is assumed to be a kernel matrix.\nAlternatively, if metric is a callable function, it is called on each\npair of instances (rows) and the resulting value recorded. The callable\nshould take two rows from X as input and return the corresponding\nkernel value as a single number. This means that callables from\n:mod:`sklearn.metrics.pairwise` are not allowed, as they operate on\nmatrices, not single samples. Use the string identifying the kernel\ninstead."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics.pairwise/pairwise_kernels/metric",
          "name": "metric",
          "qname": "sklearn.metrics.pairwise.pairwise_kernels.metric",
          "default_value": "'linear'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "\"linear\"",
            "description": "The metric to use when calculating kernel between instances in a\nfeature array. If metric is a string, it must be one of the metrics\nin pairwise.PAIRWISE_KERNEL_FUNCTIONS.\nIf metric is \"precomputed\", X is assumed to be a kernel matrix.\nAlternatively, if metric is a callable function, it is called on each\npair of instances (rows) and the resulting value recorded. The callable\nshould take two rows from X as input and return the corresponding\nkernel value as a single number. This means that callables from\n:mod:`sklearn.metrics.pairwise` are not allowed, as they operate on\nmatrices, not single samples. Use the string identifying the kernel\ninstead."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If metric is precomputed"
        },
        "hasAction": {
          "action": ", X is assumed to be a kernel matrix"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics.pairwise/pairwise_kernels/metric",
          "name": "metric",
          "qname": "sklearn.metrics.pairwise.pairwise_kernels.metric",
          "default_value": "'linear'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "\"linear\"",
            "description": "The metric to use when calculating kernel between instances in a\nfeature array. If metric is a string, it must be one of the metrics\nin pairwise.PAIRWISE_KERNEL_FUNCTIONS.\nIf metric is \"precomputed\", X is assumed to be a kernel matrix.\nAlternatively, if metric is a callable function, it is called on each\npair of instances (rows) and the resulting value recorded. The callable\nshould take two rows from X as input and return the corresponding\nkernel value as a single number. This means that callables from\n:mod:`sklearn.metrics.pairwise` are not allowed, as they operate on\nmatrices, not single samples. Use the string identifying the kernel\ninstead."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics.pairwise/pairwise_kernels/metric",
          "name": "metric",
          "qname": "sklearn.metrics.pairwise.pairwise_kernels.metric",
          "default_value": "'linear'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "\"linear\"",
            "description": "The metric to use when calculating kernel between instances in a\nfeature array. If metric is a string, it must be one of the metrics\nin pairwise.PAIRWISE_KERNEL_FUNCTIONS.\nIf metric is \"precomputed\", X is assumed to be a kernel matrix.\nAlternatively, if metric is a callable function, it is called on each\npair of instances (rows) and the resulting value recorded. The callable\nshould take two rows from X as input and return the corresponding\nkernel value as a single number. This means that callables from\n:mod:`sklearn.metrics.pairwise` are not allowed, as they operate on\nmatrices, not single samples. Use the string identifying the kernel\ninstead."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "if metric is a callable function"
        },
        "hasAction": {
          "action": "Alternatively , , it is called on each pair of instances ( rows ) and the resulting value recorded"
        }
      }
    ]
  },
  "sklearn/sklearn.metrics._base/_average_binary_score": {
    "average": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics._base/_average_binary_score/average",
          "name": "average",
          "qname": "sklearn.metrics._base._average_binary_score.average",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "{None, 'micro', 'macro', 'samples', 'weighted'}",
            "default_value": "'macro'",
            "description": "If ``None``, the scores for each class are returned. Otherwise,\nthis determines the type of averaging performed on the data:\n\n``'micro'``:\n    Calculate metrics globally by considering each element of the label\n    indicator matrix as a label.\n``'macro'``:\n    Calculate metrics for each label, and find their unweighted\n    mean.  This does not take label imbalance into account.\n``'weighted'``:\n    Calculate metrics for each label, and find their average, weighted\n    by support (the number of true instances for each label).\n``'samples'``:\n    Calculate metrics for each instance, and find their average.\n\nWill be ignored when ``y_true`` is binary."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "macro",
              "micro",
              "samples",
              "weighted"
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics._base/_average_binary_score/y_true",
          "name": "y_true",
          "qname": "sklearn.metrics._base._average_binary_score.y_true",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "array, shape = [n_samples] or [n_samples, n_classes]",
            "default_value": "",
            "description": "True binary labels in binary label indicators."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array"
              },
              {
                "kind": "NamedType",
                "name": "shape = [n_samples]"
              },
              {
                "kind": "NamedType",
                "name": "[n_samples"
              },
              {
                "kind": "NamedType",
                "name": "n_classes]"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "when y_true is binary"
        },
        "hasAction": {
          "action": "Will be ignored"
        }
      }
    ]
  },
  "sklearn/sklearn.metrics._base/_average_multiclass_ovo_score": {},
  "sklearn/sklearn.metrics._base/_check_pos_label_consistency": {},
  "sklearn/sklearn.metrics._classification/_check_zero_division": {},
  "sklearn/sklearn.metrics._classification/_check_targets": {},
  "sklearn/sklearn.metrics._classification/_weighted_sum": {},
  "sklearn/sklearn.metrics._classification/accuracy_score": {},
  "sklearn/sklearn.metrics._classification/confusion_matrix": {},
  "sklearn/sklearn.metrics._classification/multilabel_confusion_matrix": {},
  "sklearn/sklearn.metrics._classification/cohen_kappa_score": {},
  "sklearn/sklearn.metrics._classification/jaccard_score": {
    "labels": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics._classification/jaccard_score/labels",
          "name": "labels",
          "qname": "sklearn.metrics._classification.jaccard_score.labels",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "array-like of shape (n_classes,)",
            "default_value": "None",
            "description": "The set of labels to include when ``average != 'binary'``, and their\norder if ``average is None``. Labels present in the data can be\nexcluded, for example to calculate a multiclass average ignoring a\nmajority negative class, while labels not present in the data will\nresult in 0 components in a macro average. For multilabel targets,\nlabels are column indices. By default, all labels in ``y_true`` and\n``y_pred`` are used in sorted order."
          },
          "type": {
            "kind": "NamedType",
            "name": "array-like of shape (n_classes,)"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics._classification/jaccard_score/labels",
          "name": "labels",
          "qname": "sklearn.metrics._classification.jaccard_score.labels",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "array-like of shape (n_classes,)",
            "default_value": "None",
            "description": "The set of labels to include when ``average != 'binary'``, and their\norder if ``average is None``. Labels present in the data can be\nexcluded, for example to calculate a multiclass average ignoring a\nmajority negative class, while labels not present in the data will\nresult in 0 components in a macro average. For multilabel targets,\nlabels are column indices. By default, all labels in ``y_true`` and\n``y_pred`` are used in sorted order."
          },
          "type": {
            "kind": "NamedType",
            "name": "array-like of shape (n_classes,)"
          }
        },
        "hasCondition": {
          "condition": "while labels not present in the data will result in 0 components in a macro average"
        },
        "hasAction": {
          "action": "Labels present in the data can be excluded , for example to calculate a multiclass average ignoring a majority negative class ,"
        }
      }
    ],
    "pos_label": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics._classification/jaccard_score/pos_label",
          "name": "pos_label",
          "qname": "sklearn.metrics._classification.jaccard_score.pos_label",
          "default_value": "1",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or int",
            "default_value": "1",
            "description": "The class to report if ``average='binary'`` and the data is binary.\nIf the data are multiclass or multilabel, this will be ignored;\nsetting ``labels=[pos_label]`` and ``average != 'binary'`` will report\nscores for that label only."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "int"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics._classification/jaccard_score/average",
          "name": "average",
          "qname": "sklearn.metrics._classification.jaccard_score.average",
          "default_value": "'binary'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'micro', 'macro', 'samples', 'weighted',             'binary'} or None",
            "default_value": "'binary'",
            "description": "If ``None``, the scores for each class are returned. Otherwise, this\ndetermines the type of averaging performed on the data:\n\n``'binary'``:\n    Only report results for the class specified by ``pos_label``.\n    This is applicable only if targets (``y_{true,pred}``) are binary.\n``'micro'``:\n    Calculate metrics globally by counting the total true positives,\n    false negatives and false positives.\n``'macro'``:\n    Calculate metrics for each label, and find their unweighted\n    mean.  This does not take label imbalance into account.\n``'weighted'``:\n    Calculate metrics for each label, and find their average, weighted\n    by support (the number of true instances for each label). This\n    alters 'macro' to account for label imbalance.\n``'samples'``:\n    Calculate metrics for each instance, and find their average (only\n    meaningful for multilabel classification)."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "EnumType",
                "values": [
                  "samples",
                  "micro",
                  "macro",
                  "binary",
                  "weighted"
                ]
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "if average equals binary and"
        },
        "hasAction": {
          "action": "to report"
        }
      }
    ]
  },
  "sklearn/sklearn.metrics._classification/matthews_corrcoef": {},
  "sklearn/sklearn.metrics._classification/zero_one_loss": {},
  "sklearn/sklearn.metrics._classification/f1_score": {
    "labels": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics._classification/f1_score/labels",
          "name": "labels",
          "qname": "sklearn.metrics._classification.f1_score.labels",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "array-like",
            "default_value": "None",
            "description": "The set of labels to include when ``average != 'binary'``, and their\norder if ``average is None``. Labels present in the data can be\nexcluded, for example to calculate a multiclass average ignoring a\nmajority negative class, while labels not present in the data will\nresult in 0 components in a macro average. For multilabel targets,\nlabels are column indices. By default, all labels in ``y_true`` and\n``y_pred`` are used in sorted order.\n\n.. versionchanged:: 0.17\n   Parameter `labels` improved for multiclass problem."
          },
          "type": {
            "kind": "NamedType",
            "name": "array-like"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics._classification/f1_score/labels",
          "name": "labels",
          "qname": "sklearn.metrics._classification.f1_score.labels",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "array-like",
            "default_value": "None",
            "description": "The set of labels to include when ``average != 'binary'``, and their\norder if ``average is None``. Labels present in the data can be\nexcluded, for example to calculate a multiclass average ignoring a\nmajority negative class, while labels not present in the data will\nresult in 0 components in a macro average. For multilabel targets,\nlabels are column indices. By default, all labels in ``y_true`` and\n``y_pred`` are used in sorted order.\n\n.. versionchanged:: 0.17\n   Parameter `labels` improved for multiclass problem."
          },
          "type": {
            "kind": "NamedType",
            "name": "array-like"
          }
        },
        "hasCondition": {
          "condition": "while labels not present in the data will result in 0 components in a macro average"
        },
        "hasAction": {
          "action": "Labels present in the data can be excluded , for example to calculate a multiclass average ignoring a majority negative class ,"
        }
      }
    ],
    "pos_label": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics._classification/f1_score/pos_label",
          "name": "pos_label",
          "qname": "sklearn.metrics._classification.f1_score.pos_label",
          "default_value": "1",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or int",
            "default_value": "1",
            "description": "The class to report if ``average='binary'`` and the data is binary.\nIf the data are multiclass or multilabel, this will be ignored;\nsetting ``labels=[pos_label]`` and ``average != 'binary'`` will report\nscores for that label only."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "int"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics._classification/f1_score/average",
          "name": "average",
          "qname": "sklearn.metrics._classification.f1_score.average",
          "default_value": "'binary'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'micro', 'macro', 'samples', 'weighted', 'binary'} or None",
            "default_value": "'binary'",
            "description": "This parameter is required for multiclass/multilabel targets.\nIf ``None``, the scores for each class are returned. Otherwise, this\ndetermines the type of averaging performed on the data:\n\n``'binary'``:\n    Only report results for the class specified by ``pos_label``.\n    This is applicable only if targets (``y_{true,pred}``) are binary.\n``'micro'``:\n    Calculate metrics globally by counting the total true positives,\n    false negatives and false positives.\n``'macro'``:\n    Calculate metrics for each label, and find their unweighted\n    mean.  This does not take label imbalance into account.\n``'weighted'``:\n    Calculate metrics for each label, and find their average weighted\n    by support (the number of true instances for each label). This\n    alters 'macro' to account for label imbalance; it can result in an\n    F-score that is not between precision and recall.\n``'samples'``:\n    Calculate metrics for each instance, and find their average (only\n    meaningful for multilabel classification where this differs from\n    :func:`accuracy_score`)."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "EnumType",
                "values": [
                  "samples",
                  "micro",
                  "macro",
                  "binary",
                  "weighted"
                ]
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "if average equals binary and"
        },
        "hasAction": {
          "action": "to report"
        }
      }
    ]
  },
  "sklearn/sklearn.metrics._classification/fbeta_score": {
    "labels": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics._classification/fbeta_score/labels",
          "name": "labels",
          "qname": "sklearn.metrics._classification.fbeta_score.labels",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "array-like",
            "default_value": "None",
            "description": "The set of labels to include when ``average != 'binary'``, and their\norder if ``average is None``. Labels present in the data can be\nexcluded, for example to calculate a multiclass average ignoring a\nmajority negative class, while labels not present in the data will\nresult in 0 components in a macro average. For multilabel targets,\nlabels are column indices. By default, all labels in ``y_true`` and\n``y_pred`` are used in sorted order.\n\n.. versionchanged:: 0.17\n   Parameter `labels` improved for multiclass problem."
          },
          "type": {
            "kind": "NamedType",
            "name": "array-like"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics._classification/fbeta_score/labels",
          "name": "labels",
          "qname": "sklearn.metrics._classification.fbeta_score.labels",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "array-like",
            "default_value": "None",
            "description": "The set of labels to include when ``average != 'binary'``, and their\norder if ``average is None``. Labels present in the data can be\nexcluded, for example to calculate a multiclass average ignoring a\nmajority negative class, while labels not present in the data will\nresult in 0 components in a macro average. For multilabel targets,\nlabels are column indices. By default, all labels in ``y_true`` and\n``y_pred`` are used in sorted order.\n\n.. versionchanged:: 0.17\n   Parameter `labels` improved for multiclass problem."
          },
          "type": {
            "kind": "NamedType",
            "name": "array-like"
          }
        },
        "hasCondition": {
          "condition": "while labels not present in the data will result in 0 components in a macro average"
        },
        "hasAction": {
          "action": "Labels present in the data can be excluded , for example to calculate a multiclass average ignoring a majority negative class ,"
        }
      }
    ],
    "pos_label": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics._classification/fbeta_score/pos_label",
          "name": "pos_label",
          "qname": "sklearn.metrics._classification.fbeta_score.pos_label",
          "default_value": "1",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or int",
            "default_value": "1",
            "description": "The class to report if ``average='binary'`` and the data is binary.\nIf the data are multiclass or multilabel, this will be ignored;\nsetting ``labels=[pos_label]`` and ``average != 'binary'`` will report\nscores for that label only."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "int"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics._classification/fbeta_score/average",
          "name": "average",
          "qname": "sklearn.metrics._classification.fbeta_score.average",
          "default_value": "'binary'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'micro', 'macro', 'samples', 'weighted', 'binary'} or None",
            "default_value": "'binary'",
            "description": "This parameter is required for multiclass/multilabel targets.\nIf ``None``, the scores for each class are returned. Otherwise, this\ndetermines the type of averaging performed on the data:\n\n``'binary'``:\n    Only report results for the class specified by ``pos_label``.\n    This is applicable only if targets (``y_{true,pred}``) are binary.\n``'micro'``:\n    Calculate metrics globally by counting the total true positives,\n    false negatives and false positives.\n``'macro'``:\n    Calculate metrics for each label, and find their unweighted\n    mean.  This does not take label imbalance into account.\n``'weighted'``:\n    Calculate metrics for each label, and find their average weighted\n    by support (the number of true instances for each label). This\n    alters 'macro' to account for label imbalance; it can result in an\n    F-score that is not between precision and recall.\n``'samples'``:\n    Calculate metrics for each instance, and find their average (only\n    meaningful for multilabel classification where this differs from\n    :func:`accuracy_score`)."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "EnumType",
                "values": [
                  "samples",
                  "micro",
                  "macro",
                  "binary",
                  "weighted"
                ]
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "if average equals binary and"
        },
        "hasAction": {
          "action": "to report"
        }
      }
    ]
  },
  "sklearn/sklearn.metrics._classification/_prf_divide": {},
  "sklearn/sklearn.metrics._classification/_warn_prf": {},
  "sklearn/sklearn.metrics._classification/_check_set_wise_labels": {},
  "sklearn/sklearn.metrics._classification/precision_recall_fscore_support": {
    "labels": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics._classification/precision_recall_fscore_support/labels",
          "name": "labels",
          "qname": "sklearn.metrics._classification.precision_recall_fscore_support.labels",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "array-like",
            "default_value": "None",
            "description": "The set of labels to include when ``average != 'binary'``, and their\norder if ``average is None``. Labels present in the data can be\nexcluded, for example to calculate a multiclass average ignoring a\nmajority negative class, while labels not present in the data will\nresult in 0 components in a macro average. For multilabel targets,\nlabels are column indices. By default, all labels in ``y_true`` and\n``y_pred`` are used in sorted order."
          },
          "type": {
            "kind": "NamedType",
            "name": "array-like"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics._classification/precision_recall_fscore_support/labels",
          "name": "labels",
          "qname": "sklearn.metrics._classification.precision_recall_fscore_support.labels",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "array-like",
            "default_value": "None",
            "description": "The set of labels to include when ``average != 'binary'``, and their\norder if ``average is None``. Labels present in the data can be\nexcluded, for example to calculate a multiclass average ignoring a\nmajority negative class, while labels not present in the data will\nresult in 0 components in a macro average. For multilabel targets,\nlabels are column indices. By default, all labels in ``y_true`` and\n``y_pred`` are used in sorted order."
          },
          "type": {
            "kind": "NamedType",
            "name": "array-like"
          }
        },
        "hasCondition": {
          "condition": "while labels not present in the data will result in 0 components in a macro average"
        },
        "hasAction": {
          "action": "Labels present in the data can be excluded , for example to calculate a multiclass average ignoring a majority negative class ,"
        }
      }
    ],
    "pos_label": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics._classification/precision_recall_fscore_support/pos_label",
          "name": "pos_label",
          "qname": "sklearn.metrics._classification.precision_recall_fscore_support.pos_label",
          "default_value": "1",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or int",
            "default_value": "1",
            "description": "The class to report if ``average='binary'`` and the data is binary.\nIf the data are multiclass or multilabel, this will be ignored;\nsetting ``labels=[pos_label]`` and ``average != 'binary'`` will report\nscores for that label only."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "int"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics._classification/precision_recall_fscore_support/average",
          "name": "average",
          "qname": "sklearn.metrics._classification.precision_recall_fscore_support.average",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'binary', 'micro', 'macro', 'samples', 'weighted'}",
            "default_value": "None",
            "description": "If ``None``, the scores for each class are returned. Otherwise, this\ndetermines the type of averaging performed on the data:\n\n``'binary'``:\n    Only report results for the class specified by ``pos_label``.\n    This is applicable only if targets (``y_{true,pred}``) are binary.\n``'micro'``:\n    Calculate metrics globally by counting the total true positives,\n    false negatives and false positives.\n``'macro'``:\n    Calculate metrics for each label, and find their unweighted\n    mean.  This does not take label imbalance into account.\n``'weighted'``:\n    Calculate metrics for each label, and find their average weighted\n    by support (the number of true instances for each label). This\n    alters 'macro' to account for label imbalance; it can result in an\n    F-score that is not between precision and recall.\n``'samples'``:\n    Calculate metrics for each instance, and find their average (only\n    meaningful for multilabel classification where this differs from\n    :func:`accuracy_score`)."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "samples",
              "micro",
              "macro",
              "binary",
              "weighted"
            ]
          }
        },
        "hasCondition": {
          "condition": "if average equals binary and"
        },
        "hasAction": {
          "action": "to report"
        }
      }
    ]
  },
  "sklearn/sklearn.metrics._classification/class_likelihood_ratios": {},
  "sklearn/sklearn.metrics._classification/precision_score": {
    "labels": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics._classification/precision_score/labels",
          "name": "labels",
          "qname": "sklearn.metrics._classification.precision_score.labels",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "array-like",
            "default_value": "None",
            "description": "The set of labels to include when ``average != 'binary'``, and their\norder if ``average is None``. Labels present in the data can be\nexcluded, for example to calculate a multiclass average ignoring a\nmajority negative class, while labels not present in the data will\nresult in 0 components in a macro average. For multilabel targets,\nlabels are column indices. By default, all labels in ``y_true`` and\n``y_pred`` are used in sorted order.\n\n.. versionchanged:: 0.17\n   Parameter `labels` improved for multiclass problem."
          },
          "type": {
            "kind": "NamedType",
            "name": "array-like"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics._classification/precision_score/labels",
          "name": "labels",
          "qname": "sklearn.metrics._classification.precision_score.labels",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "array-like",
            "default_value": "None",
            "description": "The set of labels to include when ``average != 'binary'``, and their\norder if ``average is None``. Labels present in the data can be\nexcluded, for example to calculate a multiclass average ignoring a\nmajority negative class, while labels not present in the data will\nresult in 0 components in a macro average. For multilabel targets,\nlabels are column indices. By default, all labels in ``y_true`` and\n``y_pred`` are used in sorted order.\n\n.. versionchanged:: 0.17\n   Parameter `labels` improved for multiclass problem."
          },
          "type": {
            "kind": "NamedType",
            "name": "array-like"
          }
        },
        "hasCondition": {
          "condition": "while labels not present in the data will result in 0 components in a macro average"
        },
        "hasAction": {
          "action": "Labels present in the data can be excluded , for example to calculate a multiclass average ignoring a majority negative class ,"
        }
      }
    ],
    "pos_label": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics._classification/precision_score/pos_label",
          "name": "pos_label",
          "qname": "sklearn.metrics._classification.precision_score.pos_label",
          "default_value": "1",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or int",
            "default_value": "1",
            "description": "The class to report if ``average='binary'`` and the data is binary.\nIf the data are multiclass or multilabel, this will be ignored;\nsetting ``labels=[pos_label]`` and ``average != 'binary'`` will report\nscores for that label only."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "int"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics._classification/precision_score/average",
          "name": "average",
          "qname": "sklearn.metrics._classification.precision_score.average",
          "default_value": "'binary'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'micro', 'macro', 'samples', 'weighted', 'binary'} or None",
            "default_value": "'binary'",
            "description": "This parameter is required for multiclass/multilabel targets.\nIf ``None``, the scores for each class are returned. Otherwise, this\ndetermines the type of averaging performed on the data:\n\n``'binary'``:\n    Only report results for the class specified by ``pos_label``.\n    This is applicable only if targets (``y_{true,pred}``) are binary.\n``'micro'``:\n    Calculate metrics globally by counting the total true positives,\n    false negatives and false positives.\n``'macro'``:\n    Calculate metrics for each label, and find their unweighted\n    mean.  This does not take label imbalance into account.\n``'weighted'``:\n    Calculate metrics for each label, and find their average weighted\n    by support (the number of true instances for each label). This\n    alters 'macro' to account for label imbalance; it can result in an\n    F-score that is not between precision and recall.\n``'samples'``:\n    Calculate metrics for each instance, and find their average (only\n    meaningful for multilabel classification where this differs from\n    :func:`accuracy_score`)."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "EnumType",
                "values": [
                  "samples",
                  "micro",
                  "macro",
                  "binary",
                  "weighted"
                ]
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "if average equals binary and"
        },
        "hasAction": {
          "action": "to report"
        }
      }
    ]
  },
  "sklearn/sklearn.metrics._classification/recall_score": {
    "labels": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics._classification/recall_score/labels",
          "name": "labels",
          "qname": "sklearn.metrics._classification.recall_score.labels",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "array-like",
            "default_value": "None",
            "description": "The set of labels to include when ``average != 'binary'``, and their\norder if ``average is None``. Labels present in the data can be\nexcluded, for example to calculate a multiclass average ignoring a\nmajority negative class, while labels not present in the data will\nresult in 0 components in a macro average. For multilabel targets,\nlabels are column indices. By default, all labels in ``y_true`` and\n``y_pred`` are used in sorted order.\n\n.. versionchanged:: 0.17\n   Parameter `labels` improved for multiclass problem."
          },
          "type": {
            "kind": "NamedType",
            "name": "array-like"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics._classification/recall_score/labels",
          "name": "labels",
          "qname": "sklearn.metrics._classification.recall_score.labels",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "array-like",
            "default_value": "None",
            "description": "The set of labels to include when ``average != 'binary'``, and their\norder if ``average is None``. Labels present in the data can be\nexcluded, for example to calculate a multiclass average ignoring a\nmajority negative class, while labels not present in the data will\nresult in 0 components in a macro average. For multilabel targets,\nlabels are column indices. By default, all labels in ``y_true`` and\n``y_pred`` are used in sorted order.\n\n.. versionchanged:: 0.17\n   Parameter `labels` improved for multiclass problem."
          },
          "type": {
            "kind": "NamedType",
            "name": "array-like"
          }
        },
        "hasCondition": {
          "condition": "while labels not present in the data will result in 0 components in a macro average"
        },
        "hasAction": {
          "action": "Labels present in the data can be excluded , for example to calculate a multiclass average ignoring a majority negative class ,"
        }
      }
    ],
    "pos_label": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics._classification/recall_score/pos_label",
          "name": "pos_label",
          "qname": "sklearn.metrics._classification.recall_score.pos_label",
          "default_value": "1",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or int",
            "default_value": "1",
            "description": "The class to report if ``average='binary'`` and the data is binary.\nIf the data are multiclass or multilabel, this will be ignored;\nsetting ``labels=[pos_label]`` and ``average != 'binary'`` will report\nscores for that label only."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "int"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics._classification/recall_score/average",
          "name": "average",
          "qname": "sklearn.metrics._classification.recall_score.average",
          "default_value": "'binary'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'micro', 'macro', 'samples', 'weighted', 'binary'} or None",
            "default_value": "'binary'",
            "description": "This parameter is required for multiclass/multilabel targets.\nIf ``None``, the scores for each class are returned. Otherwise, this\ndetermines the type of averaging performed on the data:\n\n``'binary'``:\n    Only report results for the class specified by ``pos_label``.\n    This is applicable only if targets (``y_{true,pred}``) are binary.\n``'micro'``:\n    Calculate metrics globally by counting the total true positives,\n    false negatives and false positives.\n``'macro'``:\n    Calculate metrics for each label, and find their unweighted\n    mean.  This does not take label imbalance into account.\n``'weighted'``:\n    Calculate metrics for each label, and find their average weighted\n    by support (the number of true instances for each label). This\n    alters 'macro' to account for label imbalance; it can result in an\n    F-score that is not between precision and recall. Weighted recall\n    is equal to accuracy.\n``'samples'``:\n    Calculate metrics for each instance, and find their average (only\n    meaningful for multilabel classification where this differs from\n    :func:`accuracy_score`)."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "EnumType",
                "values": [
                  "samples",
                  "micro",
                  "macro",
                  "binary",
                  "weighted"
                ]
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "if average equals binary and"
        },
        "hasAction": {
          "action": "to report"
        }
      }
    ]
  },
  "sklearn/sklearn.metrics._classification/balanced_accuracy_score": {},
  "sklearn/sklearn.metrics._classification/classification_report": {
    "digits": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics._classification/classification_report/digits",
          "name": "digits",
          "qname": "sklearn.metrics._classification.classification_report.digits",
          "default_value": "2",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "2",
            "description": "Number of digits for formatting output floating point values.\nWhen ``output_dict`` is ``True``, this will be ignored and the\nreturned values will not be rounded."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics._classification/classification_report/output_dict",
          "name": "output_dict",
          "qname": "sklearn.metrics._classification.classification_report.output_dict",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "If True, return output as dict.\n\n.. versionadded:: 0.20"
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "When output_dict is True"
        },
        "hasAction": {
          "action": ", this will be ignored and the returned values will not be rounded"
        }
      }
    ]
  },
  "sklearn/sklearn.metrics._classification/hamming_loss": {},
  "sklearn/sklearn.metrics._classification/log_loss": {
    "labels": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics._classification/log_loss/labels",
          "name": "labels",
          "qname": "sklearn.metrics._classification.log_loss.labels",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "array-like",
            "default_value": "None",
            "description": "If not provided, labels will be inferred from y_true. If ``labels``\nis ``None`` and ``y_pred`` has shape (n_samples,) the labels are\nassumed to be binary and are inferred from ``y_true``.\n\n.. versionadded:: 0.18"
          },
          "type": {
            "kind": "NamedType",
            "name": "array-like"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics._classification/log_loss/labels",
          "name": "labels",
          "qname": "sklearn.metrics._classification.log_loss.labels",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "array-like",
            "default_value": "None",
            "description": "If not provided, labels will be inferred from y_true. If ``labels``\nis ``None`` and ``y_pred`` has shape (n_samples,) the labels are\nassumed to be binary and are inferred from ``y_true``.\n\n.. versionadded:: 0.18"
          },
          "type": {
            "kind": "NamedType",
            "name": "array-like"
          }
        },
        "hasCondition": {
          "condition": "If labels is None and y_pred has shape ( n_samples , )"
        },
        "hasAction": {
          "action": "the labels are assumed to be binary and are inferred from y_true"
        }
      }
    ]
  },
  "sklearn/sklearn.metrics._classification/hinge_loss": {},
  "sklearn/sklearn.metrics._classification/brier_score_loss": {},
  "sklearn/sklearn.metrics._ranking/auc": {},
  "sklearn/sklearn.metrics._ranking/average_precision_score": {
    "average": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics._ranking/average_precision_score/average",
          "name": "average",
          "qname": "sklearn.metrics._ranking.average_precision_score.average",
          "default_value": "'macro'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'micro', 'samples', 'weighted', 'macro'} or None",
            "default_value": "'macro'",
            "description": "If ``None``, the scores for each class are returned. Otherwise,\nthis determines the type of averaging performed on the data:\n\n``'micro'``:\n    Calculate metrics globally by considering each element of the label\n    indicator matrix as a label.\n``'macro'``:\n    Calculate metrics for each label, and find their unweighted\n    mean.  This does not take label imbalance into account.\n``'weighted'``:\n    Calculate metrics for each label, and find their average, weighted\n    by support (the number of true instances for each label).\n``'samples'``:\n    Calculate metrics for each instance, and find their average.\n\nWill be ignored when ``y_true`` is binary."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "EnumType",
                "values": [
                  "macro",
                  "samples",
                  "micro",
                  "weighted"
                ]
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics._ranking/average_precision_score/y_true",
          "name": "y_true",
          "qname": "sklearn.metrics._ranking.average_precision_score.y_true",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "ndarray of shape (n_samples,) or (n_samples, n_classes)",
            "default_value": "",
            "description": "True binary labels or binary label indicators."
          },
          "type": {
            "kind": "NamedType",
            "name": "ndarray of shape (n_samples,) or (n_samples, n_classes)"
          }
        },
        "hasCondition": {
          "condition": "when y_true is binary"
        },
        "hasAction": {
          "action": "Will be ignored"
        }
      }
    ]
  },
  "sklearn/sklearn.metrics._ranking/det_curve": {
    "pos_label": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics._ranking/det_curve/pos_label",
          "name": "pos_label",
          "qname": "sklearn.metrics._ranking.det_curve.pos_label",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "int or str",
            "default_value": "None",
            "description": "The label of the positive class.\nWhen ``pos_label=None``, if `y_true` is in {-1, 1} or {0, 1},\n``pos_label`` is set to 1, otherwise an error will be raised."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "str"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics._ranking/det_curve/pos_label",
          "name": "pos_label",
          "qname": "sklearn.metrics._ranking.det_curve.pos_label",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "int or str",
            "default_value": "None",
            "description": "The label of the positive class.\nWhen ``pos_label=None``, if `y_true` is in {-1, 1} or {0, 1},\n``pos_label`` is set to 1, otherwise an error will be raised."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "str"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "When pos_label equals None"
        },
        "hasAction": {
          "action": ", if y_true is in { -1 , 1 } or { 0 , 1 } , pos_label is set to 1"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics._ranking/det_curve/pos_label",
          "name": "pos_label",
          "qname": "sklearn.metrics._ranking.det_curve.pos_label",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "int or str",
            "default_value": "None",
            "description": "The label of the positive class.\nWhen ``pos_label=None``, if `y_true` is in {-1, 1} or {0, 1},\n``pos_label`` is set to 1, otherwise an error will be raised."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "str"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics._ranking/det_curve/y_true",
          "name": "y_true",
          "qname": "sklearn.metrics._ranking.det_curve.y_true",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "ndarray of shape (n_samples,)",
            "default_value": "",
            "description": "True binary labels. If labels are not either {-1, 1} or {0, 1}, then\npos_label should be explicitly given."
          },
          "type": {
            "kind": "NamedType",
            "name": "ndarray of shape (n_samples,)"
          }
        },
        "hasCondition": {
          "condition": "if y_true is in { -1 , 1 } or { 0 , 1 }"
        },
        "hasAction": {
          "action": "When pos_label equals None , , pos_label is set to 1"
        }
      }
    ]
  },
  "sklearn/sklearn.metrics._ranking/_binary_roc_auc_score": {},
  "sklearn/sklearn.metrics._ranking/roc_auc_score": {
    "average": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics._ranking/roc_auc_score/average",
          "name": "average",
          "qname": "sklearn.metrics._ranking.roc_auc_score.average",
          "default_value": "'macro'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'micro', 'macro', 'samples', 'weighted'} or None",
            "default_value": "'macro'",
            "description": "If ``None``, the scores for each class are returned.\nOtherwise, this determines the type of averaging performed on the data.\nNote: multiclass ROC AUC currently only handles the 'macro' and\n'weighted' averages. For multiclass targets, `average=None` is only\nimplemented for `multi_class='ovo'` and `average='micro'` is only\nimplemented for `multi_class='ovr'`.\n\n``'micro'``:\n    Calculate metrics globally by considering each element of the label\n    indicator matrix as a label.\n``'macro'``:\n    Calculate metrics for each label, and find their unweighted\n    mean.  This does not take label imbalance into account.\n``'weighted'``:\n    Calculate metrics for each label, and find their average, weighted\n    by support (the number of true instances for each label).\n``'samples'``:\n    Calculate metrics for each instance, and find their average.\n\nWill be ignored when ``y_true`` is binary."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "EnumType",
                "values": [
                  "macro",
                  "micro",
                  "samples",
                  "weighted"
                ]
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics._ranking/roc_auc_score/multi_class",
          "name": "multi_class",
          "qname": "sklearn.metrics._ranking.roc_auc_score.multi_class",
          "default_value": "'raise'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'raise', 'ovr', 'ovo'}",
            "default_value": "'raise'",
            "description": "Only used for multiclass targets. Determines the type of configuration\nto use. The default value raises an error, so either\n``'ovr'`` or ``'ovo'`` must be passed explicitly.\n\n``'ovr'``:\n    Stands for One-vs-rest. Computes the AUC of each class\n    against the rest [3]_ [4]_. This\n    treats the multiclass case in the same way as the multilabel case.\n    Sensitive to class imbalance even when ``average == 'macro'``,\n    because class imbalance affects the composition of each of the\n    'rest' groupings.\n``'ovo'``:\n    Stands for One-vs-one. Computes the average AUC of all\n    possible pairwise combinations of classes [5]_.\n    Insensitive to class imbalance when\n    ``average == 'macro'``."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "ovr",
              "ovo",
              "raise"
            ]
          }
        },
        "hasCondition": {
          "condition": "for multi_class equals ovo and average"
        },
        "hasAction": {
          "action": "None is only implemented equals micro is only implemented for multi_class equals ovr"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics._ranking/roc_auc_score/average",
          "name": "average",
          "qname": "sklearn.metrics._ranking.roc_auc_score.average",
          "default_value": "'macro'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'micro', 'macro', 'samples', 'weighted'} or None",
            "default_value": "'macro'",
            "description": "If ``None``, the scores for each class are returned.\nOtherwise, this determines the type of averaging performed on the data.\nNote: multiclass ROC AUC currently only handles the 'macro' and\n'weighted' averages. For multiclass targets, `average=None` is only\nimplemented for `multi_class='ovo'` and `average='micro'` is only\nimplemented for `multi_class='ovr'`.\n\n``'micro'``:\n    Calculate metrics globally by considering each element of the label\n    indicator matrix as a label.\n``'macro'``:\n    Calculate metrics for each label, and find their unweighted\n    mean.  This does not take label imbalance into account.\n``'weighted'``:\n    Calculate metrics for each label, and find their average, weighted\n    by support (the number of true instances for each label).\n``'samples'``:\n    Calculate metrics for each instance, and find their average.\n\nWill be ignored when ``y_true`` is binary."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "EnumType",
                "values": [
                  "macro",
                  "micro",
                  "samples",
                  "weighted"
                ]
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics._ranking/roc_auc_score/multi_class",
          "name": "multi_class",
          "qname": "sklearn.metrics._ranking.roc_auc_score.multi_class",
          "default_value": "'raise'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'raise', 'ovr', 'ovo'}",
            "default_value": "'raise'",
            "description": "Only used for multiclass targets. Determines the type of configuration\nto use. The default value raises an error, so either\n``'ovr'`` or ``'ovo'`` must be passed explicitly.\n\n``'ovr'``:\n    Stands for One-vs-rest. Computes the AUC of each class\n    against the rest [3]_ [4]_. This\n    treats the multiclass case in the same way as the multilabel case.\n    Sensitive to class imbalance even when ``average == 'macro'``,\n    because class imbalance affects the composition of each of the\n    'rest' groupings.\n``'ovo'``:\n    Stands for One-vs-one. Computes the average AUC of all\n    possible pairwise combinations of classes [5]_.\n    Insensitive to class imbalance when\n    ``average == 'macro'``."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "ovr",
              "ovo",
              "raise"
            ]
          }
        },
        "hasCondition": {
          "condition": "for multi_class equals ovr"
        },
        "hasAction": {
          "action": "equals micro is only implemented"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics._ranking/roc_auc_score/average",
          "name": "average",
          "qname": "sklearn.metrics._ranking.roc_auc_score.average",
          "default_value": "'macro'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'micro', 'macro', 'samples', 'weighted'} or None",
            "default_value": "'macro'",
            "description": "If ``None``, the scores for each class are returned.\nOtherwise, this determines the type of averaging performed on the data.\nNote: multiclass ROC AUC currently only handles the 'macro' and\n'weighted' averages. For multiclass targets, `average=None` is only\nimplemented for `multi_class='ovo'` and `average='micro'` is only\nimplemented for `multi_class='ovr'`.\n\n``'micro'``:\n    Calculate metrics globally by considering each element of the label\n    indicator matrix as a label.\n``'macro'``:\n    Calculate metrics for each label, and find their unweighted\n    mean.  This does not take label imbalance into account.\n``'weighted'``:\n    Calculate metrics for each label, and find their average, weighted\n    by support (the number of true instances for each label).\n``'samples'``:\n    Calculate metrics for each instance, and find their average.\n\nWill be ignored when ``y_true`` is binary."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "EnumType",
                "values": [
                  "macro",
                  "micro",
                  "samples",
                  "weighted"
                ]
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics._ranking/roc_auc_score/y_true",
          "name": "y_true",
          "qname": "sklearn.metrics._ranking.roc_auc_score.y_true",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of shape (n_samples,) or (n_samples, n_classes)",
            "default_value": "",
            "description": "True labels or binary label indicators. The binary and multiclass cases\nexpect labels with shape (n_samples,) while the multilabel case expects\nbinary label indicators with shape (n_samples, n_classes)."
          },
          "type": {
            "kind": "NamedType",
            "name": "array-like of shape (n_samples,) or (n_samples, n_classes)"
          }
        },
        "hasCondition": {
          "condition": "when y_true is binary"
        },
        "hasAction": {
          "action": "Will be ignored"
        }
      }
    ]
  },
  "sklearn/sklearn.metrics._ranking/_multiclass_roc_auc_score": {},
  "sklearn/sklearn.metrics._ranking/_binary_clf_curve": {},
  "sklearn/sklearn.metrics._ranking/precision_recall_curve": {
    "pos_label": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics._ranking/precision_recall_curve/pos_label",
          "name": "pos_label",
          "qname": "sklearn.metrics._ranking.precision_recall_curve.pos_label",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int or str",
            "default_value": "None",
            "description": "The label of the positive class.\nWhen ``pos_label=None``, if y_true is in {-1, 1} or {0, 1},\n``pos_label`` is set to 1, otherwise an error will be raised."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "str"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics._ranking/precision_recall_curve/pos_label",
          "name": "pos_label",
          "qname": "sklearn.metrics._ranking.precision_recall_curve.pos_label",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int or str",
            "default_value": "None",
            "description": "The label of the positive class.\nWhen ``pos_label=None``, if y_true is in {-1, 1} or {0, 1},\n``pos_label`` is set to 1, otherwise an error will be raised."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "str"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "When pos_label equals None"
        },
        "hasAction": {
          "action": ", if y_true is in { -1 , 1 } or { 0 , 1 } , pos_label is set to 1"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics._ranking/precision_recall_curve/pos_label",
          "name": "pos_label",
          "qname": "sklearn.metrics._ranking.precision_recall_curve.pos_label",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int or str",
            "default_value": "None",
            "description": "The label of the positive class.\nWhen ``pos_label=None``, if y_true is in {-1, 1} or {0, 1},\n``pos_label`` is set to 1, otherwise an error will be raised."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "str"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics._ranking/precision_recall_curve/y_true",
          "name": "y_true",
          "qname": "sklearn.metrics._ranking.precision_recall_curve.y_true",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "ndarray of shape (n_samples,)",
            "default_value": "",
            "description": "True binary labels. If labels are not either {-1, 1} or {0, 1}, then\npos_label should be explicitly given."
          },
          "type": {
            "kind": "NamedType",
            "name": "ndarray of shape (n_samples,)"
          }
        },
        "hasCondition": {
          "condition": "if y_true is in { -1 , 1 } or { 0 , 1 }"
        },
        "hasAction": {
          "action": "When pos_label equals None , , pos_label is set to 1"
        }
      }
    ]
  },
  "sklearn/sklearn.metrics._ranking/roc_curve": {
    "pos_label": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics._ranking/roc_curve/pos_label",
          "name": "pos_label",
          "qname": "sklearn.metrics._ranking.roc_curve.pos_label",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int or str",
            "default_value": "None",
            "description": "The label of the positive class.\nWhen ``pos_label=None``, if `y_true` is in {-1, 1} or {0, 1},\n``pos_label`` is set to 1, otherwise an error will be raised."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "str"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics._ranking/roc_curve/pos_label",
          "name": "pos_label",
          "qname": "sklearn.metrics._ranking.roc_curve.pos_label",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int or str",
            "default_value": "None",
            "description": "The label of the positive class.\nWhen ``pos_label=None``, if `y_true` is in {-1, 1} or {0, 1},\n``pos_label`` is set to 1, otherwise an error will be raised."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "str"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "When pos_label equals None"
        },
        "hasAction": {
          "action": ", if y_true is in { -1 , 1 } or { 0 , 1 } , pos_label is set to 1"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics._ranking/roc_curve/pos_label",
          "name": "pos_label",
          "qname": "sklearn.metrics._ranking.roc_curve.pos_label",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int or str",
            "default_value": "None",
            "description": "The label of the positive class.\nWhen ``pos_label=None``, if `y_true` is in {-1, 1} or {0, 1},\n``pos_label`` is set to 1, otherwise an error will be raised."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "str"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics._ranking/roc_curve/y_true",
          "name": "y_true",
          "qname": "sklearn.metrics._ranking.roc_curve.y_true",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "ndarray of shape (n_samples,)",
            "default_value": "",
            "description": "True binary labels. If labels are not either {-1, 1} or {0, 1}, then\npos_label should be explicitly given."
          },
          "type": {
            "kind": "NamedType",
            "name": "ndarray of shape (n_samples,)"
          }
        },
        "hasCondition": {
          "condition": "if y_true is in { -1 , 1 } or { 0 , 1 }"
        },
        "hasAction": {
          "action": "When pos_label equals None , , pos_label is set to 1"
        }
      }
    ]
  },
  "sklearn/sklearn.metrics._ranking/label_ranking_average_precision_score": {},
  "sklearn/sklearn.metrics._ranking/coverage_error": {},
  "sklearn/sklearn.metrics._ranking/label_ranking_loss": {},
  "sklearn/sklearn.metrics._ranking/_dcg_sample_scores": {},
  "sklearn/sklearn.metrics._ranking/_tie_averaged_dcg": {},
  "sklearn/sklearn.metrics._ranking/_check_dcg_target_type": {},
  "sklearn/sklearn.metrics._ranking/dcg_score": {},
  "sklearn/sklearn.metrics._ranking/_ndcg_sample_scores": {},
  "sklearn/sklearn.metrics._ranking/ndcg_score": {},
  "sklearn/sklearn.metrics._ranking/top_k_accuracy_score": {
    "y_score": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics._ranking/top_k_accuracy_score/y_score",
          "name": "y_score",
          "qname": "sklearn.metrics._ranking.top_k_accuracy_score.y_score",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of shape (n_samples,) or (n_samples, n_classes)",
            "default_value": "",
            "description": "Target scores. These can be either probability estimates or\nnon-thresholded decision values (as returned by\n:term:`decision_function` on some classifiers).\nThe binary case expects scores with shape (n_samples,) while the\nmulticlass case expects scores with shape (n_samples, n_classes).\nIn the multiclass case, the order of the class scores must\ncorrespond to the order of ``labels``, if provided, or else to\nthe numerical or lexicographical order of the labels in ``y_true``.\nIf ``y_true`` does not contain all the labels, ``labels`` must be\nprovided."
          },
          "type": {
            "kind": "NamedType",
            "name": "array-like of shape (n_samples,) or (n_samples, n_classes)"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics._ranking/top_k_accuracy_score/y_true",
          "name": "y_true",
          "qname": "sklearn.metrics._ranking.top_k_accuracy_score.y_true",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of shape (n_samples,)",
            "default_value": "",
            "description": "True labels."
          },
          "type": {
            "kind": "NamedType",
            "name": "array-like of shape (n_samples,)"
          }
        },
        "hasCondition": {
          "condition": "If y_true does not contain all the labels"
        },
        "hasAction": {
          "action": ", labels must be provided"
        }
      }
    ],
    "labels": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics._ranking/top_k_accuracy_score/labels",
          "name": "labels",
          "qname": "sklearn.metrics._ranking.top_k_accuracy_score.labels",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "array-like of shape (n_classes,)",
            "default_value": "None",
            "description": "Multiclass only. List of labels that index the classes in ``y_score``.\nIf ``None``, the numerical or lexicographical order of the labels in\n``y_true`` is used. If ``y_true`` does not contain all the labels,\n``labels`` must be provided."
          },
          "type": {
            "kind": "NamedType",
            "name": "array-like of shape (n_classes,)"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics._ranking/top_k_accuracy_score/y_true",
          "name": "y_true",
          "qname": "sklearn.metrics._ranking.top_k_accuracy_score.y_true",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of shape (n_samples,)",
            "default_value": "",
            "description": "True labels."
          },
          "type": {
            "kind": "NamedType",
            "name": "array-like of shape (n_samples,)"
          }
        },
        "hasCondition": {
          "condition": "If y_true does not contain all the labels"
        },
        "hasAction": {
          "action": ", labels must be provided"
        }
      }
    ]
  },
  "sklearn/sklearn.metrics._regression/_check_reg_targets": {},
  "sklearn/sklearn.metrics._regression/mean_absolute_error": {},
  "sklearn/sklearn.metrics._regression/mean_pinball_loss": {},
  "sklearn/sklearn.metrics._regression/mean_absolute_percentage_error": {},
  "sklearn/sklearn.metrics._regression/mean_squared_error": {},
  "sklearn/sklearn.metrics._regression/mean_squared_log_error": {},
  "sklearn/sklearn.metrics._regression/median_absolute_error": {},
  "sklearn/sklearn.metrics._regression/_assemble_r2_explained_variance": {},
  "sklearn/sklearn.metrics._regression/explained_variance_score": {},
  "sklearn/sklearn.metrics._regression/r2_score": {},
  "sklearn/sklearn.metrics._regression/max_error": {},
  "sklearn/sklearn.metrics._regression/_mean_tweedie_deviance": {},
  "sklearn/sklearn.metrics._regression/mean_tweedie_deviance": {},
  "sklearn/sklearn.metrics._regression/mean_poisson_deviance": {},
  "sklearn/sklearn.metrics._regression/mean_gamma_deviance": {},
  "sklearn/sklearn.metrics._regression/d2_tweedie_score": {},
  "sklearn/sklearn.metrics._regression/d2_pinball_score": {},
  "sklearn/sklearn.metrics._regression/d2_absolute_error_score": {},
  "sklearn/sklearn.metrics._scorer/_cached_call": {},
  "sklearn/sklearn.metrics._scorer/_MultimetricScorer/__init__": {},
  "sklearn/sklearn.metrics._scorer/_MultimetricScorer/__call__": {},
  "sklearn/sklearn.metrics._scorer/_MultimetricScorer/_use_cache": {},
  "sklearn/sklearn.metrics._scorer/_BaseScorer/__init__": {},
  "sklearn/sklearn.metrics._scorer/_BaseScorer/_check_pos_label": {},
  "sklearn/sklearn.metrics._scorer/_BaseScorer/_select_proba_binary": {},
  "sklearn/sklearn.metrics._scorer/_BaseScorer/__repr__": {},
  "sklearn/sklearn.metrics._scorer/_BaseScorer/__call__": {},
  "sklearn/sklearn.metrics._scorer/_BaseScorer/_factory_args": {},
  "sklearn/sklearn.metrics._scorer/_PredictScorer/_score": {},
  "sklearn/sklearn.metrics._scorer/_ProbaScorer/_score": {},
  "sklearn/sklearn.metrics._scorer/_ProbaScorer/_factory_args": {},
  "sklearn/sklearn.metrics._scorer/_ThresholdScorer/_score": {},
  "sklearn/sklearn.metrics._scorer/_ThresholdScorer/_factory_args": {},
  "sklearn/sklearn.metrics._scorer/get_scorer": {},
  "sklearn/sklearn.metrics._scorer/_passthrough_scorer": {},
  "sklearn/sklearn.metrics._scorer/check_scoring": {
    "allow_none": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics._scorer/check_scoring/allow_none",
          "name": "allow_none",
          "qname": "sklearn.metrics._scorer.check_scoring.allow_none",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "If no scoring is specified and the estimator has no score function, we\ncan either return None or raise an exception."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics._scorer/check_scoring/scoring",
          "name": "scoring",
          "qname": "sklearn.metrics._scorer.check_scoring.scoring",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "None",
            "description": "A string (see model evaluation documentation) or\na scorer callable object / function with signature\n``scorer(estimator, X, y)``.\nIf None, the provided estimator object's `score` method is used."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If no scoring is specified and the estimator has no score function"
        },
        "hasAction": {
          "action": ", we can either return None or raise an exception"
        }
      }
    ]
  },
  "sklearn/sklearn.metrics._scorer/_check_multimetric_scoring": {},
  "sklearn/sklearn.metrics._scorer/make_scorer": {},
  "sklearn/sklearn.metrics._scorer/positive_likelihood_ratio": {},
  "sklearn/sklearn.metrics._scorer/negative_likelihood_ratio": {},
  "sklearn/sklearn.metrics._scorer/_DeprecatedScorers/__getitem__": {},
  "sklearn/sklearn.metrics._scorer/get_scorer_names": {},
  "sklearn/sklearn.metrics.cluster._bicluster/_check_rows_and_columns": {},
  "sklearn/sklearn.metrics.cluster._bicluster/_jaccard": {},
  "sklearn/sklearn.metrics.cluster._bicluster/_pairwise_similarity": {},
  "sklearn/sklearn.metrics.cluster._bicluster/consensus_score": {},
  "sklearn/sklearn.metrics.cluster._supervised/check_clusterings": {},
  "sklearn/sklearn.metrics.cluster._supervised/_generalized_average": {},
  "sklearn/sklearn.metrics.cluster._supervised/contingency_matrix": {},
  "sklearn/sklearn.metrics.cluster._supervised/pair_confusion_matrix": {},
  "sklearn/sklearn.metrics.cluster._supervised/rand_score": {},
  "sklearn/sklearn.metrics.cluster._supervised/adjusted_rand_score": {},
  "sklearn/sklearn.metrics.cluster._supervised/homogeneity_completeness_v_measure": {
    "beta": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics.cluster._supervised/homogeneity_completeness_v_measure/beta",
          "name": "beta",
          "qname": "sklearn.metrics.cluster._supervised.homogeneity_completeness_v_measure.beta",
          "default_value": "1.0",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "1.0",
            "description": "Ratio of weight attributed to ``homogeneity`` vs ``completeness``.\nIf ``beta`` is greater than 1, ``completeness`` is weighted more\nstrongly in the calculation. If ``beta`` is less than 1,\n``homogeneity`` is weighted more strongly."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics.cluster._supervised/homogeneity_completeness_v_measure/beta",
          "name": "beta",
          "qname": "sklearn.metrics.cluster._supervised.homogeneity_completeness_v_measure.beta",
          "default_value": "1.0",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "1.0",
            "description": "Ratio of weight attributed to ``homogeneity`` vs ``completeness``.\nIf ``beta`` is greater than 1, ``completeness`` is weighted more\nstrongly in the calculation. If ``beta`` is less than 1,\n``homogeneity`` is weighted more strongly."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "hasCondition": {
          "condition": "If beta is greater than 1"
        },
        "hasAction": {
          "action": ", completeness is weighted more strongly in the calculation"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics.cluster._supervised/homogeneity_completeness_v_measure/beta",
          "name": "beta",
          "qname": "sklearn.metrics.cluster._supervised.homogeneity_completeness_v_measure.beta",
          "default_value": "1.0",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "1.0",
            "description": "Ratio of weight attributed to ``homogeneity`` vs ``completeness``.\nIf ``beta`` is greater than 1, ``completeness`` is weighted more\nstrongly in the calculation. If ``beta`` is less than 1,\n``homogeneity`` is weighted more strongly."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics.cluster._supervised/homogeneity_completeness_v_measure/beta",
          "name": "beta",
          "qname": "sklearn.metrics.cluster._supervised.homogeneity_completeness_v_measure.beta",
          "default_value": "1.0",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "1.0",
            "description": "Ratio of weight attributed to ``homogeneity`` vs ``completeness``.\nIf ``beta`` is greater than 1, ``completeness`` is weighted more\nstrongly in the calculation. If ``beta`` is less than 1,\n``homogeneity`` is weighted more strongly."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "hasCondition": {
          "condition": "If beta is less than 1"
        },
        "hasAction": {
          "action": ", homogeneity is weighted more strongly"
        }
      }
    ]
  },
  "sklearn/sklearn.metrics.cluster._supervised/homogeneity_score": {},
  "sklearn/sklearn.metrics.cluster._supervised/completeness_score": {},
  "sklearn/sklearn.metrics.cluster._supervised/v_measure_score": {
    "beta": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics.cluster._supervised/v_measure_score/beta",
          "name": "beta",
          "qname": "sklearn.metrics.cluster._supervised.v_measure_score.beta",
          "default_value": "1.0",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "1.0",
            "description": "Ratio of weight attributed to ``homogeneity`` vs ``completeness``.\nIf ``beta`` is greater than 1, ``completeness`` is weighted more\nstrongly in the calculation. If ``beta`` is less than 1,\n``homogeneity`` is weighted more strongly."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics.cluster._supervised/v_measure_score/beta",
          "name": "beta",
          "qname": "sklearn.metrics.cluster._supervised.v_measure_score.beta",
          "default_value": "1.0",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "1.0",
            "description": "Ratio of weight attributed to ``homogeneity`` vs ``completeness``.\nIf ``beta`` is greater than 1, ``completeness`` is weighted more\nstrongly in the calculation. If ``beta`` is less than 1,\n``homogeneity`` is weighted more strongly."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "hasCondition": {
          "condition": "If beta is greater than 1"
        },
        "hasAction": {
          "action": ", completeness is weighted more strongly in the calculation"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics.cluster._supervised/v_measure_score/beta",
          "name": "beta",
          "qname": "sklearn.metrics.cluster._supervised.v_measure_score.beta",
          "default_value": "1.0",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "1.0",
            "description": "Ratio of weight attributed to ``homogeneity`` vs ``completeness``.\nIf ``beta`` is greater than 1, ``completeness`` is weighted more\nstrongly in the calculation. If ``beta`` is less than 1,\n``homogeneity`` is weighted more strongly."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics.cluster._supervised/v_measure_score/beta",
          "name": "beta",
          "qname": "sklearn.metrics.cluster._supervised.v_measure_score.beta",
          "default_value": "1.0",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "1.0",
            "description": "Ratio of weight attributed to ``homogeneity`` vs ``completeness``.\nIf ``beta`` is greater than 1, ``completeness`` is weighted more\nstrongly in the calculation. If ``beta`` is less than 1,\n``homogeneity`` is weighted more strongly."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "hasCondition": {
          "condition": "If beta is less than 1"
        },
        "hasAction": {
          "action": ", homogeneity is weighted more strongly"
        }
      }
    ]
  },
  "sklearn/sklearn.metrics.cluster._supervised/mutual_info_score": {},
  "sklearn/sklearn.metrics.cluster._supervised/adjusted_mutual_info_score": {},
  "sklearn/sklearn.metrics.cluster._supervised/normalized_mutual_info_score": {},
  "sklearn/sklearn.metrics.cluster._supervised/fowlkes_mallows_score": {},
  "sklearn/sklearn.metrics.cluster._supervised/entropy": {},
  "sklearn/sklearn.metrics.cluster._unsupervised/check_number_of_labels": {},
  "sklearn/sklearn.metrics.cluster._unsupervised/silhouette_score": {
    "metric": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics.cluster._unsupervised/silhouette_score/metric",
          "name": "metric",
          "qname": "sklearn.metrics.cluster._unsupervised.silhouette_score.metric",
          "default_value": "'euclidean'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'euclidean'",
            "description": "The metric to use when calculating distance between instances in a\nfeature array. If metric is a string, it must be one of the options\nallowed by :func:`metrics.pairwise.pairwise_distances\n<sklearn.metrics.pairwise.pairwise_distances>`. If ``X`` is\nthe distance array itself, use ``metric=\"precomputed\"``."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics.cluster._unsupervised/silhouette_score/X",
          "name": "X",
          "qname": "sklearn.metrics.cluster._unsupervised.silhouette_score.X",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of shape (n_samples_a, n_samples_a) if metric ==             \"precomputed\" or (n_samples_a, n_features) otherwise",
            "default_value": "",
            "description": "An array of pairwise distances between samples, or a feature array."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of shape (n_samples_a, n_samples_a) if metric == \"precomputed\""
              },
              {
                "kind": "NamedType",
                "name": "(n_samples_a, n_features) otherwise"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If X is the distance array itself"
        },
        "hasAction": {
          "action": ", use metric equals precomputed"
        }
      }
    ],
    "sample_size": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics.cluster._unsupervised/silhouette_score/sample_size",
          "name": "sample_size",
          "qname": "sklearn.metrics.cluster._unsupervised.silhouette_score.sample_size",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "None",
            "description": "The size of the sample to use when computing the Silhouette Coefficient\non a random subset of the data.\nIf ``sample_size is None``, no sampling is used."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics.cluster._unsupervised/silhouette_score/sample_size",
          "name": "sample_size",
          "qname": "sklearn.metrics.cluster._unsupervised.silhouette_score.sample_size",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "None",
            "description": "The size of the sample to use when computing the Silhouette Coefficient\non a random subset of the data.\nIf ``sample_size is None``, no sampling is used."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "hasCondition": {
          "condition": "If sample_size is None"
        },
        "hasAction": {
          "action": ", no sampling is used"
        }
      }
    ]
  },
  "sklearn/sklearn.metrics.cluster._unsupervised/_silhouette_reduce": {},
  "sklearn/sklearn.metrics.cluster._unsupervised/silhouette_samples": {
    "metric": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics.cluster._unsupervised/silhouette_samples/metric",
          "name": "metric",
          "qname": "sklearn.metrics.cluster._unsupervised.silhouette_samples.metric",
          "default_value": "'euclidean'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'euclidean'",
            "description": "The metric to use when calculating distance between instances in a\nfeature array. If metric is a string, it must be one of the options\nallowed by :func:`sklearn.metrics.pairwise.pairwise_distances`.\nIf ``X`` is the distance array itself, use \"precomputed\" as the metric.\nPrecomputed distance matrices must have 0 along the diagonal."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics.cluster._unsupervised/silhouette_samples/X",
          "name": "X",
          "qname": "sklearn.metrics.cluster._unsupervised.silhouette_samples.X",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of shape (n_samples_a, n_samples_a) if metric ==             \"precomputed\" or (n_samples_a, n_features) otherwise",
            "default_value": "",
            "description": "An array of pairwise distances between samples, or a feature array."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of shape (n_samples_a, n_samples_a) if metric == \"precomputed\""
              },
              {
                "kind": "NamedType",
                "name": "(n_samples_a, n_features) otherwise"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If X is the distance array itself"
        },
        "hasAction": {
          "action": ", use precomputed as the metric"
        }
      }
    ]
  },
  "sklearn/sklearn.metrics.cluster._unsupervised/calinski_harabasz_score": {},
  "sklearn/sklearn.metrics.cluster._unsupervised/davies_bouldin_score": {},
  "sklearn/sklearn.metrics._pairwise_distances_reduction._dispatcher/sqeuclidean_row_norms": {},
  "sklearn/sklearn.metrics._pairwise_distances_reduction._dispatcher/BaseDistancesReductionDispatcher/valid_metrics": {},
  "sklearn/sklearn.metrics._pairwise_distances_reduction._dispatcher/BaseDistancesReductionDispatcher/is_usable_for": {},
  "sklearn/sklearn.metrics._pairwise_distances_reduction._dispatcher/BaseDistancesReductionDispatcher/compute": {},
  "sklearn/sklearn.metrics._pairwise_distances_reduction._dispatcher/ArgKmin/compute": {},
  "sklearn/sklearn.metrics._pairwise_distances_reduction._dispatcher/RadiusNeighbors/compute": {},
  "sklearn/sklearn.metrics._plot.base/_check_classifier_response_method": {},
  "sklearn/sklearn.metrics._plot.base/_get_response": {},
  "sklearn/sklearn.metrics._plot.confusion_matrix/ConfusionMatrixDisplay/__init__": {},
  "sklearn/sklearn.metrics._plot.confusion_matrix/ConfusionMatrixDisplay/plot": {},
  "sklearn/sklearn.metrics._plot.confusion_matrix/ConfusionMatrixDisplay/from_estimator": {},
  "sklearn/sklearn.metrics._plot.confusion_matrix/ConfusionMatrixDisplay/from_predictions": {},
  "sklearn/sklearn.metrics._plot.det_curve/DetCurveDisplay/__init__": {},
  "sklearn/sklearn.metrics._plot.det_curve/DetCurveDisplay/from_estimator": {
    "pos_label": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics._plot.det_curve/DetCurveDisplay/from_estimator/pos_label",
          "name": "pos_label",
          "qname": "sklearn.metrics._plot.det_curve.DetCurveDisplay.from_estimator.pos_label",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or int",
            "default_value": "None",
            "description": "The label of the positive class. When `pos_label=None`, if `y_true`\nis in {-1, 1} or {0, 1}, `pos_label` is set to 1, otherwise an\nerror will be raised."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "int"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics._plot.det_curve/DetCurveDisplay/from_estimator/pos_label",
          "name": "pos_label",
          "qname": "sklearn.metrics._plot.det_curve.DetCurveDisplay.from_estimator.pos_label",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or int",
            "default_value": "None",
            "description": "The label of the positive class. When `pos_label=None`, if `y_true`\nis in {-1, 1} or {0, 1}, `pos_label` is set to 1, otherwise an\nerror will be raised."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "int"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "When pos_label equals None"
        },
        "hasAction": {
          "action": ", if y_true is in { -1 , 1 } or { 0 , 1 } , pos_label is set to 1"
        }
      }
    ]
  },
  "sklearn/sklearn.metrics._plot.det_curve/DetCurveDisplay/from_predictions": {
    "pos_label": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics._plot.det_curve/DetCurveDisplay/from_predictions/pos_label",
          "name": "pos_label",
          "qname": "sklearn.metrics._plot.det_curve.DetCurveDisplay.from_predictions.pos_label",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or int",
            "default_value": "None",
            "description": "The label of the positive class. When `pos_label=None`, if `y_true`\nis in {-1, 1} or {0, 1}, `pos_label` is set to 1, otherwise an\nerror will be raised."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "int"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics._plot.det_curve/DetCurveDisplay/from_predictions/pos_label",
          "name": "pos_label",
          "qname": "sklearn.metrics._plot.det_curve.DetCurveDisplay.from_predictions.pos_label",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or int",
            "default_value": "None",
            "description": "The label of the positive class. When `pos_label=None`, if `y_true`\nis in {-1, 1} or {0, 1}, `pos_label` is set to 1, otherwise an\nerror will be raised."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "int"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "When pos_label equals None"
        },
        "hasAction": {
          "action": ", if y_true is in { -1 , 1 } or { 0 , 1 } , pos_label is set to 1"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics._plot.det_curve/DetCurveDisplay/from_predictions/pos_label",
          "name": "pos_label",
          "qname": "sklearn.metrics._plot.det_curve.DetCurveDisplay.from_predictions.pos_label",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or int",
            "default_value": "None",
            "description": "The label of the positive class. When `pos_label=None`, if `y_true`\nis in {-1, 1} or {0, 1}, `pos_label` is set to 1, otherwise an\nerror will be raised."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "int"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics._plot.det_curve/DetCurveDisplay/from_predictions/y_true",
          "name": "y_true",
          "qname": "sklearn.metrics._plot.det_curve.DetCurveDisplay.from_predictions.y_true",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of shape (n_samples,)",
            "default_value": "",
            "description": "True labels."
          },
          "type": {
            "kind": "NamedType",
            "name": "array-like of shape (n_samples,)"
          }
        },
        "hasCondition": {
          "condition": "if y_true is in { -1 , 1 } or { 0 , 1 }"
        },
        "hasAction": {
          "action": "When pos_label equals None , , pos_label is set to 1"
        }
      }
    ]
  },
  "sklearn/sklearn.metrics._plot.det_curve/DetCurveDisplay/plot": {},
  "sklearn/sklearn.metrics._plot.precision_recall_curve/PrecisionRecallDisplay/__init__": {},
  "sklearn/sklearn.metrics._plot.precision_recall_curve/PrecisionRecallDisplay/plot": {},
  "sklearn/sklearn.metrics._plot.precision_recall_curve/PrecisionRecallDisplay/from_estimator": {},
  "sklearn/sklearn.metrics._plot.precision_recall_curve/PrecisionRecallDisplay/from_predictions": {},
  "sklearn/sklearn.metrics._plot.regression/PredictionErrorDisplay/__init__": {},
  "sklearn/sklearn.metrics._plot.regression/PredictionErrorDisplay/plot": {},
  "sklearn/sklearn.metrics._plot.regression/PredictionErrorDisplay/from_estimator": {
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics._plot.regression/PredictionErrorDisplay/from_estimator/random_state",
          "name": "random_state",
          "qname": "sklearn.metrics._plot.regression.PredictionErrorDisplay.from_estimator.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": false,
          "docstring": {
            "type": "int or RandomState",
            "default_value": "None",
            "description": "Controls the randomness when `subsample` is not `None`.\nSee :term:`Glossary <random_state>` for details."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics._plot.regression/PredictionErrorDisplay/from_estimator/subsample",
          "name": "subsample",
          "qname": "sklearn.metrics._plot.regression.PredictionErrorDisplay.from_estimator.subsample",
          "default_value": "1000",
          "assigned_by": "NAME_ONLY",
          "is_public": false,
          "docstring": {
            "type": "float, int or None",
            "default_value": "1_000",
            "description": "Sampling the samples to be shown on the scatter plot. If `float`,\nit should be between 0 and 1 and represents the proportion of the\noriginal dataset. If `int`, it represents the number of samples\ndisplay on the scatter plot. If `None`, no subsampling will be\napplied. by default, a 1000 samples or less will be displayed."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "float"
              },
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "when subsample is not None"
        },
        "hasAction": {
          "action": "Controls the randomness"
        }
      }
    ]
  },
  "sklearn/sklearn.metrics._plot.regression/PredictionErrorDisplay/from_predictions": {
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics._plot.regression/PredictionErrorDisplay/from_predictions/random_state",
          "name": "random_state",
          "qname": "sklearn.metrics._plot.regression.PredictionErrorDisplay.from_predictions.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": false,
          "docstring": {
            "type": "int or RandomState",
            "default_value": "None",
            "description": "Controls the randomness when `subsample` is not `None`.\nSee :term:`Glossary <random_state>` for details."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics._plot.regression/PredictionErrorDisplay/from_predictions/subsample",
          "name": "subsample",
          "qname": "sklearn.metrics._plot.regression.PredictionErrorDisplay.from_predictions.subsample",
          "default_value": "1000",
          "assigned_by": "NAME_ONLY",
          "is_public": false,
          "docstring": {
            "type": "float, int or None",
            "default_value": "1_000",
            "description": "Sampling the samples to be shown on the scatter plot. If `float`,\nit should be between 0 and 1 and represents the proportion of the\noriginal dataset. If `int`, it represents the number of samples\ndisplay on the scatter plot. If `None`, no subsampling will be\napplied. by default, a 1000 samples or less will be displayed."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "float"
              },
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "when subsample is not None"
        },
        "hasAction": {
          "action": "Controls the randomness"
        }
      }
    ]
  },
  "sklearn/sklearn.metrics._plot.roc_curve/RocCurveDisplay/__init__": {},
  "sklearn/sklearn.metrics._plot.roc_curve/RocCurveDisplay/plot": {},
  "sklearn/sklearn.metrics._plot.roc_curve/RocCurveDisplay/from_estimator": {},
  "sklearn/sklearn.metrics._plot.roc_curve/RocCurveDisplay/from_predictions": {
    "pos_label": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics._plot.roc_curve/RocCurveDisplay/from_predictions/pos_label",
          "name": "pos_label",
          "qname": "sklearn.metrics._plot.roc_curve.RocCurveDisplay.from_predictions.pos_label",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or int",
            "default_value": "None",
            "description": "The label of the positive class. When `pos_label=None`, if `y_true`\nis in {-1, 1} or {0, 1}, `pos_label` is set to 1, otherwise an\nerror will be raised."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "int"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics._plot.roc_curve/RocCurveDisplay/from_predictions/pos_label",
          "name": "pos_label",
          "qname": "sklearn.metrics._plot.roc_curve.RocCurveDisplay.from_predictions.pos_label",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or int",
            "default_value": "None",
            "description": "The label of the positive class. When `pos_label=None`, if `y_true`\nis in {-1, 1} or {0, 1}, `pos_label` is set to 1, otherwise an\nerror will be raised."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "int"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "When pos_label equals None"
        },
        "hasAction": {
          "action": ", if y_true is in { -1 , 1 } or { 0 , 1 } , pos_label is set to 1"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.metrics._plot.roc_curve/RocCurveDisplay/from_predictions/pos_label",
          "name": "pos_label",
          "qname": "sklearn.metrics._plot.roc_curve.RocCurveDisplay.from_predictions.pos_label",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or int",
            "default_value": "None",
            "description": "The label of the positive class. When `pos_label=None`, if `y_true`\nis in {-1, 1} or {0, 1}, `pos_label` is set to 1, otherwise an\nerror will be raised."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "int"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.metrics._plot.roc_curve/RocCurveDisplay/from_predictions/y_true",
          "name": "y_true",
          "qname": "sklearn.metrics._plot.roc_curve.RocCurveDisplay.from_predictions.y_true",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of shape (n_samples,)",
            "default_value": "",
            "description": "True labels."
          },
          "type": {
            "kind": "NamedType",
            "name": "array-like of shape (n_samples,)"
          }
        },
        "hasCondition": {
          "condition": "if y_true is in { -1 , 1 } or { 0 , 1 }"
        },
        "hasAction": {
          "action": "When pos_label equals None , , pos_label is set to 1"
        }
      }
    ]
  },
  "sklearn/sklearn.neighbors._base/_get_weights": {},
  "sklearn/sklearn.neighbors._base/_is_sorted_by_data": {},
  "sklearn/sklearn.neighbors._base/_check_precomputed": {},
  "sklearn/sklearn.neighbors._base/sort_graph_by_row_values": {
    "warn_when_not_sorted": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neighbors._base/sort_graph_by_row_values/warn_when_not_sorted",
          "name": "warn_when_not_sorted",
          "qname": "sklearn.neighbors._base.sort_graph_by_row_values.warn_when_not_sorted",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "If True, a :class:`~sklearn.exceptions.EfficiencyWarning` is raised\nwhen the input graph is not sorted by row values."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neighbors._base/sort_graph_by_row_values/graph",
          "name": "graph",
          "qname": "sklearn.neighbors._base.sort_graph_by_row_values.graph",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "sparse matrix of shape (n_samples, n_samples)",
            "default_value": "",
            "description": "Distance matrix to other samples, where only non-zero elements are\nconsidered neighbors. Matrix is converted to CSR format if not already."
          },
          "type": {
            "kind": "NamedType",
            "name": "sparse matrix of shape (n_samples, n_samples)"
          }
        },
        "hasCondition": {
          "condition": "when the input graph is not sorted by row values"
        },
        "hasAction": {
          "action": "EfficiencyWarning is raised"
        }
      }
    ]
  },
  "sklearn/sklearn.neighbors._base/_kneighbors_from_graph": {},
  "sklearn/sklearn.neighbors._base/_radius_neighbors_from_graph": {},
  "sklearn/sklearn.neighbors._base/NeighborsBase/__init__": {},
  "sklearn/sklearn.neighbors._base/NeighborsBase/_check_algorithm_metric": {},
  "sklearn/sklearn.neighbors._base/NeighborsBase/_fit": {},
  "sklearn/sklearn.neighbors._base/NeighborsBase/_more_tags": {},
  "sklearn/sklearn.neighbors._base/_tree_query_parallel_helper": {},
  "sklearn/sklearn.neighbors._base/KNeighborsMixin/_kneighbors_reduce_func": {},
  "sklearn/sklearn.neighbors._base/KNeighborsMixin/kneighbors": {},
  "sklearn/sklearn.neighbors._base/KNeighborsMixin/kneighbors_graph": {},
  "sklearn/sklearn.neighbors._base/_tree_query_radius_parallel_helper": {},
  "sklearn/sklearn.neighbors._base/RadiusNeighborsMixin/_radius_neighbors_reduce_func": {},
  "sklearn/sklearn.neighbors._base/RadiusNeighborsMixin/radius_neighbors": {
    "sort_results": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neighbors._base/RadiusNeighborsMixin/radius_neighbors/sort_results",
          "name": "sort_results",
          "qname": "sklearn.neighbors._base.RadiusNeighborsMixin.radius_neighbors.sort_results",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "If True, the distances and indices will be sorted by increasing\ndistances before being returned. If False, the results may not\nbe sorted. If `return_distance=False`, setting `sort_results=True`\nwill result in an error.\n\n.. versionadded:: 0.22"
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neighbors._base/RadiusNeighborsMixin/radius_neighbors/return_distance",
          "name": "return_distance",
          "qname": "sklearn.neighbors._base.RadiusNeighborsMixin.radius_neighbors.return_distance",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Whether or not to return the distances."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "If return_distance equals False"
        },
        "hasAction": {
          "action": ", setting sort_results equals True"
        }
      }
    ]
  },
  "sklearn/sklearn.neighbors._base/RadiusNeighborsMixin/radius_neighbors_graph": {},
  "sklearn/sklearn.neighbors._classification/KNeighborsClassifier/__init__": {
    "metric": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neighbors._classification/KNeighborsClassifier/__init__/metric",
          "name": "metric",
          "qname": "sklearn.neighbors._classification.KNeighborsClassifier.__init__.metric",
          "default_value": "'minkowski'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'minkowski'",
            "description": "Metric to use for distance computation. Default is \"minkowski\", which\nresults in the standard Euclidean distance when p = 2. See the\ndocumentation of `scipy.spatial.distance\n<https://docs.scipy.org/doc/scipy/reference/spatial.distance.html>`_ and\nthe metrics listed in\n:class:`~sklearn.metrics.pairwise.distance_metrics` for valid metric\nvalues.\n\nIf metric is \"precomputed\", X is assumed to be a distance matrix and\nmust be square during fit. X may be a :term:`sparse graph`, in which\ncase only \"nonzero\" elements may be considered neighbors.\n\nIf metric is a callable function, it takes two arrays representing 1D\nvectors as inputs and must return one value indicating the distance\nbetween those vectors. This works for Scipy's metrics, but is less\nefficient than passing the metric name as a string."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neighbors._classification/KNeighborsClassifier/__init__/p",
          "name": "p",
          "qname": "sklearn.neighbors._classification.KNeighborsClassifier.__init__.p",
          "default_value": "2",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "2",
            "description": "Power parameter for the Minkowski metric. When p = 1, this is\nequivalent to using manhattan_distance (l1), and euclidean_distance\n(l2) for p = 2. For arbitrary p, minkowski_distance (l_p) is used."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "hasCondition": {
          "condition": "when p equals 2"
        },
        "hasAction": {
          "action": "which results in the standard Euclidean distance"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neighbors._classification/KNeighborsClassifier/__init__/metric",
          "name": "metric",
          "qname": "sklearn.neighbors._classification.KNeighborsClassifier.__init__.metric",
          "default_value": "'minkowski'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'minkowski'",
            "description": "Metric to use for distance computation. Default is \"minkowski\", which\nresults in the standard Euclidean distance when p = 2. See the\ndocumentation of `scipy.spatial.distance\n<https://docs.scipy.org/doc/scipy/reference/spatial.distance.html>`_ and\nthe metrics listed in\n:class:`~sklearn.metrics.pairwise.distance_metrics` for valid metric\nvalues.\n\nIf metric is \"precomputed\", X is assumed to be a distance matrix and\nmust be square during fit. X may be a :term:`sparse graph`, in which\ncase only \"nonzero\" elements may be considered neighbors.\n\nIf metric is a callable function, it takes two arrays representing 1D\nvectors as inputs and must return one value indicating the distance\nbetween those vectors. This works for Scipy's metrics, but is less\nefficient than passing the metric name as a string."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neighbors._classification/KNeighborsClassifier/__init__/metric",
          "name": "metric",
          "qname": "sklearn.neighbors._classification.KNeighborsClassifier.__init__.metric",
          "default_value": "'minkowski'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'minkowski'",
            "description": "Metric to use for distance computation. Default is \"minkowski\", which\nresults in the standard Euclidean distance when p = 2. See the\ndocumentation of `scipy.spatial.distance\n<https://docs.scipy.org/doc/scipy/reference/spatial.distance.html>`_ and\nthe metrics listed in\n:class:`~sklearn.metrics.pairwise.distance_metrics` for valid metric\nvalues.\n\nIf metric is \"precomputed\", X is assumed to be a distance matrix and\nmust be square during fit. X may be a :term:`sparse graph`, in which\ncase only \"nonzero\" elements may be considered neighbors.\n\nIf metric is a callable function, it takes two arrays representing 1D\nvectors as inputs and must return one value indicating the distance\nbetween those vectors. This works for Scipy's metrics, but is less\nefficient than passing the metric name as a string."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If metric is precomputed"
        },
        "hasAction": {
          "action": ", X is assumed to be a distance matrix and must be square during fit"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neighbors._classification/KNeighborsClassifier/__init__/metric",
          "name": "metric",
          "qname": "sklearn.neighbors._classification.KNeighborsClassifier.__init__.metric",
          "default_value": "'minkowski'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'minkowski'",
            "description": "Metric to use for distance computation. Default is \"minkowski\", which\nresults in the standard Euclidean distance when p = 2. See the\ndocumentation of `scipy.spatial.distance\n<https://docs.scipy.org/doc/scipy/reference/spatial.distance.html>`_ and\nthe metrics listed in\n:class:`~sklearn.metrics.pairwise.distance_metrics` for valid metric\nvalues.\n\nIf metric is \"precomputed\", X is assumed to be a distance matrix and\nmust be square during fit. X may be a :term:`sparse graph`, in which\ncase only \"nonzero\" elements may be considered neighbors.\n\nIf metric is a callable function, it takes two arrays representing 1D\nvectors as inputs and must return one value indicating the distance\nbetween those vectors. This works for Scipy's metrics, but is less\nefficient than passing the metric name as a string."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neighbors._classification/KNeighborsClassifier/__init__/metric",
          "name": "metric",
          "qname": "sklearn.neighbors._classification.KNeighborsClassifier.__init__.metric",
          "default_value": "'minkowski'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'minkowski'",
            "description": "Metric to use for distance computation. Default is \"minkowski\", which\nresults in the standard Euclidean distance when p = 2. See the\ndocumentation of `scipy.spatial.distance\n<https://docs.scipy.org/doc/scipy/reference/spatial.distance.html>`_ and\nthe metrics listed in\n:class:`~sklearn.metrics.pairwise.distance_metrics` for valid metric\nvalues.\n\nIf metric is \"precomputed\", X is assumed to be a distance matrix and\nmust be square during fit. X may be a :term:`sparse graph`, in which\ncase only \"nonzero\" elements may be considered neighbors.\n\nIf metric is a callable function, it takes two arrays representing 1D\nvectors as inputs and must return one value indicating the distance\nbetween those vectors. This works for Scipy's metrics, but is less\nefficient than passing the metric name as a string."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If metric is a callable function"
        },
        "hasAction": {
          "action": ", it takes two arrays representing 1D vectors as inputs and must return one value indicating the distance between those vectors"
        }
      }
    ]
  },
  "sklearn/sklearn.neighbors._classification/KNeighborsClassifier/fit": {},
  "sklearn/sklearn.neighbors._classification/KNeighborsClassifier/predict": {},
  "sklearn/sklearn.neighbors._classification/KNeighborsClassifier/predict_proba": {},
  "sklearn/sklearn.neighbors._classification/KNeighborsClassifier/_more_tags": {},
  "sklearn/sklearn.neighbors._classification/RadiusNeighborsClassifier/__init__": {
    "metric": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neighbors._classification/RadiusNeighborsClassifier/__init__/metric",
          "name": "metric",
          "qname": "sklearn.neighbors._classification.RadiusNeighborsClassifier.__init__.metric",
          "default_value": "'minkowski'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'minkowski'",
            "description": "Metric to use for distance computation. Default is \"minkowski\", which\nresults in the standard Euclidean distance when p = 2. See the\ndocumentation of `scipy.spatial.distance\n<https://docs.scipy.org/doc/scipy/reference/spatial.distance.html>`_ and\nthe metrics listed in\n:class:`~sklearn.metrics.pairwise.distance_metrics` for valid metric\nvalues.\n\nIf metric is \"precomputed\", X is assumed to be a distance matrix and\nmust be square during fit. X may be a :term:`sparse graph`, in which\ncase only \"nonzero\" elements may be considered neighbors.\n\nIf metric is a callable function, it takes two arrays representing 1D\nvectors as inputs and must return one value indicating the distance\nbetween those vectors. This works for Scipy's metrics, but is less\nefficient than passing the metric name as a string."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neighbors._classification/RadiusNeighborsClassifier/__init__/p",
          "name": "p",
          "qname": "sklearn.neighbors._classification.RadiusNeighborsClassifier.__init__.p",
          "default_value": "2",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "2",
            "description": "Power parameter for the Minkowski metric. When p = 1, this is\nequivalent to using manhattan_distance (l1), and euclidean_distance\n(l2) for p = 2. For arbitrary p, minkowski_distance (l_p) is used."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "hasCondition": {
          "condition": "when p equals 2"
        },
        "hasAction": {
          "action": "which results in the standard Euclidean distance"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neighbors._classification/RadiusNeighborsClassifier/__init__/metric",
          "name": "metric",
          "qname": "sklearn.neighbors._classification.RadiusNeighborsClassifier.__init__.metric",
          "default_value": "'minkowski'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'minkowski'",
            "description": "Metric to use for distance computation. Default is \"minkowski\", which\nresults in the standard Euclidean distance when p = 2. See the\ndocumentation of `scipy.spatial.distance\n<https://docs.scipy.org/doc/scipy/reference/spatial.distance.html>`_ and\nthe metrics listed in\n:class:`~sklearn.metrics.pairwise.distance_metrics` for valid metric\nvalues.\n\nIf metric is \"precomputed\", X is assumed to be a distance matrix and\nmust be square during fit. X may be a :term:`sparse graph`, in which\ncase only \"nonzero\" elements may be considered neighbors.\n\nIf metric is a callable function, it takes two arrays representing 1D\nvectors as inputs and must return one value indicating the distance\nbetween those vectors. This works for Scipy's metrics, but is less\nefficient than passing the metric name as a string."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neighbors._classification/RadiusNeighborsClassifier/__init__/metric",
          "name": "metric",
          "qname": "sklearn.neighbors._classification.RadiusNeighborsClassifier.__init__.metric",
          "default_value": "'minkowski'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'minkowski'",
            "description": "Metric to use for distance computation. Default is \"minkowski\", which\nresults in the standard Euclidean distance when p = 2. See the\ndocumentation of `scipy.spatial.distance\n<https://docs.scipy.org/doc/scipy/reference/spatial.distance.html>`_ and\nthe metrics listed in\n:class:`~sklearn.metrics.pairwise.distance_metrics` for valid metric\nvalues.\n\nIf metric is \"precomputed\", X is assumed to be a distance matrix and\nmust be square during fit. X may be a :term:`sparse graph`, in which\ncase only \"nonzero\" elements may be considered neighbors.\n\nIf metric is a callable function, it takes two arrays representing 1D\nvectors as inputs and must return one value indicating the distance\nbetween those vectors. This works for Scipy's metrics, but is less\nefficient than passing the metric name as a string."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If metric is precomputed"
        },
        "hasAction": {
          "action": ", X is assumed to be a distance matrix and must be square during fit"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neighbors._classification/RadiusNeighborsClassifier/__init__/metric",
          "name": "metric",
          "qname": "sklearn.neighbors._classification.RadiusNeighborsClassifier.__init__.metric",
          "default_value": "'minkowski'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'minkowski'",
            "description": "Metric to use for distance computation. Default is \"minkowski\", which\nresults in the standard Euclidean distance when p = 2. See the\ndocumentation of `scipy.spatial.distance\n<https://docs.scipy.org/doc/scipy/reference/spatial.distance.html>`_ and\nthe metrics listed in\n:class:`~sklearn.metrics.pairwise.distance_metrics` for valid metric\nvalues.\n\nIf metric is \"precomputed\", X is assumed to be a distance matrix and\nmust be square during fit. X may be a :term:`sparse graph`, in which\ncase only \"nonzero\" elements may be considered neighbors.\n\nIf metric is a callable function, it takes two arrays representing 1D\nvectors as inputs and must return one value indicating the distance\nbetween those vectors. This works for Scipy's metrics, but is less\nefficient than passing the metric name as a string."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neighbors._classification/RadiusNeighborsClassifier/__init__/metric",
          "name": "metric",
          "qname": "sklearn.neighbors._classification.RadiusNeighborsClassifier.__init__.metric",
          "default_value": "'minkowski'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'minkowski'",
            "description": "Metric to use for distance computation. Default is \"minkowski\", which\nresults in the standard Euclidean distance when p = 2. See the\ndocumentation of `scipy.spatial.distance\n<https://docs.scipy.org/doc/scipy/reference/spatial.distance.html>`_ and\nthe metrics listed in\n:class:`~sklearn.metrics.pairwise.distance_metrics` for valid metric\nvalues.\n\nIf metric is \"precomputed\", X is assumed to be a distance matrix and\nmust be square during fit. X may be a :term:`sparse graph`, in which\ncase only \"nonzero\" elements may be considered neighbors.\n\nIf metric is a callable function, it takes two arrays representing 1D\nvectors as inputs and must return one value indicating the distance\nbetween those vectors. This works for Scipy's metrics, but is less\nefficient than passing the metric name as a string."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If metric is a callable function"
        },
        "hasAction": {
          "action": ", it takes two arrays representing 1D vectors as inputs and must return one value indicating the distance between those vectors"
        }
      }
    ]
  },
  "sklearn/sklearn.neighbors._classification/RadiusNeighborsClassifier/fit": {},
  "sklearn/sklearn.neighbors._classification/RadiusNeighborsClassifier/predict": {},
  "sklearn/sklearn.neighbors._classification/RadiusNeighborsClassifier/predict_proba": {},
  "sklearn/sklearn.neighbors._classification/RadiusNeighborsClassifier/_more_tags": {},
  "sklearn/sklearn.neighbors._distance_metric/DistanceMetric/_warn": {},
  "sklearn/sklearn.neighbors._distance_metric/DistanceMetric/get_metric": {},
  "sklearn/sklearn.neighbors._graph/_check_params": {},
  "sklearn/sklearn.neighbors._graph/_query_include_self": {},
  "sklearn/sklearn.neighbors._graph/kneighbors_graph": {
    "metric": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neighbors._graph/kneighbors_graph/metric",
          "name": "metric",
          "qname": "sklearn.neighbors._graph.kneighbors_graph.metric",
          "default_value": "'minkowski'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "'minkowski'",
            "description": "Metric to use for distance computation. Default is \"minkowski\", which\nresults in the standard Euclidean distance when p = 2. See the\ndocumentation of `scipy.spatial.distance\n<https://docs.scipy.org/doc/scipy/reference/spatial.distance.html>`_ and\nthe metrics listed in\n:class:`~sklearn.metrics.pairwise.distance_metrics` for valid metric\nvalues."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neighbors._graph/kneighbors_graph/p",
          "name": "p",
          "qname": "sklearn.neighbors._graph.kneighbors_graph.p",
          "default_value": "2",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "2",
            "description": "Power parameter for the Minkowski metric. When p = 1, this is\nequivalent to using manhattan_distance (l1), and euclidean_distance\n(l2) for p = 2. For arbitrary p, minkowski_distance (l_p) is used."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "hasCondition": {
          "condition": "when p equals 2"
        },
        "hasAction": {
          "action": "which results in the standard Euclidean distance"
        }
      }
    ]
  },
  "sklearn/sklearn.neighbors._graph/radius_neighbors_graph": {
    "metric": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neighbors._graph/radius_neighbors_graph/metric",
          "name": "metric",
          "qname": "sklearn.neighbors._graph.radius_neighbors_graph.metric",
          "default_value": "'minkowski'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "'minkowski'",
            "description": "Metric to use for distance computation. Default is \"minkowski\", which\nresults in the standard Euclidean distance when p = 2. See the\ndocumentation of `scipy.spatial.distance\n<https://docs.scipy.org/doc/scipy/reference/spatial.distance.html>`_ and\nthe metrics listed in\n:class:`~sklearn.metrics.pairwise.distance_metrics` for valid metric\nvalues."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neighbors._graph/radius_neighbors_graph/p",
          "name": "p",
          "qname": "sklearn.neighbors._graph.radius_neighbors_graph.p",
          "default_value": "2",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "2",
            "description": "Power parameter for the Minkowski metric. When p = 1, this is\nequivalent to using manhattan_distance (l1), and euclidean_distance\n(l2) for p = 2. For arbitrary p, minkowski_distance (l_p) is used."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "hasCondition": {
          "condition": "when p equals 2"
        },
        "hasAction": {
          "action": "which results in the standard Euclidean distance"
        }
      }
    ]
  },
  "sklearn/sklearn.neighbors._graph/KNeighborsTransformer/__init__": {
    "n_neighbors": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neighbors._graph/KNeighborsTransformer/__init__/n_neighbors",
          "name": "n_neighbors",
          "qname": "sklearn.neighbors._graph.KNeighborsTransformer.__init__.n_neighbors",
          "default_value": "5",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "5",
            "description": "Number of neighbors for each sample in the transformed sparse graph.\nFor compatibility reasons, as each sample is considered as its own\nneighbor, one extra neighbor will be computed when mode == 'distance'.\nIn this case, the sparse graph contains (n_neighbors + 1) neighbors."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neighbors._graph/KNeighborsTransformer/__init__/mode",
          "name": "mode",
          "qname": "sklearn.neighbors._graph.KNeighborsTransformer.__init__.mode",
          "default_value": "'distance'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'distance', 'connectivity'}",
            "default_value": "'distance'",
            "description": "Type of returned matrix: 'connectivity' will return the connectivity\nmatrix with ones and zeros, and 'distance' will return the distances\nbetween neighbors according to the given metric."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "distance",
              "connectivity"
            ]
          }
        },
        "hasCondition": {
          "condition": "when mode equals distance"
        },
        "hasAction": {
          "action": "For compatibility reasons , as each sample is considered as its own neighbor , one extra neighbor will be computed"
        }
      }
    ],
    "metric": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neighbors._graph/KNeighborsTransformer/__init__/metric",
          "name": "metric",
          "qname": "sklearn.neighbors._graph.KNeighborsTransformer.__init__.metric",
          "default_value": "'minkowski'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'minkowski'",
            "description": "Metric to use for distance computation. Default is \"minkowski\", which\nresults in the standard Euclidean distance when p = 2. See the\ndocumentation of `scipy.spatial.distance\n<https://docs.scipy.org/doc/scipy/reference/spatial.distance.html>`_ and\nthe metrics listed in\n:class:`~sklearn.metrics.pairwise.distance_metrics` for valid metric\nvalues.\n\nIf metric is a callable function, it takes two arrays representing 1D\nvectors as inputs and must return one value indicating the distance\nbetween those vectors. This works for Scipy's metrics, but is less\nefficient than passing the metric name as a string.\n\nDistance matrices are not supported."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neighbors._graph/KNeighborsTransformer/__init__/p",
          "name": "p",
          "qname": "sklearn.neighbors._graph.KNeighborsTransformer.__init__.p",
          "default_value": "2",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "2",
            "description": "Parameter for the Minkowski metric from\nsklearn.metrics.pairwise.pairwise_distances. When p = 1, this is\nequivalent to using manhattan_distance (l1), and euclidean_distance\n(l2) for p = 2. For arbitrary p, minkowski_distance (l_p) is used."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "hasCondition": {
          "condition": "when p equals 2"
        },
        "hasAction": {
          "action": "which results in the standard Euclidean distance"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neighbors._graph/KNeighborsTransformer/__init__/metric",
          "name": "metric",
          "qname": "sklearn.neighbors._graph.KNeighborsTransformer.__init__.metric",
          "default_value": "'minkowski'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'minkowski'",
            "description": "Metric to use for distance computation. Default is \"minkowski\", which\nresults in the standard Euclidean distance when p = 2. See the\ndocumentation of `scipy.spatial.distance\n<https://docs.scipy.org/doc/scipy/reference/spatial.distance.html>`_ and\nthe metrics listed in\n:class:`~sklearn.metrics.pairwise.distance_metrics` for valid metric\nvalues.\n\nIf metric is a callable function, it takes two arrays representing 1D\nvectors as inputs and must return one value indicating the distance\nbetween those vectors. This works for Scipy's metrics, but is less\nefficient than passing the metric name as a string.\n\nDistance matrices are not supported."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neighbors._graph/KNeighborsTransformer/__init__/metric",
          "name": "metric",
          "qname": "sklearn.neighbors._graph.KNeighborsTransformer.__init__.metric",
          "default_value": "'minkowski'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'minkowski'",
            "description": "Metric to use for distance computation. Default is \"minkowski\", which\nresults in the standard Euclidean distance when p = 2. See the\ndocumentation of `scipy.spatial.distance\n<https://docs.scipy.org/doc/scipy/reference/spatial.distance.html>`_ and\nthe metrics listed in\n:class:`~sklearn.metrics.pairwise.distance_metrics` for valid metric\nvalues.\n\nIf metric is a callable function, it takes two arrays representing 1D\nvectors as inputs and must return one value indicating the distance\nbetween those vectors. This works for Scipy's metrics, but is less\nefficient than passing the metric name as a string.\n\nDistance matrices are not supported."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If metric is a callable function"
        },
        "hasAction": {
          "action": ", it takes two arrays representing 1D vectors as inputs and must return one value indicating the distance between those vectors"
        }
      }
    ]
  },
  "sklearn/sklearn.neighbors._graph/KNeighborsTransformer/fit": {},
  "sklearn/sklearn.neighbors._graph/KNeighborsTransformer/transform": {},
  "sklearn/sklearn.neighbors._graph/KNeighborsTransformer/fit_transform": {},
  "sklearn/sklearn.neighbors._graph/KNeighborsTransformer/_more_tags": {},
  "sklearn/sklearn.neighbors._graph/RadiusNeighborsTransformer/__init__": {
    "metric": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neighbors._graph/RadiusNeighborsTransformer/__init__/metric",
          "name": "metric",
          "qname": "sklearn.neighbors._graph.RadiusNeighborsTransformer.__init__.metric",
          "default_value": "'minkowski'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'minkowski'",
            "description": "Metric to use for distance computation. Default is \"minkowski\", which\nresults in the standard Euclidean distance when p = 2. See the\ndocumentation of `scipy.spatial.distance\n<https://docs.scipy.org/doc/scipy/reference/spatial.distance.html>`_ and\nthe metrics listed in\n:class:`~sklearn.metrics.pairwise.distance_metrics` for valid metric\nvalues.\n\nIf metric is a callable function, it takes two arrays representing 1D\nvectors as inputs and must return one value indicating the distance\nbetween those vectors. This works for Scipy's metrics, but is less\nefficient than passing the metric name as a string.\n\nDistance matrices are not supported."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neighbors._graph/RadiusNeighborsTransformer/__init__/p",
          "name": "p",
          "qname": "sklearn.neighbors._graph.RadiusNeighborsTransformer.__init__.p",
          "default_value": "2",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "2",
            "description": "Parameter for the Minkowski metric from\nsklearn.metrics.pairwise.pairwise_distances. When p = 1, this is\nequivalent to using manhattan_distance (l1), and euclidean_distance\n(l2) for p = 2. For arbitrary p, minkowski_distance (l_p) is used."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "hasCondition": {
          "condition": "when p equals 2"
        },
        "hasAction": {
          "action": "which results in the standard Euclidean distance"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neighbors._graph/RadiusNeighborsTransformer/__init__/metric",
          "name": "metric",
          "qname": "sklearn.neighbors._graph.RadiusNeighborsTransformer.__init__.metric",
          "default_value": "'minkowski'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'minkowski'",
            "description": "Metric to use for distance computation. Default is \"minkowski\", which\nresults in the standard Euclidean distance when p = 2. See the\ndocumentation of `scipy.spatial.distance\n<https://docs.scipy.org/doc/scipy/reference/spatial.distance.html>`_ and\nthe metrics listed in\n:class:`~sklearn.metrics.pairwise.distance_metrics` for valid metric\nvalues.\n\nIf metric is a callable function, it takes two arrays representing 1D\nvectors as inputs and must return one value indicating the distance\nbetween those vectors. This works for Scipy's metrics, but is less\nefficient than passing the metric name as a string.\n\nDistance matrices are not supported."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neighbors._graph/RadiusNeighborsTransformer/__init__/metric",
          "name": "metric",
          "qname": "sklearn.neighbors._graph.RadiusNeighborsTransformer.__init__.metric",
          "default_value": "'minkowski'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'minkowski'",
            "description": "Metric to use for distance computation. Default is \"minkowski\", which\nresults in the standard Euclidean distance when p = 2. See the\ndocumentation of `scipy.spatial.distance\n<https://docs.scipy.org/doc/scipy/reference/spatial.distance.html>`_ and\nthe metrics listed in\n:class:`~sklearn.metrics.pairwise.distance_metrics` for valid metric\nvalues.\n\nIf metric is a callable function, it takes two arrays representing 1D\nvectors as inputs and must return one value indicating the distance\nbetween those vectors. This works for Scipy's metrics, but is less\nefficient than passing the metric name as a string.\n\nDistance matrices are not supported."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If metric is a callable function"
        },
        "hasAction": {
          "action": ", it takes two arrays representing 1D vectors as inputs and must return one value indicating the distance between those vectors"
        }
      }
    ]
  },
  "sklearn/sklearn.neighbors._graph/RadiusNeighborsTransformer/fit": {},
  "sklearn/sklearn.neighbors._graph/RadiusNeighborsTransformer/transform": {},
  "sklearn/sklearn.neighbors._graph/RadiusNeighborsTransformer/fit_transform": {},
  "sklearn/sklearn.neighbors._graph/RadiusNeighborsTransformer/_more_tags": {},
  "sklearn/sklearn.neighbors._kde/KernelDensity/__init__": {
    "bandwidth": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neighbors._kde/KernelDensity/__init__/bandwidth",
          "name": "bandwidth",
          "qname": "sklearn.neighbors._kde.KernelDensity.__init__.bandwidth",
          "default_value": "1.0",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float or {\"scott\", \"silverman\"}",
            "default_value": "1.0",
            "description": "The bandwidth of the kernel. If bandwidth is a float, it defines the\nbandwidth of the kernel. If bandwidth is a string, one of the estimation\nmethods is implemented."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "EnumType",
                "values": [
                  "silverman",
                  "scott"
                ]
              },
              {
                "kind": "NamedType",
                "name": "float"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neighbors._kde/KernelDensity/__init__/bandwidth",
          "name": "bandwidth",
          "qname": "sklearn.neighbors._kde.KernelDensity.__init__.bandwidth",
          "default_value": "1.0",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float or {\"scott\", \"silverman\"}",
            "default_value": "1.0",
            "description": "The bandwidth of the kernel. If bandwidth is a float, it defines the\nbandwidth of the kernel. If bandwidth is a string, one of the estimation\nmethods is implemented."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "EnumType",
                "values": [
                  "silverman",
                  "scott"
                ]
              },
              {
                "kind": "NamedType",
                "name": "float"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If bandwidth is a string"
        },
        "hasAction": {
          "action": ", one of the estimation methods is implemented"
        }
      }
    ]
  },
  "sklearn/sklearn.neighbors._kde/KernelDensity/_choose_algorithm": {},
  "sklearn/sklearn.neighbors._kde/KernelDensity/fit": {},
  "sklearn/sklearn.neighbors._kde/KernelDensity/score_samples": {},
  "sklearn/sklearn.neighbors._kde/KernelDensity/score": {},
  "sklearn/sklearn.neighbors._kde/KernelDensity/sample": {},
  "sklearn/sklearn.neighbors._kde/KernelDensity/_more_tags": {},
  "sklearn/sklearn.neighbors._lof/LocalOutlierFactor/__init__": {
    "n_neighbors": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neighbors._lof/LocalOutlierFactor/__init__/n_neighbors",
          "name": "n_neighbors",
          "qname": "sklearn.neighbors._lof.LocalOutlierFactor.__init__.n_neighbors",
          "default_value": "20",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "20",
            "description": "Number of neighbors to use by default for :meth:`kneighbors` queries.\nIf n_neighbors is larger than the number of samples provided,\nall samples will be used."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neighbors._lof/LocalOutlierFactor/__init__/n_neighbors",
          "name": "n_neighbors",
          "qname": "sklearn.neighbors._lof.LocalOutlierFactor.__init__.n_neighbors",
          "default_value": "20",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "20",
            "description": "Number of neighbors to use by default for :meth:`kneighbors` queries.\nIf n_neighbors is larger than the number of samples provided,\nall samples will be used."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "hasCondition": {
          "condition": "If n_neighbors is larger than the number of samples provided"
        },
        "hasAction": {
          "action": ", all samples will be used"
        }
      }
    ],
    "metric": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neighbors._lof/LocalOutlierFactor/__init__/metric",
          "name": "metric",
          "qname": "sklearn.neighbors._lof.LocalOutlierFactor.__init__.metric",
          "default_value": "'minkowski'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'minkowski'",
            "description": "Metric to use for distance computation. Default is \"minkowski\", which\nresults in the standard Euclidean distance when p = 2. See the\ndocumentation of `scipy.spatial.distance\n<https://docs.scipy.org/doc/scipy/reference/spatial.distance.html>`_ and\nthe metrics listed in\n:class:`~sklearn.metrics.pairwise.distance_metrics` for valid metric\nvalues.\n\nIf metric is \"precomputed\", X is assumed to be a distance matrix and\nmust be square during fit. X may be a :term:`sparse graph`, in which\ncase only \"nonzero\" elements may be considered neighbors.\n\nIf metric is a callable function, it takes two arrays representing 1D\nvectors as inputs and must return one value indicating the distance\nbetween those vectors. This works for Scipy's metrics, but is less\nefficient than passing the metric name as a string."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neighbors._lof/LocalOutlierFactor/__init__/p",
          "name": "p",
          "qname": "sklearn.neighbors._lof.LocalOutlierFactor.__init__.p",
          "default_value": "2",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "2",
            "description": "Parameter for the Minkowski metric from\n:func:`sklearn.metrics.pairwise.pairwise_distances`. When p = 1, this\nis equivalent to using manhattan_distance (l1), and euclidean_distance\n(l2) for p = 2. For arbitrary p, minkowski_distance (l_p) is used."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "hasCondition": {
          "condition": "when p equals 2"
        },
        "hasAction": {
          "action": "which results in the standard Euclidean distance"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neighbors._lof/LocalOutlierFactor/__init__/metric",
          "name": "metric",
          "qname": "sklearn.neighbors._lof.LocalOutlierFactor.__init__.metric",
          "default_value": "'minkowski'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'minkowski'",
            "description": "Metric to use for distance computation. Default is \"minkowski\", which\nresults in the standard Euclidean distance when p = 2. See the\ndocumentation of `scipy.spatial.distance\n<https://docs.scipy.org/doc/scipy/reference/spatial.distance.html>`_ and\nthe metrics listed in\n:class:`~sklearn.metrics.pairwise.distance_metrics` for valid metric\nvalues.\n\nIf metric is \"precomputed\", X is assumed to be a distance matrix and\nmust be square during fit. X may be a :term:`sparse graph`, in which\ncase only \"nonzero\" elements may be considered neighbors.\n\nIf metric is a callable function, it takes two arrays representing 1D\nvectors as inputs and must return one value indicating the distance\nbetween those vectors. This works for Scipy's metrics, but is less\nefficient than passing the metric name as a string."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neighbors._lof/LocalOutlierFactor/__init__/metric",
          "name": "metric",
          "qname": "sklearn.neighbors._lof.LocalOutlierFactor.__init__.metric",
          "default_value": "'minkowski'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'minkowski'",
            "description": "Metric to use for distance computation. Default is \"minkowski\", which\nresults in the standard Euclidean distance when p = 2. See the\ndocumentation of `scipy.spatial.distance\n<https://docs.scipy.org/doc/scipy/reference/spatial.distance.html>`_ and\nthe metrics listed in\n:class:`~sklearn.metrics.pairwise.distance_metrics` for valid metric\nvalues.\n\nIf metric is \"precomputed\", X is assumed to be a distance matrix and\nmust be square during fit. X may be a :term:`sparse graph`, in which\ncase only \"nonzero\" elements may be considered neighbors.\n\nIf metric is a callable function, it takes two arrays representing 1D\nvectors as inputs and must return one value indicating the distance\nbetween those vectors. This works for Scipy's metrics, but is less\nefficient than passing the metric name as a string."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If metric is precomputed"
        },
        "hasAction": {
          "action": ", X is assumed to be a distance matrix and must be square during fit"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neighbors._lof/LocalOutlierFactor/__init__/metric",
          "name": "metric",
          "qname": "sklearn.neighbors._lof.LocalOutlierFactor.__init__.metric",
          "default_value": "'minkowski'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'minkowski'",
            "description": "Metric to use for distance computation. Default is \"minkowski\", which\nresults in the standard Euclidean distance when p = 2. See the\ndocumentation of `scipy.spatial.distance\n<https://docs.scipy.org/doc/scipy/reference/spatial.distance.html>`_ and\nthe metrics listed in\n:class:`~sklearn.metrics.pairwise.distance_metrics` for valid metric\nvalues.\n\nIf metric is \"precomputed\", X is assumed to be a distance matrix and\nmust be square during fit. X may be a :term:`sparse graph`, in which\ncase only \"nonzero\" elements may be considered neighbors.\n\nIf metric is a callable function, it takes two arrays representing 1D\nvectors as inputs and must return one value indicating the distance\nbetween those vectors. This works for Scipy's metrics, but is less\nefficient than passing the metric name as a string."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neighbors._lof/LocalOutlierFactor/__init__/metric",
          "name": "metric",
          "qname": "sklearn.neighbors._lof.LocalOutlierFactor.__init__.metric",
          "default_value": "'minkowski'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'minkowski'",
            "description": "Metric to use for distance computation. Default is \"minkowski\", which\nresults in the standard Euclidean distance when p = 2. See the\ndocumentation of `scipy.spatial.distance\n<https://docs.scipy.org/doc/scipy/reference/spatial.distance.html>`_ and\nthe metrics listed in\n:class:`~sklearn.metrics.pairwise.distance_metrics` for valid metric\nvalues.\n\nIf metric is \"precomputed\", X is assumed to be a distance matrix and\nmust be square during fit. X may be a :term:`sparse graph`, in which\ncase only \"nonzero\" elements may be considered neighbors.\n\nIf metric is a callable function, it takes two arrays representing 1D\nvectors as inputs and must return one value indicating the distance\nbetween those vectors. This works for Scipy's metrics, but is less\nefficient than passing the metric name as a string."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If metric is a callable function"
        },
        "hasAction": {
          "action": ", it takes two arrays representing 1D vectors as inputs and must return one value indicating the distance between those vectors"
        }
      }
    ],
    "contamination": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neighbors._lof/LocalOutlierFactor/__init__/contamination",
          "name": "contamination",
          "qname": "sklearn.neighbors._lof.LocalOutlierFactor.__init__.contamination",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "'auto' or float",
            "default_value": "'auto'",
            "description": "The amount of contamination of the data set, i.e. the proportion\nof outliers in the data set. When fitting this is used to define the\nthreshold on the scores of the samples.\n\n- if 'auto', the threshold is determined as in the\n  original paper,\n- if a float, the contamination should be in the range (0, 0.5].\n\n.. versionchanged:: 0.22\n   The default value of ``contamination`` changed from 0.1\n   to ``'auto'``."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "BoundaryType",
                "base_type": "float",
                "min": 0.0,
                "max": 0.5,
                "min_inclusive": false,
                "max_inclusive": true
              },
              {
                "kind": "NamedType",
                "name": "'auto'"
              },
              {
                "kind": "NamedType",
                "name": "float"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neighbors._lof/LocalOutlierFactor/__init__/contamination",
          "name": "contamination",
          "qname": "sklearn.neighbors._lof.LocalOutlierFactor.__init__.contamination",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "'auto' or float",
            "default_value": "'auto'",
            "description": "The amount of contamination of the data set, i.e. the proportion\nof outliers in the data set. When fitting this is used to define the\nthreshold on the scores of the samples.\n\n- if 'auto', the threshold is determined as in the\n  original paper,\n- if a float, the contamination should be in the range (0, 0.5].\n\n.. versionchanged:: 0.22\n   The default value of ``contamination`` changed from 0.1\n   to ``'auto'``."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "BoundaryType",
                "base_type": "float",
                "min": 0.0,
                "max": 0.5,
                "min_inclusive": false,
                "max_inclusive": true
              },
              {
                "kind": "NamedType",
                "name": "'auto'"
              },
              {
                "kind": "NamedType",
                "name": "float"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "if a float , the contamination should be in the range ( 0 , 0.5 ]"
        },
        "hasAction": {
          "action": "- if auto , the threshold is determined as in the original paper , -"
        }
      }
    ]
  },
  "sklearn/sklearn.neighbors._lof/LocalOutlierFactor/_check_novelty_fit_predict": {},
  "sklearn/sklearn.neighbors._lof/LocalOutlierFactor/fit_predict": {},
  "sklearn/sklearn.neighbors._lof/LocalOutlierFactor/fit": {},
  "sklearn/sklearn.neighbors._lof/LocalOutlierFactor/_check_novelty_predict": {},
  "sklearn/sklearn.neighbors._lof/LocalOutlierFactor/predict": {},
  "sklearn/sklearn.neighbors._lof/LocalOutlierFactor/_predict": {},
  "sklearn/sklearn.neighbors._lof/LocalOutlierFactor/_check_novelty_decision_function": {},
  "sklearn/sklearn.neighbors._lof/LocalOutlierFactor/decision_function": {},
  "sklearn/sklearn.neighbors._lof/LocalOutlierFactor/_check_novelty_score_samples": {},
  "sklearn/sklearn.neighbors._lof/LocalOutlierFactor/score_samples": {},
  "sklearn/sklearn.neighbors._lof/LocalOutlierFactor/_local_reachability_density": {},
  "sklearn/sklearn.neighbors._lof/LocalOutlierFactor/_more_tags": {},
  "sklearn/sklearn.neighbors._nca/NeighborhoodComponentsAnalysis/__init__": {
    "init": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neighbors._nca/NeighborhoodComponentsAnalysis/__init__/init",
          "name": "init",
          "qname": "sklearn.neighbors._nca.NeighborhoodComponentsAnalysis.__init__.init",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'auto', 'pca', 'lda', 'identity', 'random'} or ndarray of shape             (n_features_a, n_features_b)",
            "default_value": "'auto'",
            "description": "Initialization of the linear transformation. Possible options are\n`'auto'`, `'pca'`, `'lda'`, `'identity'`, `'random'`, and a numpy\narray of shape `(n_features_a, n_features_b)`.\n\n- `'auto'`\n    Depending on `n_components`, the most reasonable initialization\n    will be chosen. If `n_components <= n_classes` we use `'lda'`, as\n    it uses labels information. If not, but\n    `n_components < min(n_features, n_samples)`, we use `'pca'`, as\n    it projects data in meaningful directions (those of higher\n    variance). Otherwise, we just use `'identity'`.\n\n- `'pca'`\n    `n_components` principal components of the inputs passed\n    to :meth:`fit` will be used to initialize the transformation.\n    (See :class:`~sklearn.decomposition.PCA`)\n\n- `'lda'`\n    `min(n_components, n_classes)` most discriminative\n    components of the inputs passed to :meth:`fit` will be used to\n    initialize the transformation. (If `n_components > n_classes`,\n    the rest of the components will be zero.) (See\n    :class:`~sklearn.discriminant_analysis.LinearDiscriminantAnalysis`)\n\n- `'identity'`\n    If `n_components` is strictly smaller than the\n    dimensionality of the inputs passed to :meth:`fit`, the identity\n    matrix will be truncated to the first `n_components` rows.\n\n- `'random'`\n    The initial transformation will be a random array of shape\n    `(n_components, n_features)`. Each value is sampled from the\n    standard normal distribution.\n\n- numpy array\n    `n_features_b` must match the dimensionality of the inputs passed\n    to :meth:`fit` and n_features_a must be less than or equal to that.\n    If `n_components` is not `None`, `n_features_a` must match it."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "EnumType",
                "values": [
                  "identity",
                  "lda",
                  "auto",
                  "pca",
                  "random"
                ]
              },
              {
                "kind": "NamedType",
                "name": "ndarray of shape (n_features_a, n_features_b)"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neighbors._nca/NeighborhoodComponentsAnalysis/__init__/n_components",
          "name": "n_components",
          "qname": "sklearn.neighbors._nca.NeighborhoodComponentsAnalysis.__init__.n_components",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "None",
            "description": "Preferred dimensionality of the projected space.\nIf None it will be set to `n_features`."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "hasCondition": {
          "condition": "If n_components is strictly smaller than the dimensionality of the inputs"
        },
        "hasAction": {
          "action": "LinearDiscriminantAnalysis ) - identity meth : fit passed to :"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neighbors._nca/NeighborhoodComponentsAnalysis/__init__/init",
          "name": "init",
          "qname": "sklearn.neighbors._nca.NeighborhoodComponentsAnalysis.__init__.init",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'auto', 'pca', 'lda', 'identity', 'random'} or ndarray of shape             (n_features_a, n_features_b)",
            "default_value": "'auto'",
            "description": "Initialization of the linear transformation. Possible options are\n`'auto'`, `'pca'`, `'lda'`, `'identity'`, `'random'`, and a numpy\narray of shape `(n_features_a, n_features_b)`.\n\n- `'auto'`\n    Depending on `n_components`, the most reasonable initialization\n    will be chosen. If `n_components <= n_classes` we use `'lda'`, as\n    it uses labels information. If not, but\n    `n_components < min(n_features, n_samples)`, we use `'pca'`, as\n    it projects data in meaningful directions (those of higher\n    variance). Otherwise, we just use `'identity'`.\n\n- `'pca'`\n    `n_components` principal components of the inputs passed\n    to :meth:`fit` will be used to initialize the transformation.\n    (See :class:`~sklearn.decomposition.PCA`)\n\n- `'lda'`\n    `min(n_components, n_classes)` most discriminative\n    components of the inputs passed to :meth:`fit` will be used to\n    initialize the transformation. (If `n_components > n_classes`,\n    the rest of the components will be zero.) (See\n    :class:`~sklearn.discriminant_analysis.LinearDiscriminantAnalysis`)\n\n- `'identity'`\n    If `n_components` is strictly smaller than the\n    dimensionality of the inputs passed to :meth:`fit`, the identity\n    matrix will be truncated to the first `n_components` rows.\n\n- `'random'`\n    The initial transformation will be a random array of shape\n    `(n_components, n_features)`. Each value is sampled from the\n    standard normal distribution.\n\n- numpy array\n    `n_features_b` must match the dimensionality of the inputs passed\n    to :meth:`fit` and n_features_a must be less than or equal to that.\n    If `n_components` is not `None`, `n_features_a` must match it."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "EnumType",
                "values": [
                  "identity",
                  "lda",
                  "auto",
                  "pca",
                  "random"
                ]
              },
              {
                "kind": "NamedType",
                "name": "ndarray of shape (n_features_a, n_features_b)"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neighbors._nca/NeighborhoodComponentsAnalysis/__init__/n_components",
          "name": "n_components",
          "qname": "sklearn.neighbors._nca.NeighborhoodComponentsAnalysis.__init__.n_components",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "None",
            "description": "Preferred dimensionality of the projected space.\nIf None it will be set to `n_features`."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "hasCondition": {
          "condition": "If n_components is not None"
        },
        "hasAction": {
          "action": ", n_features_a must match it"
        }
      }
    ],
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neighbors._nca/NeighborhoodComponentsAnalysis/__init__/random_state",
          "name": "random_state",
          "qname": "sklearn.neighbors._nca.NeighborhoodComponentsAnalysis.__init__.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int or numpy.RandomState",
            "default_value": "None",
            "description": "A pseudo random number generator object or a seed for it if int. If\n`init='random'`, `random_state` is used to initialize the random\ntransformation. If `init='pca'`, `random_state` is passed as an\nargument to PCA when initializing the transformation. Pass an int\nfor reproducible results across multiple function calls.\nSee :term:`Glossary <random_state>`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "numpy.RandomState"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neighbors._nca/NeighborhoodComponentsAnalysis/__init__/init",
          "name": "init",
          "qname": "sklearn.neighbors._nca.NeighborhoodComponentsAnalysis.__init__.init",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'auto', 'pca', 'lda', 'identity', 'random'} or ndarray of shape             (n_features_a, n_features_b)",
            "default_value": "'auto'",
            "description": "Initialization of the linear transformation. Possible options are\n`'auto'`, `'pca'`, `'lda'`, `'identity'`, `'random'`, and a numpy\narray of shape `(n_features_a, n_features_b)`.\n\n- `'auto'`\n    Depending on `n_components`, the most reasonable initialization\n    will be chosen. If `n_components <= n_classes` we use `'lda'`, as\n    it uses labels information. If not, but\n    `n_components < min(n_features, n_samples)`, we use `'pca'`, as\n    it projects data in meaningful directions (those of higher\n    variance). Otherwise, we just use `'identity'`.\n\n- `'pca'`\n    `n_components` principal components of the inputs passed\n    to :meth:`fit` will be used to initialize the transformation.\n    (See :class:`~sklearn.decomposition.PCA`)\n\n- `'lda'`\n    `min(n_components, n_classes)` most discriminative\n    components of the inputs passed to :meth:`fit` will be used to\n    initialize the transformation. (If `n_components > n_classes`,\n    the rest of the components will be zero.) (See\n    :class:`~sklearn.discriminant_analysis.LinearDiscriminantAnalysis`)\n\n- `'identity'`\n    If `n_components` is strictly smaller than the\n    dimensionality of the inputs passed to :meth:`fit`, the identity\n    matrix will be truncated to the first `n_components` rows.\n\n- `'random'`\n    The initial transformation will be a random array of shape\n    `(n_components, n_features)`. Each value is sampled from the\n    standard normal distribution.\n\n- numpy array\n    `n_features_b` must match the dimensionality of the inputs passed\n    to :meth:`fit` and n_features_a must be less than or equal to that.\n    If `n_components` is not `None`, `n_features_a` must match it."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "EnumType",
                "values": [
                  "identity",
                  "lda",
                  "auto",
                  "pca",
                  "random"
                ]
              },
              {
                "kind": "NamedType",
                "name": "ndarray of shape (n_features_a, n_features_b)"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If init equals random"
        },
        "hasAction": {
          "action": ", random_state is used to initialize the random transformation"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neighbors._nca/NeighborhoodComponentsAnalysis/__init__/random_state",
          "name": "random_state",
          "qname": "sklearn.neighbors._nca.NeighborhoodComponentsAnalysis.__init__.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int or numpy.RandomState",
            "default_value": "None",
            "description": "A pseudo random number generator object or a seed for it if int. If\n`init='random'`, `random_state` is used to initialize the random\ntransformation. If `init='pca'`, `random_state` is passed as an\nargument to PCA when initializing the transformation. Pass an int\nfor reproducible results across multiple function calls.\nSee :term:`Glossary <random_state>`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "numpy.RandomState"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neighbors._nca/NeighborhoodComponentsAnalysis/__init__/init",
          "name": "init",
          "qname": "sklearn.neighbors._nca.NeighborhoodComponentsAnalysis.__init__.init",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'auto', 'pca', 'lda', 'identity', 'random'} or ndarray of shape             (n_features_a, n_features_b)",
            "default_value": "'auto'",
            "description": "Initialization of the linear transformation. Possible options are\n`'auto'`, `'pca'`, `'lda'`, `'identity'`, `'random'`, and a numpy\narray of shape `(n_features_a, n_features_b)`.\n\n- `'auto'`\n    Depending on `n_components`, the most reasonable initialization\n    will be chosen. If `n_components <= n_classes` we use `'lda'`, as\n    it uses labels information. If not, but\n    `n_components < min(n_features, n_samples)`, we use `'pca'`, as\n    it projects data in meaningful directions (those of higher\n    variance). Otherwise, we just use `'identity'`.\n\n- `'pca'`\n    `n_components` principal components of the inputs passed\n    to :meth:`fit` will be used to initialize the transformation.\n    (See :class:`~sklearn.decomposition.PCA`)\n\n- `'lda'`\n    `min(n_components, n_classes)` most discriminative\n    components of the inputs passed to :meth:`fit` will be used to\n    initialize the transformation. (If `n_components > n_classes`,\n    the rest of the components will be zero.) (See\n    :class:`~sklearn.discriminant_analysis.LinearDiscriminantAnalysis`)\n\n- `'identity'`\n    If `n_components` is strictly smaller than the\n    dimensionality of the inputs passed to :meth:`fit`, the identity\n    matrix will be truncated to the first `n_components` rows.\n\n- `'random'`\n    The initial transformation will be a random array of shape\n    `(n_components, n_features)`. Each value is sampled from the\n    standard normal distribution.\n\n- numpy array\n    `n_features_b` must match the dimensionality of the inputs passed\n    to :meth:`fit` and n_features_a must be less than or equal to that.\n    If `n_components` is not `None`, `n_features_a` must match it."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "EnumType",
                "values": [
                  "identity",
                  "lda",
                  "auto",
                  "pca",
                  "random"
                ]
              },
              {
                "kind": "NamedType",
                "name": "ndarray of shape (n_features_a, n_features_b)"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If init equals pca"
        },
        "hasAction": {
          "action": ", random_state is passed as an argument to PCA when initializing the transformation"
        }
      }
    ]
  },
  "sklearn/sklearn.neighbors._nca/NeighborhoodComponentsAnalysis/fit": {},
  "sklearn/sklearn.neighbors._nca/NeighborhoodComponentsAnalysis/transform": {},
  "sklearn/sklearn.neighbors._nca/NeighborhoodComponentsAnalysis/_initialize": {},
  "sklearn/sklearn.neighbors._nca/NeighborhoodComponentsAnalysis/_callback": {},
  "sklearn/sklearn.neighbors._nca/NeighborhoodComponentsAnalysis/_loss_grad_lbfgs": {},
  "sklearn/sklearn.neighbors._nca/NeighborhoodComponentsAnalysis/_more_tags": {},
  "sklearn/sklearn.neighbors._nearest_centroid/NearestCentroid/__init__": {},
  "sklearn/sklearn.neighbors._nearest_centroid/NearestCentroid/fit": {},
  "sklearn/sklearn.neighbors._nearest_centroid/NearestCentroid/predict": {},
  "sklearn/sklearn.neighbors._regression/KNeighborsRegressor/__init__": {
    "metric": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neighbors._regression/KNeighborsRegressor/__init__/metric",
          "name": "metric",
          "qname": "sklearn.neighbors._regression.KNeighborsRegressor.__init__.metric",
          "default_value": "'minkowski'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'minkowski'",
            "description": "Metric to use for distance computation. Default is \"minkowski\", which\nresults in the standard Euclidean distance when p = 2. See the\ndocumentation of `scipy.spatial.distance\n<https://docs.scipy.org/doc/scipy/reference/spatial.distance.html>`_ and\nthe metrics listed in\n:class:`~sklearn.metrics.pairwise.distance_metrics` for valid metric\nvalues.\n\nIf metric is \"precomputed\", X is assumed to be a distance matrix and\nmust be square during fit. X may be a :term:`sparse graph`, in which\ncase only \"nonzero\" elements may be considered neighbors.\n\nIf metric is a callable function, it takes two arrays representing 1D\nvectors as inputs and must return one value indicating the distance\nbetween those vectors. This works for Scipy's metrics, but is less\nefficient than passing the metric name as a string."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neighbors._regression/KNeighborsRegressor/__init__/p",
          "name": "p",
          "qname": "sklearn.neighbors._regression.KNeighborsRegressor.__init__.p",
          "default_value": "2",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "2",
            "description": "Power parameter for the Minkowski metric. When p = 1, this is\nequivalent to using manhattan_distance (l1), and euclidean_distance\n(l2) for p = 2. For arbitrary p, minkowski_distance (l_p) is used."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "hasCondition": {
          "condition": "when p equals 2"
        },
        "hasAction": {
          "action": "which results in the standard Euclidean distance"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neighbors._regression/KNeighborsRegressor/__init__/metric",
          "name": "metric",
          "qname": "sklearn.neighbors._regression.KNeighborsRegressor.__init__.metric",
          "default_value": "'minkowski'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'minkowski'",
            "description": "Metric to use for distance computation. Default is \"minkowski\", which\nresults in the standard Euclidean distance when p = 2. See the\ndocumentation of `scipy.spatial.distance\n<https://docs.scipy.org/doc/scipy/reference/spatial.distance.html>`_ and\nthe metrics listed in\n:class:`~sklearn.metrics.pairwise.distance_metrics` for valid metric\nvalues.\n\nIf metric is \"precomputed\", X is assumed to be a distance matrix and\nmust be square during fit. X may be a :term:`sparse graph`, in which\ncase only \"nonzero\" elements may be considered neighbors.\n\nIf metric is a callable function, it takes two arrays representing 1D\nvectors as inputs and must return one value indicating the distance\nbetween those vectors. This works for Scipy's metrics, but is less\nefficient than passing the metric name as a string."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neighbors._regression/KNeighborsRegressor/__init__/metric",
          "name": "metric",
          "qname": "sklearn.neighbors._regression.KNeighborsRegressor.__init__.metric",
          "default_value": "'minkowski'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'minkowski'",
            "description": "Metric to use for distance computation. Default is \"minkowski\", which\nresults in the standard Euclidean distance when p = 2. See the\ndocumentation of `scipy.spatial.distance\n<https://docs.scipy.org/doc/scipy/reference/spatial.distance.html>`_ and\nthe metrics listed in\n:class:`~sklearn.metrics.pairwise.distance_metrics` for valid metric\nvalues.\n\nIf metric is \"precomputed\", X is assumed to be a distance matrix and\nmust be square during fit. X may be a :term:`sparse graph`, in which\ncase only \"nonzero\" elements may be considered neighbors.\n\nIf metric is a callable function, it takes two arrays representing 1D\nvectors as inputs and must return one value indicating the distance\nbetween those vectors. This works for Scipy's metrics, but is less\nefficient than passing the metric name as a string."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If metric is precomputed"
        },
        "hasAction": {
          "action": ", X is assumed to be a distance matrix and must be square during fit"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neighbors._regression/KNeighborsRegressor/__init__/metric",
          "name": "metric",
          "qname": "sklearn.neighbors._regression.KNeighborsRegressor.__init__.metric",
          "default_value": "'minkowski'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'minkowski'",
            "description": "Metric to use for distance computation. Default is \"minkowski\", which\nresults in the standard Euclidean distance when p = 2. See the\ndocumentation of `scipy.spatial.distance\n<https://docs.scipy.org/doc/scipy/reference/spatial.distance.html>`_ and\nthe metrics listed in\n:class:`~sklearn.metrics.pairwise.distance_metrics` for valid metric\nvalues.\n\nIf metric is \"precomputed\", X is assumed to be a distance matrix and\nmust be square during fit. X may be a :term:`sparse graph`, in which\ncase only \"nonzero\" elements may be considered neighbors.\n\nIf metric is a callable function, it takes two arrays representing 1D\nvectors as inputs and must return one value indicating the distance\nbetween those vectors. This works for Scipy's metrics, but is less\nefficient than passing the metric name as a string."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neighbors._regression/KNeighborsRegressor/__init__/metric",
          "name": "metric",
          "qname": "sklearn.neighbors._regression.KNeighborsRegressor.__init__.metric",
          "default_value": "'minkowski'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'minkowski'",
            "description": "Metric to use for distance computation. Default is \"minkowski\", which\nresults in the standard Euclidean distance when p = 2. See the\ndocumentation of `scipy.spatial.distance\n<https://docs.scipy.org/doc/scipy/reference/spatial.distance.html>`_ and\nthe metrics listed in\n:class:`~sklearn.metrics.pairwise.distance_metrics` for valid metric\nvalues.\n\nIf metric is \"precomputed\", X is assumed to be a distance matrix and\nmust be square during fit. X may be a :term:`sparse graph`, in which\ncase only \"nonzero\" elements may be considered neighbors.\n\nIf metric is a callable function, it takes two arrays representing 1D\nvectors as inputs and must return one value indicating the distance\nbetween those vectors. This works for Scipy's metrics, but is less\nefficient than passing the metric name as a string."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If metric is a callable function"
        },
        "hasAction": {
          "action": ", it takes two arrays representing 1D vectors as inputs and must return one value indicating the distance between those vectors"
        }
      }
    ]
  },
  "sklearn/sklearn.neighbors._regression/KNeighborsRegressor/_more_tags": {},
  "sklearn/sklearn.neighbors._regression/KNeighborsRegressor/fit": {},
  "sklearn/sklearn.neighbors._regression/KNeighborsRegressor/predict": {},
  "sklearn/sklearn.neighbors._regression/RadiusNeighborsRegressor/__init__": {
    "metric": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neighbors._regression/RadiusNeighborsRegressor/__init__/metric",
          "name": "metric",
          "qname": "sklearn.neighbors._regression.RadiusNeighborsRegressor.__init__.metric",
          "default_value": "'minkowski'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'minkowski'",
            "description": "Metric to use for distance computation. Default is \"minkowski\", which\nresults in the standard Euclidean distance when p = 2. See the\ndocumentation of `scipy.spatial.distance\n<https://docs.scipy.org/doc/scipy/reference/spatial.distance.html>`_ and\nthe metrics listed in\n:class:`~sklearn.metrics.pairwise.distance_metrics` for valid metric\nvalues.\n\nIf metric is \"precomputed\", X is assumed to be a distance matrix and\nmust be square during fit. X may be a :term:`sparse graph`, in which\ncase only \"nonzero\" elements may be considered neighbors.\n\nIf metric is a callable function, it takes two arrays representing 1D\nvectors as inputs and must return one value indicating the distance\nbetween those vectors. This works for Scipy's metrics, but is less\nefficient than passing the metric name as a string."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neighbors._regression/RadiusNeighborsRegressor/__init__/p",
          "name": "p",
          "qname": "sklearn.neighbors._regression.RadiusNeighborsRegressor.__init__.p",
          "default_value": "2",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "2",
            "description": "Power parameter for the Minkowski metric. When p = 1, this is\nequivalent to using manhattan_distance (l1), and euclidean_distance\n(l2) for p = 2. For arbitrary p, minkowski_distance (l_p) is used."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "hasCondition": {
          "condition": "when p equals 2"
        },
        "hasAction": {
          "action": "which results in the standard Euclidean distance"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neighbors._regression/RadiusNeighborsRegressor/__init__/metric",
          "name": "metric",
          "qname": "sklearn.neighbors._regression.RadiusNeighborsRegressor.__init__.metric",
          "default_value": "'minkowski'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'minkowski'",
            "description": "Metric to use for distance computation. Default is \"minkowski\", which\nresults in the standard Euclidean distance when p = 2. See the\ndocumentation of `scipy.spatial.distance\n<https://docs.scipy.org/doc/scipy/reference/spatial.distance.html>`_ and\nthe metrics listed in\n:class:`~sklearn.metrics.pairwise.distance_metrics` for valid metric\nvalues.\n\nIf metric is \"precomputed\", X is assumed to be a distance matrix and\nmust be square during fit. X may be a :term:`sparse graph`, in which\ncase only \"nonzero\" elements may be considered neighbors.\n\nIf metric is a callable function, it takes two arrays representing 1D\nvectors as inputs and must return one value indicating the distance\nbetween those vectors. This works for Scipy's metrics, but is less\nefficient than passing the metric name as a string."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neighbors._regression/RadiusNeighborsRegressor/__init__/metric",
          "name": "metric",
          "qname": "sklearn.neighbors._regression.RadiusNeighborsRegressor.__init__.metric",
          "default_value": "'minkowski'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'minkowski'",
            "description": "Metric to use for distance computation. Default is \"minkowski\", which\nresults in the standard Euclidean distance when p = 2. See the\ndocumentation of `scipy.spatial.distance\n<https://docs.scipy.org/doc/scipy/reference/spatial.distance.html>`_ and\nthe metrics listed in\n:class:`~sklearn.metrics.pairwise.distance_metrics` for valid metric\nvalues.\n\nIf metric is \"precomputed\", X is assumed to be a distance matrix and\nmust be square during fit. X may be a :term:`sparse graph`, in which\ncase only \"nonzero\" elements may be considered neighbors.\n\nIf metric is a callable function, it takes two arrays representing 1D\nvectors as inputs and must return one value indicating the distance\nbetween those vectors. This works for Scipy's metrics, but is less\nefficient than passing the metric name as a string."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If metric is precomputed"
        },
        "hasAction": {
          "action": ", X is assumed to be a distance matrix and must be square during fit"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neighbors._regression/RadiusNeighborsRegressor/__init__/metric",
          "name": "metric",
          "qname": "sklearn.neighbors._regression.RadiusNeighborsRegressor.__init__.metric",
          "default_value": "'minkowski'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'minkowski'",
            "description": "Metric to use for distance computation. Default is \"minkowski\", which\nresults in the standard Euclidean distance when p = 2. See the\ndocumentation of `scipy.spatial.distance\n<https://docs.scipy.org/doc/scipy/reference/spatial.distance.html>`_ and\nthe metrics listed in\n:class:`~sklearn.metrics.pairwise.distance_metrics` for valid metric\nvalues.\n\nIf metric is \"precomputed\", X is assumed to be a distance matrix and\nmust be square during fit. X may be a :term:`sparse graph`, in which\ncase only \"nonzero\" elements may be considered neighbors.\n\nIf metric is a callable function, it takes two arrays representing 1D\nvectors as inputs and must return one value indicating the distance\nbetween those vectors. This works for Scipy's metrics, but is less\nefficient than passing the metric name as a string."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neighbors._regression/RadiusNeighborsRegressor/__init__/metric",
          "name": "metric",
          "qname": "sklearn.neighbors._regression.RadiusNeighborsRegressor.__init__.metric",
          "default_value": "'minkowski'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'minkowski'",
            "description": "Metric to use for distance computation. Default is \"minkowski\", which\nresults in the standard Euclidean distance when p = 2. See the\ndocumentation of `scipy.spatial.distance\n<https://docs.scipy.org/doc/scipy/reference/spatial.distance.html>`_ and\nthe metrics listed in\n:class:`~sklearn.metrics.pairwise.distance_metrics` for valid metric\nvalues.\n\nIf metric is \"precomputed\", X is assumed to be a distance matrix and\nmust be square during fit. X may be a :term:`sparse graph`, in which\ncase only \"nonzero\" elements may be considered neighbors.\n\nIf metric is a callable function, it takes two arrays representing 1D\nvectors as inputs and must return one value indicating the distance\nbetween those vectors. This works for Scipy's metrics, but is less\nefficient than passing the metric name as a string."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If metric is a callable function"
        },
        "hasAction": {
          "action": ", it takes two arrays representing 1D vectors as inputs and must return one value indicating the distance between those vectors"
        }
      }
    ]
  },
  "sklearn/sklearn.neighbors._regression/RadiusNeighborsRegressor/fit": {},
  "sklearn/sklearn.neighbors._regression/RadiusNeighborsRegressor/predict": {},
  "sklearn/sklearn.neighbors._unsupervised/NearestNeighbors/__init__": {
    "metric": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neighbors._unsupervised/NearestNeighbors/__init__/metric",
          "name": "metric",
          "qname": "sklearn.neighbors._unsupervised.NearestNeighbors.__init__.metric",
          "default_value": "'minkowski'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'minkowski'",
            "description": "Metric to use for distance computation. Default is \"minkowski\", which\nresults in the standard Euclidean distance when p = 2. See the\ndocumentation of `scipy.spatial.distance\n<https://docs.scipy.org/doc/scipy/reference/spatial.distance.html>`_ and\nthe metrics listed in\n:class:`~sklearn.metrics.pairwise.distance_metrics` for valid metric\nvalues.\n\nIf metric is \"precomputed\", X is assumed to be a distance matrix and\nmust be square during fit. X may be a :term:`sparse graph`, in which\ncase only \"nonzero\" elements may be considered neighbors.\n\nIf metric is a callable function, it takes two arrays representing 1D\nvectors as inputs and must return one value indicating the distance\nbetween those vectors. This works for Scipy's metrics, but is less\nefficient than passing the metric name as a string."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neighbors._unsupervised/NearestNeighbors/__init__/p",
          "name": "p",
          "qname": "sklearn.neighbors._unsupervised.NearestNeighbors.__init__.p",
          "default_value": "2",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "2",
            "description": "Parameter for the Minkowski metric from\nsklearn.metrics.pairwise.pairwise_distances. When p = 1, this is\nequivalent to using manhattan_distance (l1), and euclidean_distance\n(l2) for p = 2. For arbitrary p, minkowski_distance (l_p) is used."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "hasCondition": {
          "condition": "when p equals 2"
        },
        "hasAction": {
          "action": "which results in the standard Euclidean distance"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neighbors._unsupervised/NearestNeighbors/__init__/metric",
          "name": "metric",
          "qname": "sklearn.neighbors._unsupervised.NearestNeighbors.__init__.metric",
          "default_value": "'minkowski'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'minkowski'",
            "description": "Metric to use for distance computation. Default is \"minkowski\", which\nresults in the standard Euclidean distance when p = 2. See the\ndocumentation of `scipy.spatial.distance\n<https://docs.scipy.org/doc/scipy/reference/spatial.distance.html>`_ and\nthe metrics listed in\n:class:`~sklearn.metrics.pairwise.distance_metrics` for valid metric\nvalues.\n\nIf metric is \"precomputed\", X is assumed to be a distance matrix and\nmust be square during fit. X may be a :term:`sparse graph`, in which\ncase only \"nonzero\" elements may be considered neighbors.\n\nIf metric is a callable function, it takes two arrays representing 1D\nvectors as inputs and must return one value indicating the distance\nbetween those vectors. This works for Scipy's metrics, but is less\nefficient than passing the metric name as a string."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neighbors._unsupervised/NearestNeighbors/__init__/metric",
          "name": "metric",
          "qname": "sklearn.neighbors._unsupervised.NearestNeighbors.__init__.metric",
          "default_value": "'minkowski'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'minkowski'",
            "description": "Metric to use for distance computation. Default is \"minkowski\", which\nresults in the standard Euclidean distance when p = 2. See the\ndocumentation of `scipy.spatial.distance\n<https://docs.scipy.org/doc/scipy/reference/spatial.distance.html>`_ and\nthe metrics listed in\n:class:`~sklearn.metrics.pairwise.distance_metrics` for valid metric\nvalues.\n\nIf metric is \"precomputed\", X is assumed to be a distance matrix and\nmust be square during fit. X may be a :term:`sparse graph`, in which\ncase only \"nonzero\" elements may be considered neighbors.\n\nIf metric is a callable function, it takes two arrays representing 1D\nvectors as inputs and must return one value indicating the distance\nbetween those vectors. This works for Scipy's metrics, but is less\nefficient than passing the metric name as a string."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If metric is precomputed"
        },
        "hasAction": {
          "action": ", X is assumed to be a distance matrix and must be square during fit"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neighbors._unsupervised/NearestNeighbors/__init__/metric",
          "name": "metric",
          "qname": "sklearn.neighbors._unsupervised.NearestNeighbors.__init__.metric",
          "default_value": "'minkowski'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'minkowski'",
            "description": "Metric to use for distance computation. Default is \"minkowski\", which\nresults in the standard Euclidean distance when p = 2. See the\ndocumentation of `scipy.spatial.distance\n<https://docs.scipy.org/doc/scipy/reference/spatial.distance.html>`_ and\nthe metrics listed in\n:class:`~sklearn.metrics.pairwise.distance_metrics` for valid metric\nvalues.\n\nIf metric is \"precomputed\", X is assumed to be a distance matrix and\nmust be square during fit. X may be a :term:`sparse graph`, in which\ncase only \"nonzero\" elements may be considered neighbors.\n\nIf metric is a callable function, it takes two arrays representing 1D\nvectors as inputs and must return one value indicating the distance\nbetween those vectors. This works for Scipy's metrics, but is less\nefficient than passing the metric name as a string."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neighbors._unsupervised/NearestNeighbors/__init__/metric",
          "name": "metric",
          "qname": "sklearn.neighbors._unsupervised.NearestNeighbors.__init__.metric",
          "default_value": "'minkowski'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str or callable",
            "default_value": "'minkowski'",
            "description": "Metric to use for distance computation. Default is \"minkowski\", which\nresults in the standard Euclidean distance when p = 2. See the\ndocumentation of `scipy.spatial.distance\n<https://docs.scipy.org/doc/scipy/reference/spatial.distance.html>`_ and\nthe metrics listed in\n:class:`~sklearn.metrics.pairwise.distance_metrics` for valid metric\nvalues.\n\nIf metric is \"precomputed\", X is assumed to be a distance matrix and\nmust be square during fit. X may be a :term:`sparse graph`, in which\ncase only \"nonzero\" elements may be considered neighbors.\n\nIf metric is a callable function, it takes two arrays representing 1D\nvectors as inputs and must return one value indicating the distance\nbetween those vectors. This works for Scipy's metrics, but is less\nefficient than passing the metric name as a string."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If metric is a callable function"
        },
        "hasAction": {
          "action": ", it takes two arrays representing 1D vectors as inputs and must return one value indicating the distance between those vectors"
        }
      }
    ]
  },
  "sklearn/sklearn.neighbors._unsupervised/NearestNeighbors/fit": {},
  "sklearn/sklearn.neural_network._base/inplace_identity": {},
  "sklearn/sklearn.neural_network._base/inplace_logistic": {},
  "sklearn/sklearn.neural_network._base/inplace_tanh": {},
  "sklearn/sklearn.neural_network._base/inplace_relu": {},
  "sklearn/sklearn.neural_network._base/inplace_softmax": {},
  "sklearn/sklearn.neural_network._base/inplace_identity_derivative": {},
  "sklearn/sklearn.neural_network._base/inplace_logistic_derivative": {},
  "sklearn/sklearn.neural_network._base/inplace_tanh_derivative": {},
  "sklearn/sklearn.neural_network._base/inplace_relu_derivative": {},
  "sklearn/sklearn.neural_network._base/squared_loss": {},
  "sklearn/sklearn.neural_network._base/log_loss": {},
  "sklearn/sklearn.neural_network._base/binary_log_loss": {},
  "sklearn/sklearn.neural_network._multilayer_perceptron/_pack": {},
  "sklearn/sklearn.neural_network._multilayer_perceptron/BaseMultilayerPerceptron/__init__": {},
  "sklearn/sklearn.neural_network._multilayer_perceptron/BaseMultilayerPerceptron/_unpack": {},
  "sklearn/sklearn.neural_network._multilayer_perceptron/BaseMultilayerPerceptron/_forward_pass": {},
  "sklearn/sklearn.neural_network._multilayer_perceptron/BaseMultilayerPerceptron/_forward_pass_fast": {},
  "sklearn/sklearn.neural_network._multilayer_perceptron/BaseMultilayerPerceptron/_compute_loss_grad": {},
  "sklearn/sklearn.neural_network._multilayer_perceptron/BaseMultilayerPerceptron/_loss_grad_lbfgs": {},
  "sklearn/sklearn.neural_network._multilayer_perceptron/BaseMultilayerPerceptron/_backprop": {},
  "sklearn/sklearn.neural_network._multilayer_perceptron/BaseMultilayerPerceptron/_initialize": {},
  "sklearn/sklearn.neural_network._multilayer_perceptron/BaseMultilayerPerceptron/_init_coef": {},
  "sklearn/sklearn.neural_network._multilayer_perceptron/BaseMultilayerPerceptron/_fit": {},
  "sklearn/sklearn.neural_network._multilayer_perceptron/BaseMultilayerPerceptron/_fit_lbfgs": {},
  "sklearn/sklearn.neural_network._multilayer_perceptron/BaseMultilayerPerceptron/_fit_stochastic": {},
  "sklearn/sklearn.neural_network._multilayer_perceptron/BaseMultilayerPerceptron/_update_no_improvement_count": {},
  "sklearn/sklearn.neural_network._multilayer_perceptron/BaseMultilayerPerceptron/fit": {},
  "sklearn/sklearn.neural_network._multilayer_perceptron/BaseMultilayerPerceptron/_check_solver": {},
  "sklearn/sklearn.neural_network._multilayer_perceptron/MLPClassifier/__init__": {
    "batch_size": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neural_network._multilayer_perceptron/MLPClassifier/__init__/batch_size",
          "name": "batch_size",
          "qname": "sklearn.neural_network._multilayer_perceptron.MLPClassifier.__init__.batch_size",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "'auto'",
            "description": "Size of minibatches for stochastic optimizers.\nIf the solver is 'lbfgs', the classifier will not use minibatch.\nWhen set to \"auto\", `batch_size=min(200, n_samples)`."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neural_network._multilayer_perceptron/MLPClassifier/__init__/solver",
          "name": "solver",
          "qname": "sklearn.neural_network._multilayer_perceptron.MLPClassifier.__init__.solver",
          "default_value": "'adam'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'lbfgs', 'sgd', 'adam'}",
            "default_value": "'adam'",
            "description": "The solver for weight optimization.\n\n- 'lbfgs' is an optimizer in the family of quasi-Newton methods.\n\n- 'sgd' refers to stochastic gradient descent.\n\n- 'adam' refers to a stochastic gradient-based optimizer proposed\n  by Kingma, Diederik, and Jimmy Ba\n\nNote: The default solver 'adam' works pretty well on relatively\nlarge datasets (with thousands of training samples or more) in terms of\nboth training time and validation score.\nFor small datasets, however, 'lbfgs' can converge faster and perform\nbetter."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "lbfgs",
              "adam",
              "sgd"
            ]
          }
        },
        "hasCondition": {
          "condition": "If the solver is lbfgs"
        },
        "hasAction": {
          "action": ", the classifier will not use minibatch"
        }
      }
    ],
    "learning_rate": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neural_network._multilayer_perceptron/MLPClassifier/__init__/learning_rate",
          "name": "learning_rate",
          "qname": "sklearn.neural_network._multilayer_perceptron.MLPClassifier.__init__.learning_rate",
          "default_value": "'constant'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'constant', 'invscaling', 'adaptive'}",
            "default_value": "'constant'",
            "description": "Learning rate schedule for weight updates.\n\n- 'constant' is a constant learning rate given by\n  'learning_rate_init'.\n\n- 'invscaling' gradually decreases the learning rate at each\n  time step 't' using an inverse scaling exponent of 'power_t'.\n  effective_learning_rate = learning_rate_init / pow(t, power_t)\n\n- 'adaptive' keeps the learning rate constant to\n  'learning_rate_init' as long as training loss keeps decreasing.\n  Each time two consecutive epochs fail to decrease training loss by at\n  least tol, or fail to increase validation score by at least tol if\n  'early_stopping' is on, the current learning rate is divided by 5.\n\nOnly used when ``solver='sgd'``."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "adaptive",
              "constant",
              "invscaling"
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neural_network._multilayer_perceptron/MLPClassifier/__init__/early_stopping",
          "name": "early_stopping",
          "qname": "sklearn.neural_network._multilayer_perceptron.MLPClassifier.__init__.early_stopping",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "Whether to use early stopping to terminate training when validation\nscore is not improving. If set to true, it will automatically set\naside 10% of training data as validation and terminate training when\nvalidation score is not improving by at least tol for\n``n_iter_no_change`` consecutive epochs. The split is stratified,\nexcept in a multilabel setting.\nIf early stopping is False, then the training stops when the training\nloss does not improve by more than tol for n_iter_no_change consecutive\npasses over the training set.\nOnly effective when solver='sgd' or 'adam'."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "if early_stopping is on"
        },
        "hasAction": {
          "action": "to increase validation score by at least tol"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neural_network._multilayer_perceptron/MLPClassifier/__init__/learning_rate",
          "name": "learning_rate",
          "qname": "sklearn.neural_network._multilayer_perceptron.MLPClassifier.__init__.learning_rate",
          "default_value": "'constant'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'constant', 'invscaling', 'adaptive'}",
            "default_value": "'constant'",
            "description": "Learning rate schedule for weight updates.\n\n- 'constant' is a constant learning rate given by\n  'learning_rate_init'.\n\n- 'invscaling' gradually decreases the learning rate at each\n  time step 't' using an inverse scaling exponent of 'power_t'.\n  effective_learning_rate = learning_rate_init / pow(t, power_t)\n\n- 'adaptive' keeps the learning rate constant to\n  'learning_rate_init' as long as training loss keeps decreasing.\n  Each time two consecutive epochs fail to decrease training loss by at\n  least tol, or fail to increase validation score by at least tol if\n  'early_stopping' is on, the current learning rate is divided by 5.\n\nOnly used when ``solver='sgd'``."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "adaptive",
              "constant",
              "invscaling"
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neural_network._multilayer_perceptron/MLPClassifier/__init__/solver",
          "name": "solver",
          "qname": "sklearn.neural_network._multilayer_perceptron.MLPClassifier.__init__.solver",
          "default_value": "'adam'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'lbfgs', 'sgd', 'adam'}",
            "default_value": "'adam'",
            "description": "The solver for weight optimization.\n\n- 'lbfgs' is an optimizer in the family of quasi-Newton methods.\n\n- 'sgd' refers to stochastic gradient descent.\n\n- 'adam' refers to a stochastic gradient-based optimizer proposed\n  by Kingma, Diederik, and Jimmy Ba\n\nNote: The default solver 'adam' works pretty well on relatively\nlarge datasets (with thousands of training samples or more) in terms of\nboth training time and validation score.\nFor small datasets, however, 'lbfgs' can converge faster and perform\nbetter."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "lbfgs",
              "adam",
              "sgd"
            ]
          }
        },
        "hasCondition": {
          "condition": "when solver equals sgd"
        },
        "hasAction": {
          "action": "Only used"
        }
      }
    ],
    "learning_rate_init": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neural_network._multilayer_perceptron/MLPClassifier/__init__/learning_rate_init",
          "name": "learning_rate_init",
          "qname": "sklearn.neural_network._multilayer_perceptron.MLPClassifier.__init__.learning_rate_init",
          "default_value": "0.001",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "0.001",
            "description": "The initial learning rate used. It controls the step-size\nin updating the weights. Only used when solver='sgd' or 'adam'."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neural_network._multilayer_perceptron/MLPClassifier/__init__/solver",
          "name": "solver",
          "qname": "sklearn.neural_network._multilayer_perceptron.MLPClassifier.__init__.solver",
          "default_value": "'adam'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'lbfgs', 'sgd', 'adam'}",
            "default_value": "'adam'",
            "description": "The solver for weight optimization.\n\n- 'lbfgs' is an optimizer in the family of quasi-Newton methods.\n\n- 'sgd' refers to stochastic gradient descent.\n\n- 'adam' refers to a stochastic gradient-based optimizer proposed\n  by Kingma, Diederik, and Jimmy Ba\n\nNote: The default solver 'adam' works pretty well on relatively\nlarge datasets (with thousands of training samples or more) in terms of\nboth training time and validation score.\nFor small datasets, however, 'lbfgs' can converge faster and perform\nbetter."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "lbfgs",
              "adam",
              "sgd"
            ]
          }
        },
        "hasCondition": {
          "condition": "when solver equals sgd or adam"
        },
        "hasAction": {
          "action": "Only used"
        }
      }
    ],
    "power_t": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neural_network._multilayer_perceptron/MLPClassifier/__init__/power_t",
          "name": "power_t",
          "qname": "sklearn.neural_network._multilayer_perceptron.MLPClassifier.__init__.power_t",
          "default_value": "0.5",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "0.5",
            "description": "The exponent for inverse scaling learning rate.\nIt is used in updating effective learning rate when the learning_rate\nis set to 'invscaling'. Only used when solver='sgd'."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neural_network._multilayer_perceptron/MLPClassifier/__init__/learning_rate",
          "name": "learning_rate",
          "qname": "sklearn.neural_network._multilayer_perceptron.MLPClassifier.__init__.learning_rate",
          "default_value": "'constant'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'constant', 'invscaling', 'adaptive'}",
            "default_value": "'constant'",
            "description": "Learning rate schedule for weight updates.\n\n- 'constant' is a constant learning rate given by\n  'learning_rate_init'.\n\n- 'invscaling' gradually decreases the learning rate at each\n  time step 't' using an inverse scaling exponent of 'power_t'.\n  effective_learning_rate = learning_rate_init / pow(t, power_t)\n\n- 'adaptive' keeps the learning rate constant to\n  'learning_rate_init' as long as training loss keeps decreasing.\n  Each time two consecutive epochs fail to decrease training loss by at\n  least tol, or fail to increase validation score by at least tol if\n  'early_stopping' is on, the current learning rate is divided by 5.\n\nOnly used when ``solver='sgd'``."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "adaptive",
              "constant",
              "invscaling"
            ]
          }
        },
        "hasCondition": {
          "condition": "when the learning_rate is set to invscaling"
        },
        "hasAction": {
          "action": "updating effective learning rate"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neural_network._multilayer_perceptron/MLPClassifier/__init__/power_t",
          "name": "power_t",
          "qname": "sklearn.neural_network._multilayer_perceptron.MLPClassifier.__init__.power_t",
          "default_value": "0.5",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "0.5",
            "description": "The exponent for inverse scaling learning rate.\nIt is used in updating effective learning rate when the learning_rate\nis set to 'invscaling'. Only used when solver='sgd'."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neural_network._multilayer_perceptron/MLPClassifier/__init__/solver",
          "name": "solver",
          "qname": "sklearn.neural_network._multilayer_perceptron.MLPClassifier.__init__.solver",
          "default_value": "'adam'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'lbfgs', 'sgd', 'adam'}",
            "default_value": "'adam'",
            "description": "The solver for weight optimization.\n\n- 'lbfgs' is an optimizer in the family of quasi-Newton methods.\n\n- 'sgd' refers to stochastic gradient descent.\n\n- 'adam' refers to a stochastic gradient-based optimizer proposed\n  by Kingma, Diederik, and Jimmy Ba\n\nNote: The default solver 'adam' works pretty well on relatively\nlarge datasets (with thousands of training samples or more) in terms of\nboth training time and validation score.\nFor small datasets, however, 'lbfgs' can converge faster and perform\nbetter."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "lbfgs",
              "adam",
              "sgd"
            ]
          }
        },
        "hasCondition": {
          "condition": "when solver equals sgd"
        },
        "hasAction": {
          "action": "Only used"
        }
      }
    ],
    "shuffle": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neural_network._multilayer_perceptron/MLPClassifier/__init__/shuffle",
          "name": "shuffle",
          "qname": "sklearn.neural_network._multilayer_perceptron.MLPClassifier.__init__.shuffle",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Whether to shuffle samples in each iteration. Only used when\nsolver='sgd' or 'adam'."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neural_network._multilayer_perceptron/MLPClassifier/__init__/solver",
          "name": "solver",
          "qname": "sklearn.neural_network._multilayer_perceptron.MLPClassifier.__init__.solver",
          "default_value": "'adam'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'lbfgs', 'sgd', 'adam'}",
            "default_value": "'adam'",
            "description": "The solver for weight optimization.\n\n- 'lbfgs' is an optimizer in the family of quasi-Newton methods.\n\n- 'sgd' refers to stochastic gradient descent.\n\n- 'adam' refers to a stochastic gradient-based optimizer proposed\n  by Kingma, Diederik, and Jimmy Ba\n\nNote: The default solver 'adam' works pretty well on relatively\nlarge datasets (with thousands of training samples or more) in terms of\nboth training time and validation score.\nFor small datasets, however, 'lbfgs' can converge faster and perform\nbetter."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "lbfgs",
              "adam",
              "sgd"
            ]
          }
        },
        "hasCondition": {
          "condition": "when solver equals sgd or adam"
        },
        "hasAction": {
          "action": "Only used"
        }
      }
    ],
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neural_network._multilayer_perceptron/MLPClassifier/__init__/random_state",
          "name": "random_state",
          "qname": "sklearn.neural_network._multilayer_perceptron.MLPClassifier.__init__.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance",
            "default_value": "None",
            "description": "Determines random number generation for weights and bias\ninitialization, train-test split if early stopping is used, and batch\nsampling when solver='sgd' or 'adam'.\nPass an int for reproducible results across multiple function calls.\nSee :term:`Glossary <random_state>`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neural_network._multilayer_perceptron/MLPClassifier/__init__/solver",
          "name": "solver",
          "qname": "sklearn.neural_network._multilayer_perceptron.MLPClassifier.__init__.solver",
          "default_value": "'adam'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'lbfgs', 'sgd', 'adam'}",
            "default_value": "'adam'",
            "description": "The solver for weight optimization.\n\n- 'lbfgs' is an optimizer in the family of quasi-Newton methods.\n\n- 'sgd' refers to stochastic gradient descent.\n\n- 'adam' refers to a stochastic gradient-based optimizer proposed\n  by Kingma, Diederik, and Jimmy Ba\n\nNote: The default solver 'adam' works pretty well on relatively\nlarge datasets (with thousands of training samples or more) in terms of\nboth training time and validation score.\nFor small datasets, however, 'lbfgs' can converge faster and perform\nbetter."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "lbfgs",
              "adam",
              "sgd"
            ]
          }
        },
        "hasCondition": {
          "condition": "when solver equals sgd or adam"
        },
        "hasAction": {
          "action": "batch sampling"
        }
      }
    ],
    "tol": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neural_network._multilayer_perceptron/MLPClassifier/__init__/tol",
          "name": "tol",
          "qname": "sklearn.neural_network._multilayer_perceptron.MLPClassifier.__init__.tol",
          "default_value": "0.0001",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "1e-4",
            "description": "Tolerance for the optimization. When the loss or score is not improving\nby at least ``tol`` for ``n_iter_no_change`` consecutive iterations,\nunless ``learning_rate`` is set to 'adaptive', convergence is\nconsidered to be reached and training stops."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neural_network._multilayer_perceptron/MLPClassifier/__init__/learning_rate",
          "name": "learning_rate",
          "qname": "sklearn.neural_network._multilayer_perceptron.MLPClassifier.__init__.learning_rate",
          "default_value": "'constant'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'constant', 'invscaling', 'adaptive'}",
            "default_value": "'constant'",
            "description": "Learning rate schedule for weight updates.\n\n- 'constant' is a constant learning rate given by\n  'learning_rate_init'.\n\n- 'invscaling' gradually decreases the learning rate at each\n  time step 't' using an inverse scaling exponent of 'power_t'.\n  effective_learning_rate = learning_rate_init / pow(t, power_t)\n\n- 'adaptive' keeps the learning rate constant to\n  'learning_rate_init' as long as training loss keeps decreasing.\n  Each time two consecutive epochs fail to decrease training loss by at\n  least tol, or fail to increase validation score by at least tol if\n  'early_stopping' is on, the current learning rate is divided by 5.\n\nOnly used when ``solver='sgd'``."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "adaptive",
              "constant",
              "invscaling"
            ]
          }
        },
        "hasCondition": {
          "condition": "unless learning_rate is set to adaptive"
        },
        "hasAction": {
          "action": "When the loss or score is not improving by at least tol for n_iter_no_change consecutive iterations"
        }
      }
    ],
    "momentum": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neural_network._multilayer_perceptron/MLPClassifier/__init__/momentum",
          "name": "momentum",
          "qname": "sklearn.neural_network._multilayer_perceptron.MLPClassifier.__init__.momentum",
          "default_value": "0.9",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "0.9",
            "description": "Momentum for gradient descent update. Should be between 0 and 1. Only\nused when solver='sgd'."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neural_network._multilayer_perceptron/MLPClassifier/__init__/solver",
          "name": "solver",
          "qname": "sklearn.neural_network._multilayer_perceptron.MLPClassifier.__init__.solver",
          "default_value": "'adam'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'lbfgs', 'sgd', 'adam'}",
            "default_value": "'adam'",
            "description": "The solver for weight optimization.\n\n- 'lbfgs' is an optimizer in the family of quasi-Newton methods.\n\n- 'sgd' refers to stochastic gradient descent.\n\n- 'adam' refers to a stochastic gradient-based optimizer proposed\n  by Kingma, Diederik, and Jimmy Ba\n\nNote: The default solver 'adam' works pretty well on relatively\nlarge datasets (with thousands of training samples or more) in terms of\nboth training time and validation score.\nFor small datasets, however, 'lbfgs' can converge faster and perform\nbetter."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "lbfgs",
              "adam",
              "sgd"
            ]
          }
        },
        "hasCondition": {
          "condition": "when solver equals sgd"
        },
        "hasAction": {
          "action": "Only used"
        }
      }
    ],
    "nesterovs_momentum": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neural_network._multilayer_perceptron/MLPClassifier/__init__/nesterovs_momentum",
          "name": "nesterovs_momentum",
          "qname": "sklearn.neural_network._multilayer_perceptron.MLPClassifier.__init__.nesterovs_momentum",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Whether to use Nesterov's momentum. Only used when solver='sgd' and\nmomentum > 0."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neural_network._multilayer_perceptron/MLPClassifier/__init__/solver",
          "name": "solver",
          "qname": "sklearn.neural_network._multilayer_perceptron.MLPClassifier.__init__.solver",
          "default_value": "'adam'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'lbfgs', 'sgd', 'adam'}",
            "default_value": "'adam'",
            "description": "The solver for weight optimization.\n\n- 'lbfgs' is an optimizer in the family of quasi-Newton methods.\n\n- 'sgd' refers to stochastic gradient descent.\n\n- 'adam' refers to a stochastic gradient-based optimizer proposed\n  by Kingma, Diederik, and Jimmy Ba\n\nNote: The default solver 'adam' works pretty well on relatively\nlarge datasets (with thousands of training samples or more) in terms of\nboth training time and validation score.\nFor small datasets, however, 'lbfgs' can converge faster and perform\nbetter."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "lbfgs",
              "adam",
              "sgd"
            ]
          }
        },
        "hasCondition": {
          "condition": "when solver equals sgd and momentum"
        },
        "hasAction": {
          "action": "Only used > 0"
        }
      }
    ],
    "validation_fraction": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neural_network._multilayer_perceptron/MLPClassifier/__init__/validation_fraction",
          "name": "validation_fraction",
          "qname": "sklearn.neural_network._multilayer_perceptron.MLPClassifier.__init__.validation_fraction",
          "default_value": "0.1",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "0.1",
            "description": "The proportion of training data to set aside as validation set for\nearly stopping. Must be between 0 and 1.\nOnly used if early_stopping is True."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neural_network._multilayer_perceptron/MLPClassifier/__init__/early_stopping",
          "name": "early_stopping",
          "qname": "sklearn.neural_network._multilayer_perceptron.MLPClassifier.__init__.early_stopping",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "Whether to use early stopping to terminate training when validation\nscore is not improving. If set to true, it will automatically set\naside 10% of training data as validation and terminate training when\nvalidation score is not improving by at least tol for\n``n_iter_no_change`` consecutive epochs. The split is stratified,\nexcept in a multilabel setting.\nIf early stopping is False, then the training stops when the training\nloss does not improve by more than tol for n_iter_no_change consecutive\npasses over the training set.\nOnly effective when solver='sgd' or 'adam'."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "if early_stopping is True"
        },
        "hasAction": {
          "action": "Only used"
        }
      }
    ]
  },
  "sklearn/sklearn.neural_network._multilayer_perceptron/MLPClassifier/_validate_input": {},
  "sklearn/sklearn.neural_network._multilayer_perceptron/MLPClassifier/predict": {},
  "sklearn/sklearn.neural_network._multilayer_perceptron/MLPClassifier/_predict": {},
  "sklearn/sklearn.neural_network._multilayer_perceptron/MLPClassifier/_score": {},
  "sklearn/sklearn.neural_network._multilayer_perceptron/MLPClassifier/partial_fit": {},
  "sklearn/sklearn.neural_network._multilayer_perceptron/MLPClassifier/predict_log_proba": {},
  "sklearn/sklearn.neural_network._multilayer_perceptron/MLPClassifier/predict_proba": {},
  "sklearn/sklearn.neural_network._multilayer_perceptron/MLPClassifier/_more_tags": {},
  "sklearn/sklearn.neural_network._multilayer_perceptron/MLPRegressor/__init__": {
    "batch_size": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neural_network._multilayer_perceptron/MLPRegressor/__init__/batch_size",
          "name": "batch_size",
          "qname": "sklearn.neural_network._multilayer_perceptron.MLPRegressor.__init__.batch_size",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "'auto'",
            "description": "Size of minibatches for stochastic optimizers.\nIf the solver is 'lbfgs', the classifier will not use minibatch.\nWhen set to \"auto\", `batch_size=min(200, n_samples)`."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neural_network._multilayer_perceptron/MLPRegressor/__init__/solver",
          "name": "solver",
          "qname": "sklearn.neural_network._multilayer_perceptron.MLPRegressor.__init__.solver",
          "default_value": "'adam'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'lbfgs', 'sgd', 'adam'}",
            "default_value": "'adam'",
            "description": "The solver for weight optimization.\n\n- 'lbfgs' is an optimizer in the family of quasi-Newton methods.\n\n- 'sgd' refers to stochastic gradient descent.\n\n- 'adam' refers to a stochastic gradient-based optimizer proposed by\n  Kingma, Diederik, and Jimmy Ba\n\nNote: The default solver 'adam' works pretty well on relatively\nlarge datasets (with thousands of training samples or more) in terms of\nboth training time and validation score.\nFor small datasets, however, 'lbfgs' can converge faster and perform\nbetter."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "lbfgs",
              "adam",
              "sgd"
            ]
          }
        },
        "hasCondition": {
          "condition": "If the solver is lbfgs"
        },
        "hasAction": {
          "action": ", the classifier will not use minibatch"
        }
      }
    ],
    "learning_rate": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neural_network._multilayer_perceptron/MLPRegressor/__init__/learning_rate",
          "name": "learning_rate",
          "qname": "sklearn.neural_network._multilayer_perceptron.MLPRegressor.__init__.learning_rate",
          "default_value": "'constant'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'constant', 'invscaling', 'adaptive'}",
            "default_value": "'constant'",
            "description": "Learning rate schedule for weight updates.\n\n- 'constant' is a constant learning rate given by\n  'learning_rate_init'.\n\n- 'invscaling' gradually decreases the learning rate ``learning_rate_``\n  at each time step 't' using an inverse scaling exponent of 'power_t'.\n  effective_learning_rate = learning_rate_init / pow(t, power_t)\n\n- 'adaptive' keeps the learning rate constant to\n  'learning_rate_init' as long as training loss keeps decreasing.\n  Each time two consecutive epochs fail to decrease training loss by at\n  least tol, or fail to increase validation score by at least tol if\n  'early_stopping' is on, the current learning rate is divided by 5.\n\nOnly used when solver='sgd'."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "adaptive",
              "constant",
              "invscaling"
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neural_network._multilayer_perceptron/MLPRegressor/__init__/early_stopping",
          "name": "early_stopping",
          "qname": "sklearn.neural_network._multilayer_perceptron.MLPRegressor.__init__.early_stopping",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "Whether to use early stopping to terminate training when validation\nscore is not improving. If set to true, it will automatically set\naside 10% of training data as validation and terminate training when\nvalidation score is not improving by at least ``tol`` for\n``n_iter_no_change`` consecutive epochs.\nOnly effective when solver='sgd' or 'adam'."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "if early_stopping is on"
        },
        "hasAction": {
          "action": "to increase validation score by at least tol"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neural_network._multilayer_perceptron/MLPRegressor/__init__/learning_rate",
          "name": "learning_rate",
          "qname": "sklearn.neural_network._multilayer_perceptron.MLPRegressor.__init__.learning_rate",
          "default_value": "'constant'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'constant', 'invscaling', 'adaptive'}",
            "default_value": "'constant'",
            "description": "Learning rate schedule for weight updates.\n\n- 'constant' is a constant learning rate given by\n  'learning_rate_init'.\n\n- 'invscaling' gradually decreases the learning rate ``learning_rate_``\n  at each time step 't' using an inverse scaling exponent of 'power_t'.\n  effective_learning_rate = learning_rate_init / pow(t, power_t)\n\n- 'adaptive' keeps the learning rate constant to\n  'learning_rate_init' as long as training loss keeps decreasing.\n  Each time two consecutive epochs fail to decrease training loss by at\n  least tol, or fail to increase validation score by at least tol if\n  'early_stopping' is on, the current learning rate is divided by 5.\n\nOnly used when solver='sgd'."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "adaptive",
              "constant",
              "invscaling"
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neural_network._multilayer_perceptron/MLPRegressor/__init__/solver",
          "name": "solver",
          "qname": "sklearn.neural_network._multilayer_perceptron.MLPRegressor.__init__.solver",
          "default_value": "'adam'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'lbfgs', 'sgd', 'adam'}",
            "default_value": "'adam'",
            "description": "The solver for weight optimization.\n\n- 'lbfgs' is an optimizer in the family of quasi-Newton methods.\n\n- 'sgd' refers to stochastic gradient descent.\n\n- 'adam' refers to a stochastic gradient-based optimizer proposed by\n  Kingma, Diederik, and Jimmy Ba\n\nNote: The default solver 'adam' works pretty well on relatively\nlarge datasets (with thousands of training samples or more) in terms of\nboth training time and validation score.\nFor small datasets, however, 'lbfgs' can converge faster and perform\nbetter."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "lbfgs",
              "adam",
              "sgd"
            ]
          }
        },
        "hasCondition": {
          "condition": "when solver equals sgd"
        },
        "hasAction": {
          "action": "Only used"
        }
      }
    ],
    "learning_rate_init": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neural_network._multilayer_perceptron/MLPRegressor/__init__/learning_rate_init",
          "name": "learning_rate_init",
          "qname": "sklearn.neural_network._multilayer_perceptron.MLPRegressor.__init__.learning_rate_init",
          "default_value": "0.001",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "0.001",
            "description": "The initial learning rate used. It controls the step-size\nin updating the weights. Only used when solver='sgd' or 'adam'."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neural_network._multilayer_perceptron/MLPRegressor/__init__/solver",
          "name": "solver",
          "qname": "sklearn.neural_network._multilayer_perceptron.MLPRegressor.__init__.solver",
          "default_value": "'adam'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'lbfgs', 'sgd', 'adam'}",
            "default_value": "'adam'",
            "description": "The solver for weight optimization.\n\n- 'lbfgs' is an optimizer in the family of quasi-Newton methods.\n\n- 'sgd' refers to stochastic gradient descent.\n\n- 'adam' refers to a stochastic gradient-based optimizer proposed by\n  Kingma, Diederik, and Jimmy Ba\n\nNote: The default solver 'adam' works pretty well on relatively\nlarge datasets (with thousands of training samples or more) in terms of\nboth training time and validation score.\nFor small datasets, however, 'lbfgs' can converge faster and perform\nbetter."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "lbfgs",
              "adam",
              "sgd"
            ]
          }
        },
        "hasCondition": {
          "condition": "when solver equals sgd or adam"
        },
        "hasAction": {
          "action": "Only used"
        }
      }
    ],
    "power_t": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neural_network._multilayer_perceptron/MLPRegressor/__init__/power_t",
          "name": "power_t",
          "qname": "sklearn.neural_network._multilayer_perceptron.MLPRegressor.__init__.power_t",
          "default_value": "0.5",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "0.5",
            "description": "The exponent for inverse scaling learning rate.\nIt is used in updating effective learning rate when the learning_rate\nis set to 'invscaling'. Only used when solver='sgd'."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neural_network._multilayer_perceptron/MLPRegressor/__init__/learning_rate",
          "name": "learning_rate",
          "qname": "sklearn.neural_network._multilayer_perceptron.MLPRegressor.__init__.learning_rate",
          "default_value": "'constant'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'constant', 'invscaling', 'adaptive'}",
            "default_value": "'constant'",
            "description": "Learning rate schedule for weight updates.\n\n- 'constant' is a constant learning rate given by\n  'learning_rate_init'.\n\n- 'invscaling' gradually decreases the learning rate ``learning_rate_``\n  at each time step 't' using an inverse scaling exponent of 'power_t'.\n  effective_learning_rate = learning_rate_init / pow(t, power_t)\n\n- 'adaptive' keeps the learning rate constant to\n  'learning_rate_init' as long as training loss keeps decreasing.\n  Each time two consecutive epochs fail to decrease training loss by at\n  least tol, or fail to increase validation score by at least tol if\n  'early_stopping' is on, the current learning rate is divided by 5.\n\nOnly used when solver='sgd'."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "adaptive",
              "constant",
              "invscaling"
            ]
          }
        },
        "hasCondition": {
          "condition": "when the learning_rate is set to invscaling"
        },
        "hasAction": {
          "action": "updating effective learning rate"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neural_network._multilayer_perceptron/MLPRegressor/__init__/power_t",
          "name": "power_t",
          "qname": "sklearn.neural_network._multilayer_perceptron.MLPRegressor.__init__.power_t",
          "default_value": "0.5",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "0.5",
            "description": "The exponent for inverse scaling learning rate.\nIt is used in updating effective learning rate when the learning_rate\nis set to 'invscaling'. Only used when solver='sgd'."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neural_network._multilayer_perceptron/MLPRegressor/__init__/solver",
          "name": "solver",
          "qname": "sklearn.neural_network._multilayer_perceptron.MLPRegressor.__init__.solver",
          "default_value": "'adam'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'lbfgs', 'sgd', 'adam'}",
            "default_value": "'adam'",
            "description": "The solver for weight optimization.\n\n- 'lbfgs' is an optimizer in the family of quasi-Newton methods.\n\n- 'sgd' refers to stochastic gradient descent.\n\n- 'adam' refers to a stochastic gradient-based optimizer proposed by\n  Kingma, Diederik, and Jimmy Ba\n\nNote: The default solver 'adam' works pretty well on relatively\nlarge datasets (with thousands of training samples or more) in terms of\nboth training time and validation score.\nFor small datasets, however, 'lbfgs' can converge faster and perform\nbetter."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "lbfgs",
              "adam",
              "sgd"
            ]
          }
        },
        "hasCondition": {
          "condition": "when solver equals sgd"
        },
        "hasAction": {
          "action": "Only used"
        }
      }
    ],
    "shuffle": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neural_network._multilayer_perceptron/MLPRegressor/__init__/shuffle",
          "name": "shuffle",
          "qname": "sklearn.neural_network._multilayer_perceptron.MLPRegressor.__init__.shuffle",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Whether to shuffle samples in each iteration. Only used when\nsolver='sgd' or 'adam'."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neural_network._multilayer_perceptron/MLPRegressor/__init__/solver",
          "name": "solver",
          "qname": "sklearn.neural_network._multilayer_perceptron.MLPRegressor.__init__.solver",
          "default_value": "'adam'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'lbfgs', 'sgd', 'adam'}",
            "default_value": "'adam'",
            "description": "The solver for weight optimization.\n\n- 'lbfgs' is an optimizer in the family of quasi-Newton methods.\n\n- 'sgd' refers to stochastic gradient descent.\n\n- 'adam' refers to a stochastic gradient-based optimizer proposed by\n  Kingma, Diederik, and Jimmy Ba\n\nNote: The default solver 'adam' works pretty well on relatively\nlarge datasets (with thousands of training samples or more) in terms of\nboth training time and validation score.\nFor small datasets, however, 'lbfgs' can converge faster and perform\nbetter."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "lbfgs",
              "adam",
              "sgd"
            ]
          }
        },
        "hasCondition": {
          "condition": "when solver equals sgd or adam"
        },
        "hasAction": {
          "action": "Only used"
        }
      }
    ],
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neural_network._multilayer_perceptron/MLPRegressor/__init__/random_state",
          "name": "random_state",
          "qname": "sklearn.neural_network._multilayer_perceptron.MLPRegressor.__init__.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance",
            "default_value": "None",
            "description": "Determines random number generation for weights and bias\ninitialization, train-test split if early stopping is used, and batch\nsampling when solver='sgd' or 'adam'.\nPass an int for reproducible results across multiple function calls.\nSee :term:`Glossary <random_state>`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neural_network._multilayer_perceptron/MLPRegressor/__init__/solver",
          "name": "solver",
          "qname": "sklearn.neural_network._multilayer_perceptron.MLPRegressor.__init__.solver",
          "default_value": "'adam'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'lbfgs', 'sgd', 'adam'}",
            "default_value": "'adam'",
            "description": "The solver for weight optimization.\n\n- 'lbfgs' is an optimizer in the family of quasi-Newton methods.\n\n- 'sgd' refers to stochastic gradient descent.\n\n- 'adam' refers to a stochastic gradient-based optimizer proposed by\n  Kingma, Diederik, and Jimmy Ba\n\nNote: The default solver 'adam' works pretty well on relatively\nlarge datasets (with thousands of training samples or more) in terms of\nboth training time and validation score.\nFor small datasets, however, 'lbfgs' can converge faster and perform\nbetter."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "lbfgs",
              "adam",
              "sgd"
            ]
          }
        },
        "hasCondition": {
          "condition": "when solver equals sgd or adam"
        },
        "hasAction": {
          "action": "batch sampling"
        }
      }
    ],
    "tol": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neural_network._multilayer_perceptron/MLPRegressor/__init__/tol",
          "name": "tol",
          "qname": "sklearn.neural_network._multilayer_perceptron.MLPRegressor.__init__.tol",
          "default_value": "0.0001",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "1e-4",
            "description": "Tolerance for the optimization. When the loss or score is not improving\nby at least ``tol`` for ``n_iter_no_change`` consecutive iterations,\nunless ``learning_rate`` is set to 'adaptive', convergence is\nconsidered to be reached and training stops."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neural_network._multilayer_perceptron/MLPRegressor/__init__/learning_rate",
          "name": "learning_rate",
          "qname": "sklearn.neural_network._multilayer_perceptron.MLPRegressor.__init__.learning_rate",
          "default_value": "'constant'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'constant', 'invscaling', 'adaptive'}",
            "default_value": "'constant'",
            "description": "Learning rate schedule for weight updates.\n\n- 'constant' is a constant learning rate given by\n  'learning_rate_init'.\n\n- 'invscaling' gradually decreases the learning rate ``learning_rate_``\n  at each time step 't' using an inverse scaling exponent of 'power_t'.\n  effective_learning_rate = learning_rate_init / pow(t, power_t)\n\n- 'adaptive' keeps the learning rate constant to\n  'learning_rate_init' as long as training loss keeps decreasing.\n  Each time two consecutive epochs fail to decrease training loss by at\n  least tol, or fail to increase validation score by at least tol if\n  'early_stopping' is on, the current learning rate is divided by 5.\n\nOnly used when solver='sgd'."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "adaptive",
              "constant",
              "invscaling"
            ]
          }
        },
        "hasCondition": {
          "condition": "unless learning_rate is set to adaptive"
        },
        "hasAction": {
          "action": "When the loss or score is not improving by at least tol for n_iter_no_change consecutive iterations"
        }
      }
    ],
    "momentum": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neural_network._multilayer_perceptron/MLPRegressor/__init__/momentum",
          "name": "momentum",
          "qname": "sklearn.neural_network._multilayer_perceptron.MLPRegressor.__init__.momentum",
          "default_value": "0.9",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "0.9",
            "description": "Momentum for gradient descent update.  Should be between 0 and 1. Only\nused when solver='sgd'."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neural_network._multilayer_perceptron/MLPRegressor/__init__/solver",
          "name": "solver",
          "qname": "sklearn.neural_network._multilayer_perceptron.MLPRegressor.__init__.solver",
          "default_value": "'adam'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'lbfgs', 'sgd', 'adam'}",
            "default_value": "'adam'",
            "description": "The solver for weight optimization.\n\n- 'lbfgs' is an optimizer in the family of quasi-Newton methods.\n\n- 'sgd' refers to stochastic gradient descent.\n\n- 'adam' refers to a stochastic gradient-based optimizer proposed by\n  Kingma, Diederik, and Jimmy Ba\n\nNote: The default solver 'adam' works pretty well on relatively\nlarge datasets (with thousands of training samples or more) in terms of\nboth training time and validation score.\nFor small datasets, however, 'lbfgs' can converge faster and perform\nbetter."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "lbfgs",
              "adam",
              "sgd"
            ]
          }
        },
        "hasCondition": {
          "condition": "when solver equals sgd"
        },
        "hasAction": {
          "action": "Only used"
        }
      }
    ],
    "nesterovs_momentum": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neural_network._multilayer_perceptron/MLPRegressor/__init__/nesterovs_momentum",
          "name": "nesterovs_momentum",
          "qname": "sklearn.neural_network._multilayer_perceptron.MLPRegressor.__init__.nesterovs_momentum",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Whether to use Nesterov's momentum. Only used when solver='sgd' and\nmomentum > 0."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neural_network._multilayer_perceptron/MLPRegressor/__init__/solver",
          "name": "solver",
          "qname": "sklearn.neural_network._multilayer_perceptron.MLPRegressor.__init__.solver",
          "default_value": "'adam'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'lbfgs', 'sgd', 'adam'}",
            "default_value": "'adam'",
            "description": "The solver for weight optimization.\n\n- 'lbfgs' is an optimizer in the family of quasi-Newton methods.\n\n- 'sgd' refers to stochastic gradient descent.\n\n- 'adam' refers to a stochastic gradient-based optimizer proposed by\n  Kingma, Diederik, and Jimmy Ba\n\nNote: The default solver 'adam' works pretty well on relatively\nlarge datasets (with thousands of training samples or more) in terms of\nboth training time and validation score.\nFor small datasets, however, 'lbfgs' can converge faster and perform\nbetter."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "lbfgs",
              "adam",
              "sgd"
            ]
          }
        },
        "hasCondition": {
          "condition": "when solver equals sgd and momentum"
        },
        "hasAction": {
          "action": "Only used > 0"
        }
      }
    ],
    "validation_fraction": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.neural_network._multilayer_perceptron/MLPRegressor/__init__/validation_fraction",
          "name": "validation_fraction",
          "qname": "sklearn.neural_network._multilayer_perceptron.MLPRegressor.__init__.validation_fraction",
          "default_value": "0.1",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "0.1",
            "description": "The proportion of training data to set aside as validation set for\nearly stopping. Must be between 0 and 1.\nOnly used if early_stopping is True."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.neural_network._multilayer_perceptron/MLPRegressor/__init__/early_stopping",
          "name": "early_stopping",
          "qname": "sklearn.neural_network._multilayer_perceptron.MLPRegressor.__init__.early_stopping",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "Whether to use early stopping to terminate training when validation\nscore is not improving. If set to true, it will automatically set\naside 10% of training data as validation and terminate training when\nvalidation score is not improving by at least ``tol`` for\n``n_iter_no_change`` consecutive epochs.\nOnly effective when solver='sgd' or 'adam'."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "if early_stopping is True"
        },
        "hasAction": {
          "action": "Only used"
        }
      }
    ]
  },
  "sklearn/sklearn.neural_network._multilayer_perceptron/MLPRegressor/predict": {},
  "sklearn/sklearn.neural_network._multilayer_perceptron/MLPRegressor/_predict": {},
  "sklearn/sklearn.neural_network._multilayer_perceptron/MLPRegressor/_score": {},
  "sklearn/sklearn.neural_network._multilayer_perceptron/MLPRegressor/_validate_input": {},
  "sklearn/sklearn.neural_network._multilayer_perceptron/MLPRegressor/partial_fit": {},
  "sklearn/sklearn.neural_network._rbm/BernoulliRBM/__init__": {},
  "sklearn/sklearn.neural_network._rbm/BernoulliRBM/transform": {},
  "sklearn/sklearn.neural_network._rbm/BernoulliRBM/_mean_hiddens": {},
  "sklearn/sklearn.neural_network._rbm/BernoulliRBM/_sample_hiddens": {},
  "sklearn/sklearn.neural_network._rbm/BernoulliRBM/_sample_visibles": {},
  "sklearn/sklearn.neural_network._rbm/BernoulliRBM/_free_energy": {},
  "sklearn/sklearn.neural_network._rbm/BernoulliRBM/gibbs": {},
  "sklearn/sklearn.neural_network._rbm/BernoulliRBM/partial_fit": {},
  "sklearn/sklearn.neural_network._rbm/BernoulliRBM/_fit": {},
  "sklearn/sklearn.neural_network._rbm/BernoulliRBM/score_samples": {},
  "sklearn/sklearn.neural_network._rbm/BernoulliRBM/fit": {},
  "sklearn/sklearn.neural_network._rbm/BernoulliRBM/_more_tags": {},
  "sklearn/sklearn.neural_network._stochastic_optimizers/BaseOptimizer/__init__": {},
  "sklearn/sklearn.neural_network._stochastic_optimizers/BaseOptimizer/update_params": {},
  "sklearn/sklearn.neural_network._stochastic_optimizers/BaseOptimizer/iteration_ends": {},
  "sklearn/sklearn.neural_network._stochastic_optimizers/BaseOptimizer/trigger_stopping": {},
  "sklearn/sklearn.neural_network._stochastic_optimizers/SGDOptimizer/__init__": {},
  "sklearn/sklearn.neural_network._stochastic_optimizers/SGDOptimizer/iteration_ends": {},
  "sklearn/sklearn.neural_network._stochastic_optimizers/SGDOptimizer/trigger_stopping": {},
  "sklearn/sklearn.neural_network._stochastic_optimizers/SGDOptimizer/_get_updates": {},
  "sklearn/sklearn.neural_network._stochastic_optimizers/AdamOptimizer/__init__": {},
  "sklearn/sklearn.neural_network._stochastic_optimizers/AdamOptimizer/_get_updates": {},
  "sklearn/sklearn.preprocessing._data/_is_constant_feature": {},
  "sklearn/sklearn.preprocessing._data/_handle_zeros_in_scale": {},
  "sklearn/sklearn.preprocessing._data/scale": {},
  "sklearn/sklearn.preprocessing._data/MinMaxScaler/__init__": {},
  "sklearn/sklearn.preprocessing._data/MinMaxScaler/_reset": {},
  "sklearn/sklearn.preprocessing._data/MinMaxScaler/fit": {},
  "sklearn/sklearn.preprocessing._data/MinMaxScaler/partial_fit": {},
  "sklearn/sklearn.preprocessing._data/MinMaxScaler/transform": {},
  "sklearn/sklearn.preprocessing._data/MinMaxScaler/inverse_transform": {},
  "sklearn/sklearn.preprocessing._data/MinMaxScaler/_more_tags": {},
  "sklearn/sklearn.preprocessing._data/minmax_scale": {},
  "sklearn/sklearn.preprocessing._data/StandardScaler/__init__": {},
  "sklearn/sklearn.preprocessing._data/StandardScaler/_reset": {},
  "sklearn/sklearn.preprocessing._data/StandardScaler/fit": {},
  "sklearn/sklearn.preprocessing._data/StandardScaler/partial_fit": {},
  "sklearn/sklearn.preprocessing._data/StandardScaler/transform": {},
  "sklearn/sklearn.preprocessing._data/StandardScaler/inverse_transform": {},
  "sklearn/sklearn.preprocessing._data/StandardScaler/_more_tags": {},
  "sklearn/sklearn.preprocessing._data/MaxAbsScaler/__init__": {},
  "sklearn/sklearn.preprocessing._data/MaxAbsScaler/_reset": {},
  "sklearn/sklearn.preprocessing._data/MaxAbsScaler/fit": {},
  "sklearn/sklearn.preprocessing._data/MaxAbsScaler/partial_fit": {},
  "sklearn/sklearn.preprocessing._data/MaxAbsScaler/transform": {},
  "sklearn/sklearn.preprocessing._data/MaxAbsScaler/inverse_transform": {},
  "sklearn/sklearn.preprocessing._data/MaxAbsScaler/_more_tags": {},
  "sklearn/sklearn.preprocessing._data/maxabs_scale": {},
  "sklearn/sklearn.preprocessing._data/RobustScaler/__init__": {},
  "sklearn/sklearn.preprocessing._data/RobustScaler/fit": {},
  "sklearn/sklearn.preprocessing._data/RobustScaler/transform": {},
  "sklearn/sklearn.preprocessing._data/RobustScaler/inverse_transform": {},
  "sklearn/sklearn.preprocessing._data/RobustScaler/_more_tags": {},
  "sklearn/sklearn.preprocessing._data/robust_scale": {},
  "sklearn/sklearn.preprocessing._data/normalize": {
    "norm": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.preprocessing._data/normalize/norm",
          "name": "norm",
          "qname": "sklearn.preprocessing._data.normalize.norm",
          "default_value": "'l2'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "{'l1', 'l2', 'max'}",
            "default_value": "'l2'",
            "description": "The norm to use to normalize each non zero sample (or each non-zero\nfeature if axis is 0)."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "l1",
              "l2",
              "max"
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.preprocessing._data/normalize/axis",
          "name": "axis",
          "qname": "sklearn.preprocessing._data.normalize.axis",
          "default_value": "1",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{0, 1}",
            "default_value": "1",
            "description": "Define axis used to normalize the data along. If 1, independently\nnormalize each sample, otherwise (if 0) normalize each feature."
          },
          "type": {
            "kind": "EnumType",
            "values": []
          }
        },
        "hasCondition": {
          "condition": "if axis is 0"
        },
        "hasAction": {
          "action": "to use to normalize each non zero sample ( or each non - zero feature"
        }
      }
    ]
  },
  "sklearn/sklearn.preprocessing._data/Normalizer/__init__": {
    "norm": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.preprocessing._data/Normalizer/__init__/norm",
          "name": "norm",
          "qname": "sklearn.preprocessing._data.Normalizer.__init__.norm",
          "default_value": "'l2'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "{'l1', 'l2', 'max'}",
            "default_value": "'l2'",
            "description": "The norm to use to normalize each non zero sample. If norm='max'\nis used, values will be rescaled by the maximum of the absolute\nvalues."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "l1",
              "l2",
              "max"
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.preprocessing._data/Normalizer/__init__/norm",
          "name": "norm",
          "qname": "sklearn.preprocessing._data.Normalizer.__init__.norm",
          "default_value": "'l2'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "{'l1', 'l2', 'max'}",
            "default_value": "'l2'",
            "description": "The norm to use to normalize each non zero sample. If norm='max'\nis used, values will be rescaled by the maximum of the absolute\nvalues."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "l1",
              "l2",
              "max"
            ]
          }
        },
        "hasCondition": {
          "condition": "If norm equals max is used"
        },
        "hasAction": {
          "action": ", values will be rescaled by the maximum of the absolute values"
        }
      }
    ]
  },
  "sklearn/sklearn.preprocessing._data/Normalizer/fit": {},
  "sklearn/sklearn.preprocessing._data/Normalizer/transform": {},
  "sklearn/sklearn.preprocessing._data/Normalizer/_more_tags": {},
  "sklearn/sklearn.preprocessing._data/binarize": {},
  "sklearn/sklearn.preprocessing._data/Binarizer/__init__": {},
  "sklearn/sklearn.preprocessing._data/Binarizer/fit": {},
  "sklearn/sklearn.preprocessing._data/Binarizer/transform": {},
  "sklearn/sklearn.preprocessing._data/Binarizer/_more_tags": {},
  "sklearn/sklearn.preprocessing._data/KernelCenterer/__init__": {},
  "sklearn/sklearn.preprocessing._data/KernelCenterer/fit": {},
  "sklearn/sklearn.preprocessing._data/KernelCenterer/transform": {},
  "sklearn/sklearn.preprocessing._data/KernelCenterer/_n_features_out@getter": {},
  "sklearn/sklearn.preprocessing._data/KernelCenterer/_more_tags": {},
  "sklearn/sklearn.preprocessing._data/add_dummy_feature": {},
  "sklearn/sklearn.preprocessing._data/QuantileTransformer/__init__": {
    "n_quantiles": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.preprocessing._data/QuantileTransformer/__init__/n_quantiles",
          "name": "n_quantiles",
          "qname": "sklearn.preprocessing._data.QuantileTransformer.__init__.n_quantiles",
          "default_value": "1000",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "1000 or n_samples",
            "description": "Number of quantiles to be computed. It corresponds to the number\nof landmarks used to discretize the cumulative distribution function.\nIf n_quantiles is larger than the number of samples, n_quantiles is set\nto the number of samples as a larger number of quantiles does not give\na better approximation of the cumulative distribution function\nestimator."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.preprocessing._data/QuantileTransformer/__init__/n_quantiles",
          "name": "n_quantiles",
          "qname": "sklearn.preprocessing._data.QuantileTransformer.__init__.n_quantiles",
          "default_value": "1000",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "1000 or n_samples",
            "description": "Number of quantiles to be computed. It corresponds to the number\nof landmarks used to discretize the cumulative distribution function.\nIf n_quantiles is larger than the number of samples, n_quantiles is set\nto the number of samples as a larger number of quantiles does not give\na better approximation of the cumulative distribution function\nestimator."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "hasCondition": {
          "condition": "If n_quantiles is larger than the number of samples"
        },
        "hasAction": {
          "action": ", n_quantiles is set to the number of samples as a larger number of quantiles does not give a better approximation of the cumulative distribution function estimator"
        }
      }
    ]
  },
  "sklearn/sklearn.preprocessing._data/QuantileTransformer/_dense_fit": {},
  "sklearn/sklearn.preprocessing._data/QuantileTransformer/_sparse_fit": {},
  "sklearn/sklearn.preprocessing._data/QuantileTransformer/fit": {},
  "sklearn/sklearn.preprocessing._data/QuantileTransformer/_transform_col": {},
  "sklearn/sklearn.preprocessing._data/QuantileTransformer/_check_inputs": {},
  "sklearn/sklearn.preprocessing._data/QuantileTransformer/_transform": {},
  "sklearn/sklearn.preprocessing._data/QuantileTransformer/transform": {},
  "sklearn/sklearn.preprocessing._data/QuantileTransformer/inverse_transform": {},
  "sklearn/sklearn.preprocessing._data/QuantileTransformer/_more_tags": {},
  "sklearn/sklearn.preprocessing._data/quantile_transform": {
    "n_quantiles": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.preprocessing._data/quantile_transform/n_quantiles",
          "name": "n_quantiles",
          "qname": "sklearn.preprocessing._data.quantile_transform.n_quantiles",
          "default_value": "1000",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "1000 or n_samples",
            "description": "Number of quantiles to be computed. It corresponds to the number\nof landmarks used to discretize the cumulative distribution function.\nIf n_quantiles is larger than the number of samples, n_quantiles is set\nto the number of samples as a larger number of quantiles does not give\na better approximation of the cumulative distribution function\nestimator."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.preprocessing._data/quantile_transform/n_quantiles",
          "name": "n_quantiles",
          "qname": "sklearn.preprocessing._data.quantile_transform.n_quantiles",
          "default_value": "1000",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "1000 or n_samples",
            "description": "Number of quantiles to be computed. It corresponds to the number\nof landmarks used to discretize the cumulative distribution function.\nIf n_quantiles is larger than the number of samples, n_quantiles is set\nto the number of samples as a larger number of quantiles does not give\na better approximation of the cumulative distribution function\nestimator."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "hasCondition": {
          "condition": "If n_quantiles is larger than the number of samples"
        },
        "hasAction": {
          "action": ", n_quantiles is set to the number of samples as a larger number of quantiles does not give a better approximation of the cumulative distribution function estimator"
        }
      }
    ]
  },
  "sklearn/sklearn.preprocessing._data/PowerTransformer/__init__": {},
  "sklearn/sklearn.preprocessing._data/PowerTransformer/fit": {},
  "sklearn/sklearn.preprocessing._data/PowerTransformer/fit_transform": {},
  "sklearn/sklearn.preprocessing._data/PowerTransformer/_fit": {},
  "sklearn/sklearn.preprocessing._data/PowerTransformer/transform": {},
  "sklearn/sklearn.preprocessing._data/PowerTransformer/inverse_transform": {},
  "sklearn/sklearn.preprocessing._data/PowerTransformer/_box_cox_inverse_tranform": {},
  "sklearn/sklearn.preprocessing._data/PowerTransformer/_yeo_johnson_inverse_transform": {},
  "sklearn/sklearn.preprocessing._data/PowerTransformer/_yeo_johnson_transform": {},
  "sklearn/sklearn.preprocessing._data/PowerTransformer/_box_cox_optimize": {},
  "sklearn/sklearn.preprocessing._data/PowerTransformer/_yeo_johnson_optimize": {},
  "sklearn/sklearn.preprocessing._data/PowerTransformer/_check_input": {},
  "sklearn/sklearn.preprocessing._data/PowerTransformer/_more_tags": {},
  "sklearn/sklearn.preprocessing._data/power_transform": {},
  "sklearn/sklearn.preprocessing._discretization/KBinsDiscretizer/__init__": {
    "subsample": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.preprocessing._discretization/KBinsDiscretizer/__init__/subsample",
          "name": "subsample",
          "qname": "sklearn.preprocessing._discretization.KBinsDiscretizer.__init__.subsample",
          "default_value": "'warn'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int or None (default='warn')",
            "default_value": "",
            "description": "Maximum number of samples, used to fit the model, for computational\nefficiency. Used when `strategy=\"quantile\"`.\n`subsample=None` means that all the training samples are used when\ncomputing the quantiles that determine the binning thresholds.\nSince quantile computation relies on sorting each column of `X` and\nthat sorting has an `n log(n)` time complexity,\nit is recommended to use subsampling on datasets with a\nvery large number of samples.\n\n.. deprecated:: 1.1\n   In version 1.3 and onwards, `subsample=2e5` will be the default."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "None ("
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.preprocessing._discretization/KBinsDiscretizer/__init__/strategy",
          "name": "strategy",
          "qname": "sklearn.preprocessing._discretization.KBinsDiscretizer.__init__.strategy",
          "default_value": "'quantile'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'uniform', 'quantile', 'kmeans'}",
            "default_value": "'quantile'",
            "description": "Strategy used to define the widths of the bins.\n\n- 'uniform': All bins in each feature have identical widths.\n- 'quantile': All bins in each feature have the same number of points.\n- 'kmeans': Values in each bin have the same nearest center of a 1D\n  k-means cluster."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "uniform",
              "quantile",
              "kmeans"
            ]
          }
        },
        "hasCondition": {
          "condition": "when strategy equals quantile"
        },
        "hasAction": {
          "action": "Used"
        }
      }
    ]
  },
  "sklearn/sklearn.preprocessing._discretization/KBinsDiscretizer/fit": {},
  "sklearn/sklearn.preprocessing._discretization/KBinsDiscretizer/_validate_n_bins": {},
  "sklearn/sklearn.preprocessing._discretization/KBinsDiscretizer/transform": {},
  "sklearn/sklearn.preprocessing._discretization/KBinsDiscretizer/inverse_transform": {},
  "sklearn/sklearn.preprocessing._discretization/KBinsDiscretizer/get_feature_names_out": {
    "input_features": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.preprocessing._discretization/KBinsDiscretizer/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.preprocessing._discretization.KBinsDiscretizer.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features.\n\n- If `input_features` is `None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then the following input feature names are generated:\n  `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.preprocessing._discretization/KBinsDiscretizer/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.preprocessing._discretization.KBinsDiscretizer.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features.\n\n- If `input_features` is `None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then the following input feature names are generated:\n  `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If input_features is None , then feature_names_in _"
        },
        "hasAction": {
          "action": "is used as feature names in"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.preprocessing._discretization/KBinsDiscretizer/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.preprocessing._discretization.KBinsDiscretizer.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features.\n\n- If `input_features` is `None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then the following input feature names are generated:\n  `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.preprocessing._discretization/KBinsDiscretizer/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.preprocessing._discretization.KBinsDiscretizer.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features.\n\n- If `input_features` is `None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then the following input feature names are generated:\n  `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If input_features is"
        },
        "hasAction": {
          "action": "an array - like , then input_features must match feature_names_in _"
        }
      }
    ]
  },
  "sklearn/sklearn.preprocessing._encoders/_BaseEncoder/_check_X": {},
  "sklearn/sklearn.preprocessing._encoders/_BaseEncoder/_fit": {},
  "sklearn/sklearn.preprocessing._encoders/_BaseEncoder/_transform": {},
  "sklearn/sklearn.preprocessing._encoders/_BaseEncoder/_more_tags": {},
  "sklearn/sklearn.preprocessing._encoders/OneHotEncoder/__init__": {},
  "sklearn/sklearn.preprocessing._encoders/OneHotEncoder/infrequent_categories_@getter": {},
  "sklearn/sklearn.preprocessing._encoders/OneHotEncoder/_check_infrequent_enabled": {},
  "sklearn/sklearn.preprocessing._encoders/OneHotEncoder/_map_drop_idx_to_infrequent": {},
  "sklearn/sklearn.preprocessing._encoders/OneHotEncoder/_compute_drop_idx": {},
  "sklearn/sklearn.preprocessing._encoders/OneHotEncoder/_identify_infrequent": {},
  "sklearn/sklearn.preprocessing._encoders/OneHotEncoder/_fit_infrequent_category_mapping": {},
  "sklearn/sklearn.preprocessing._encoders/OneHotEncoder/_map_infrequent_categories": {},
  "sklearn/sklearn.preprocessing._encoders/OneHotEncoder/_compute_transformed_categories": {},
  "sklearn/sklearn.preprocessing._encoders/OneHotEncoder/_remove_dropped_categories": {},
  "sklearn/sklearn.preprocessing._encoders/OneHotEncoder/_compute_n_features_outs": {},
  "sklearn/sklearn.preprocessing._encoders/OneHotEncoder/fit": {},
  "sklearn/sklearn.preprocessing._encoders/OneHotEncoder/transform": {},
  "sklearn/sklearn.preprocessing._encoders/OneHotEncoder/inverse_transform": {},
  "sklearn/sklearn.preprocessing._encoders/OneHotEncoder/get_feature_names_out": {
    "input_features": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.preprocessing._encoders/OneHotEncoder/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.preprocessing._encoders.OneHotEncoder.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features.\n\n- If `input_features` is `None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then the following input feature names are generated:\n  `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.preprocessing._encoders/OneHotEncoder/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.preprocessing._encoders.OneHotEncoder.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features.\n\n- If `input_features` is `None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then the following input feature names are generated:\n  `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If input_features is None , then feature_names_in _"
        },
        "hasAction": {
          "action": "is used as feature names in"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.preprocessing._encoders/OneHotEncoder/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.preprocessing._encoders.OneHotEncoder.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features.\n\n- If `input_features` is `None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then the following input feature names are generated:\n  `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.preprocessing._encoders/OneHotEncoder/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.preprocessing._encoders.OneHotEncoder.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features.\n\n- If `input_features` is `None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then the following input feature names are generated:\n  `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If input_features is"
        },
        "hasAction": {
          "action": "an array - like , then input_features must match feature_names_in _"
        }
      }
    ]
  },
  "sklearn/sklearn.preprocessing._encoders/OrdinalEncoder/__init__": {
    "unknown_value": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.preprocessing._encoders/OrdinalEncoder/__init__/unknown_value",
          "name": "unknown_value",
          "qname": "sklearn.preprocessing._encoders.OrdinalEncoder.__init__.unknown_value",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int or np.nan",
            "default_value": "None",
            "description": "When the parameter handle_unknown is set to 'use_encoded_value', this\nparameter is required and will set the encoded value of unknown\ncategories. It has to be distinct from the values used to encode any of\nthe categories in `fit`. If set to np.nan, the `dtype` parameter must\nbe a float dtype.\n\n.. versionadded:: 0.24"
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "np.nan"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.preprocessing._encoders/OrdinalEncoder/__init__/handle_unknown",
          "name": "handle_unknown",
          "qname": "sklearn.preprocessing._encoders.OrdinalEncoder.__init__.handle_unknown",
          "default_value": "'error'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'error', 'use_encoded_value'}",
            "default_value": "'error'",
            "description": "When set to 'error' an error will be raised in case an unknown\ncategorical feature is present during transform. When set to\n'use_encoded_value', the encoded value of unknown categories will be\nset to the value given for the parameter `unknown_value`. In\n:meth:`inverse_transform`, an unknown category will be denoted as None.\n\n.. versionadded:: 0.24"
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "error",
              "use_encoded_value"
            ]
          }
        },
        "hasCondition": {
          "condition": "When the parameter handle_unknown is set to use_encoded_value"
        },
        "hasAction": {
          "action": ", this parameter is required and will set the encoded value of unknown categories"
        }
      }
    ]
  },
  "sklearn/sklearn.preprocessing._encoders/OrdinalEncoder/fit": {},
  "sklearn/sklearn.preprocessing._encoders/OrdinalEncoder/transform": {},
  "sklearn/sklearn.preprocessing._encoders/OrdinalEncoder/inverse_transform": {},
  "sklearn/sklearn.preprocessing._function_transformer/_identity": {},
  "sklearn/sklearn.preprocessing._function_transformer/FunctionTransformer/__init__": {
    "accept_sparse": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.preprocessing._function_transformer/FunctionTransformer/__init__/accept_sparse",
          "name": "accept_sparse",
          "qname": "sklearn.preprocessing._function_transformer.FunctionTransformer.__init__.accept_sparse",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "Indicate that func accepts a sparse matrix as input. If validate is\nFalse, this has no effect. Otherwise, if accept_sparse is false,\nsparse matrix inputs will cause an exception to be raised."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.preprocessing._function_transformer/FunctionTransformer/__init__/validate",
          "name": "validate",
          "qname": "sklearn.preprocessing._function_transformer.FunctionTransformer.__init__.validate",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "Indicate that the input X array should be checked before calling\n``func``. The possibilities are:\n\n- If False, there is no input validation.\n- If True, then X will be converted to a 2-dimensional NumPy array or\n  sparse matrix. If the conversion is not possible an exception is\n  raised.\n\n.. versionchanged:: 0.22\n   The default of ``validate`` changed from True to False."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "If validate is False"
        },
        "hasAction": {
          "action": ", this has no effect"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.preprocessing._function_transformer/FunctionTransformer/__init__/accept_sparse",
          "name": "accept_sparse",
          "qname": "sklearn.preprocessing._function_transformer.FunctionTransformer.__init__.accept_sparse",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "Indicate that func accepts a sparse matrix as input. If validate is\nFalse, this has no effect. Otherwise, if accept_sparse is false,\nsparse matrix inputs will cause an exception to be raised."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.preprocessing._function_transformer/FunctionTransformer/__init__/accept_sparse",
          "name": "accept_sparse",
          "qname": "sklearn.preprocessing._function_transformer.FunctionTransformer.__init__.accept_sparse",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "Indicate that func accepts a sparse matrix as input. If validate is\nFalse, this has no effect. Otherwise, if accept_sparse is false,\nsparse matrix inputs will cause an exception to be raised."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "if accept_sparse is false"
        },
        "hasAction": {
          "action": "Otherwise , , sparse matrix inputs will cause an exception to be raised"
        }
      }
    ],
    "feature_names_out": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.preprocessing._function_transformer/FunctionTransformer/__init__/feature_names_out",
          "name": "feature_names_out",
          "qname": "sklearn.preprocessing._function_transformer.FunctionTransformer.__init__.feature_names_out",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "callable, 'one-to-one' or None",
            "default_value": "None",
            "description": "Determines the list of feature names that will be returned by the\n`get_feature_names_out` method. If it is 'one-to-one', then the output\nfeature names will be equal to the input feature names. If it is a\ncallable, then it must take two positional arguments: this\n`FunctionTransformer` (`self`) and an array-like of input feature names\n(`input_features`). It must return an array-like of output feature\nnames. The `get_feature_names_out` method is only defined if\n`feature_names_out` is not None.\n\nSee ``get_feature_names_out`` for more details.\n\n.. versionadded:: 1.1"
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "callable"
              },
              {
                "kind": "NamedType",
                "name": "'one-to-one'"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.preprocessing._function_transformer/FunctionTransformer/__init__/feature_names_out",
          "name": "feature_names_out",
          "qname": "sklearn.preprocessing._function_transformer.FunctionTransformer.__init__.feature_names_out",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "callable, 'one-to-one' or None",
            "default_value": "None",
            "description": "Determines the list of feature names that will be returned by the\n`get_feature_names_out` method. If it is 'one-to-one', then the output\nfeature names will be equal to the input feature names. If it is a\ncallable, then it must take two positional arguments: this\n`FunctionTransformer` (`self`) and an array-like of input feature names\n(`input_features`). It must return an array-like of output feature\nnames. The `get_feature_names_out` method is only defined if\n`feature_names_out` is not None.\n\nSee ``get_feature_names_out`` for more details.\n\n.. versionadded:: 1.1"
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "callable"
              },
              {
                "kind": "NamedType",
                "name": "'one-to-one'"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "if feature_names_out is not None"
        },
        "hasAction": {
          "action": "The get_feature_names_out method is only defined"
        }
      }
    ]
  },
  "sklearn/sklearn.preprocessing._function_transformer/FunctionTransformer/_check_input": {},
  "sklearn/sklearn.preprocessing._function_transformer/FunctionTransformer/_check_inverse_transform": {},
  "sklearn/sklearn.preprocessing._function_transformer/FunctionTransformer/fit": {},
  "sklearn/sklearn.preprocessing._function_transformer/FunctionTransformer/transform": {},
  "sklearn/sklearn.preprocessing._function_transformer/FunctionTransformer/inverse_transform": {},
  "sklearn/sklearn.preprocessing._function_transformer/FunctionTransformer/get_feature_names_out": {
    "input_features": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.preprocessing._function_transformer/FunctionTransformer/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.preprocessing._function_transformer.FunctionTransformer.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input feature names.\n\n- If `input_features` is None, then `feature_names_in_` is\n  used as the input feature names. If `feature_names_in_` is not\n  defined, then names are generated:\n  `[x0, x1, ..., x(n_features_in_ - 1)]`.\n- If `input_features` is array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.preprocessing._function_transformer/FunctionTransformer/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.preprocessing._function_transformer.FunctionTransformer.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input feature names.\n\n- If `input_features` is None, then `feature_names_in_` is\n  used as the input feature names. If `feature_names_in_` is not\n  defined, then names are generated:\n  `[x0, x1, ..., x(n_features_in_ - 1)]`.\n- If `input_features` is array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If input_features is None , then feature_names_in _"
        },
        "hasAction": {
          "action": "is used as the input feature names"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.preprocessing._function_transformer/FunctionTransformer/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.preprocessing._function_transformer.FunctionTransformer.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input feature names.\n\n- If `input_features` is None, then `feature_names_in_` is\n  used as the input feature names. If `feature_names_in_` is not\n  defined, then names are generated:\n  `[x0, x1, ..., x(n_features_in_ - 1)]`.\n- If `input_features` is array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.preprocessing._function_transformer/FunctionTransformer/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.preprocessing._function_transformer.FunctionTransformer.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input feature names.\n\n- If `input_features` is None, then `feature_names_in_` is\n  used as the input feature names. If `feature_names_in_` is not\n  defined, then names are generated:\n  `[x0, x1, ..., x(n_features_in_ - 1)]`.\n- If `input_features` is array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If input_features is array - like"
        },
        "hasAction": {
          "action": ", then input_features must match feature_names_in _ if feature_names_in _ is defined"
        }
      }
    ]
  },
  "sklearn/sklearn.preprocessing._function_transformer/FunctionTransformer/_transform": {},
  "sklearn/sklearn.preprocessing._function_transformer/FunctionTransformer/__sklearn_is_fitted__": {},
  "sklearn/sklearn.preprocessing._function_transformer/FunctionTransformer/_more_tags": {},
  "sklearn/sklearn.preprocessing._function_transformer/FunctionTransformer/set_output": {},
  "sklearn/sklearn.preprocessing._label/LabelEncoder/fit": {},
  "sklearn/sklearn.preprocessing._label/LabelEncoder/fit_transform": {},
  "sklearn/sklearn.preprocessing._label/LabelEncoder/transform": {},
  "sklearn/sklearn.preprocessing._label/LabelEncoder/inverse_transform": {},
  "sklearn/sklearn.preprocessing._label/LabelEncoder/_more_tags": {},
  "sklearn/sklearn.preprocessing._label/LabelBinarizer/__init__": {},
  "sklearn/sklearn.preprocessing._label/LabelBinarizer/fit": {},
  "sklearn/sklearn.preprocessing._label/LabelBinarizer/fit_transform": {},
  "sklearn/sklearn.preprocessing._label/LabelBinarizer/transform": {},
  "sklearn/sklearn.preprocessing._label/LabelBinarizer/inverse_transform": {
    "threshold": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.preprocessing._label/LabelBinarizer/inverse_transform/threshold",
          "name": "threshold",
          "qname": "sklearn.preprocessing._label.LabelBinarizer.inverse_transform.threshold",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "None",
            "description": "Threshold used in the binary and multi-label cases.\n\nUse 0 when ``Y`` contains the output of decision_function\n(classifier).\nUse 0.5 when ``Y`` contains the output of predict_proba.\n\nIf None, the threshold is assumed to be half way between\nneg_label and pos_label."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.preprocessing._label/LabelBinarizer/inverse_transform/Y",
          "name": "Y",
          "qname": "sklearn.preprocessing._label.LabelBinarizer.inverse_transform.Y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "{ndarray, sparse matrix} of shape (n_samples, n_classes)",
            "default_value": "",
            "description": "Target values. All sparse matrices are converted to CSR before\ninverse transformation."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "EnumType",
                "values": []
              },
              {
                "kind": "NamedType",
                "name": "of shape (n_samples, n_classes)"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "when Y contains the output of decision_function ( classifier )"
        },
        "hasAction": {
          "action": "Use 0"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.preprocessing._label/LabelBinarizer/inverse_transform/threshold",
          "name": "threshold",
          "qname": "sklearn.preprocessing._label.LabelBinarizer.inverse_transform.threshold",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "None",
            "description": "Threshold used in the binary and multi-label cases.\n\nUse 0 when ``Y`` contains the output of decision_function\n(classifier).\nUse 0.5 when ``Y`` contains the output of predict_proba.\n\nIf None, the threshold is assumed to be half way between\nneg_label and pos_label."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.preprocessing._label/LabelBinarizer/inverse_transform/Y",
          "name": "Y",
          "qname": "sklearn.preprocessing._label.LabelBinarizer.inverse_transform.Y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "{ndarray, sparse matrix} of shape (n_samples, n_classes)",
            "default_value": "",
            "description": "Target values. All sparse matrices are converted to CSR before\ninverse transformation."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "EnumType",
                "values": []
              },
              {
                "kind": "NamedType",
                "name": "of shape (n_samples, n_classes)"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "when Y contains the output of predict_proba"
        },
        "hasAction": {
          "action": "Use 0.5"
        }
      }
    ]
  },
  "sklearn/sklearn.preprocessing._label/LabelBinarizer/_more_tags": {},
  "sklearn/sklearn.preprocessing._label/label_binarize": {},
  "sklearn/sklearn.preprocessing._label/_inverse_binarize_multiclass": {},
  "sklearn/sklearn.preprocessing._label/_inverse_binarize_thresholding": {},
  "sklearn/sklearn.preprocessing._label/MultiLabelBinarizer/__init__": {},
  "sklearn/sklearn.preprocessing._label/MultiLabelBinarizer/fit": {},
  "sklearn/sklearn.preprocessing._label/MultiLabelBinarizer/fit_transform": {},
  "sklearn/sklearn.preprocessing._label/MultiLabelBinarizer/transform": {},
  "sklearn/sklearn.preprocessing._label/MultiLabelBinarizer/_build_cache": {},
  "sklearn/sklearn.preprocessing._label/MultiLabelBinarizer/_transform": {},
  "sklearn/sklearn.preprocessing._label/MultiLabelBinarizer/inverse_transform": {},
  "sklearn/sklearn.preprocessing._label/MultiLabelBinarizer/_more_tags": {},
  "sklearn/sklearn.preprocessing._polynomial/PolynomialFeatures/__init__": {},
  "sklearn/sklearn.preprocessing._polynomial/PolynomialFeatures/_combinations": {},
  "sklearn/sklearn.preprocessing._polynomial/PolynomialFeatures/_num_combinations": {},
  "sklearn/sklearn.preprocessing._polynomial/PolynomialFeatures/powers_@getter": {},
  "sklearn/sklearn.preprocessing._polynomial/PolynomialFeatures/get_feature_names_out": {
    "input_features": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.preprocessing._polynomial/PolynomialFeatures/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.preprocessing._polynomial.PolynomialFeatures.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features.\n\n- If `input_features is None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then the following input feature names are generated:\n  `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.preprocessing._polynomial/PolynomialFeatures/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.preprocessing._polynomial.PolynomialFeatures.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features.\n\n- If `input_features is None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then the following input feature names are generated:\n  `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If input_features is None , then feature_names_in _"
        },
        "hasAction": {
          "action": "is used as feature names in"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.preprocessing._polynomial/PolynomialFeatures/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.preprocessing._polynomial.PolynomialFeatures.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features.\n\n- If `input_features is None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then the following input feature names are generated:\n  `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.preprocessing._polynomial/PolynomialFeatures/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.preprocessing._polynomial.PolynomialFeatures.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features.\n\n- If `input_features is None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then the following input feature names are generated:\n  `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If input_features is"
        },
        "hasAction": {
          "action": "an array - like , then input_features must match feature_names_in _"
        }
      }
    ]
  },
  "sklearn/sklearn.preprocessing._polynomial/PolynomialFeatures/fit": {},
  "sklearn/sklearn.preprocessing._polynomial/PolynomialFeatures/transform": {},
  "sklearn/sklearn.preprocessing._polynomial/SplineTransformer/__init__": {
    "n_knots": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.preprocessing._polynomial/SplineTransformer/__init__/n_knots",
          "name": "n_knots",
          "qname": "sklearn.preprocessing._polynomial.SplineTransformer.__init__.n_knots",
          "default_value": "5",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "5",
            "description": "Number of knots of the splines if `knots` equals one of\n{'uniform', 'quantile'}. Must be larger or equal 2. Ignored if `knots`\nis array-like."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.preprocessing._polynomial/SplineTransformer/__init__/knots",
          "name": "knots",
          "qname": "sklearn.preprocessing._polynomial.SplineTransformer.__init__.knots",
          "default_value": "'uniform'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'uniform', 'quantile'} or array-like of shape         (n_knots, n_features)",
            "default_value": "'uniform'",
            "description": "Set knot positions such that first knot <= features <= last knot.\n\n- If 'uniform', `n_knots` number of knots are distributed uniformly\n  from min to max values of the features.\n- If 'quantile', they are distributed uniformly along the quantiles of\n  the features.\n- If an array-like is given, it directly specifies the sorted knot\n  positions including the boundary knots. Note that, internally,\n  `degree` number of knots are added before the first knot, the same\n  after the last knot."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "EnumType",
                "values": [
                  "uniform",
                  "quantile"
                ]
              },
              {
                "kind": "NamedType",
                "name": "array-like of shape (n_knots, n_features)"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "if knots is array - like"
        },
        "hasAction": {
          "action": "Ignored"
        }
      }
    ]
  },
  "sklearn/sklearn.preprocessing._polynomial/SplineTransformer/_get_base_knot_positions": {},
  "sklearn/sklearn.preprocessing._polynomial/SplineTransformer/get_feature_names_out": {
    "input_features": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.preprocessing._polynomial/SplineTransformer/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.preprocessing._polynomial.SplineTransformer.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features.\n\n- If `input_features` is `None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then the following input feature names are generated:\n  `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.preprocessing._polynomial/SplineTransformer/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.preprocessing._polynomial.SplineTransformer.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features.\n\n- If `input_features` is `None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then the following input feature names are generated:\n  `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If input_features is None , then feature_names_in _"
        },
        "hasAction": {
          "action": "is used as feature names in"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.preprocessing._polynomial/SplineTransformer/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.preprocessing._polynomial.SplineTransformer.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features.\n\n- If `input_features` is `None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then the following input feature names are generated:\n  `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.preprocessing._polynomial/SplineTransformer/get_feature_names_out/input_features",
          "name": "input_features",
          "qname": "sklearn.preprocessing._polynomial.SplineTransformer.get_feature_names_out.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features.\n\n- If `input_features` is `None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then the following input feature names are generated:\n  `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If input_features is"
        },
        "hasAction": {
          "action": "an array - like , then input_features must match feature_names_in _"
        }
      }
    ]
  },
  "sklearn/sklearn.preprocessing._polynomial/SplineTransformer/fit": {},
  "sklearn/sklearn.preprocessing._polynomial/SplineTransformer/transform": {},
  "sklearn/sklearn.svm._base/_one_vs_one_coef": {},
  "sklearn/sklearn.svm._base/BaseLibSVM/__init__": {},
  "sklearn/sklearn.svm._base/BaseLibSVM/_more_tags": {},
  "sklearn/sklearn.svm._base/BaseLibSVM/fit": {},
  "sklearn/sklearn.svm._base/BaseLibSVM/_validate_targets": {},
  "sklearn/sklearn.svm._base/BaseLibSVM/_warn_from_fit_status": {},
  "sklearn/sklearn.svm._base/BaseLibSVM/_dense_fit": {},
  "sklearn/sklearn.svm._base/BaseLibSVM/_sparse_fit": {},
  "sklearn/sklearn.svm._base/BaseLibSVM/predict": {},
  "sklearn/sklearn.svm._base/BaseLibSVM/_dense_predict": {},
  "sklearn/sklearn.svm._base/BaseLibSVM/_sparse_predict": {},
  "sklearn/sklearn.svm._base/BaseLibSVM/_compute_kernel": {},
  "sklearn/sklearn.svm._base/BaseLibSVM/_decision_function": {},
  "sklearn/sklearn.svm._base/BaseLibSVM/_dense_decision_function": {},
  "sklearn/sklearn.svm._base/BaseLibSVM/_sparse_decision_function": {},
  "sklearn/sklearn.svm._base/BaseLibSVM/_validate_for_predict": {},
  "sklearn/sklearn.svm._base/BaseLibSVM/coef_@getter": {},
  "sklearn/sklearn.svm._base/BaseLibSVM/_get_coef": {},
  "sklearn/sklearn.svm._base/BaseLibSVM/n_support_@getter": {},
  "sklearn/sklearn.svm._base/BaseSVC/__init__": {},
  "sklearn/sklearn.svm._base/BaseSVC/_validate_targets": {},
  "sklearn/sklearn.svm._base/BaseSVC/decision_function": {},
  "sklearn/sklearn.svm._base/BaseSVC/predict": {},
  "sklearn/sklearn.svm._base/BaseSVC/_check_proba": {},
  "sklearn/sklearn.svm._base/BaseSVC/predict_proba": {},
  "sklearn/sklearn.svm._base/BaseSVC/predict_log_proba": {},
  "sklearn/sklearn.svm._base/BaseSVC/_dense_predict_proba": {},
  "sklearn/sklearn.svm._base/BaseSVC/_sparse_predict_proba": {},
  "sklearn/sklearn.svm._base/BaseSVC/_get_coef": {},
  "sklearn/sklearn.svm._base/BaseSVC/probA_@getter": {},
  "sklearn/sklearn.svm._base/BaseSVC/probB_@getter": {},
  "sklearn/sklearn.svm._base/BaseSVC/_class_weight@getter": {},
  "sklearn/sklearn.svm._base/_get_liblinear_solver_type": {},
  "sklearn/sklearn.svm._base/_fit_liblinear": {},
  "sklearn/sklearn.svm._bounds/l1_min_c": {
    "intercept_scaling": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.svm._bounds/l1_min_c/intercept_scaling",
          "name": "intercept_scaling",
          "qname": "sklearn.svm._bounds.l1_min_c.intercept_scaling",
          "default_value": "1.0",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "1.0",
            "description": "When fit_intercept is True, instance vector x becomes\n[x, intercept_scaling],\ni.e. a \"synthetic\" feature with constant value equals to\nintercept_scaling is appended to the instance vector.\nIt must match the fit() method parameter."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.svm._bounds/l1_min_c/fit_intercept",
          "name": "fit_intercept",
          "qname": "sklearn.svm._bounds.l1_min_c.fit_intercept",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Specifies if the intercept should be fitted by the model.\nIt must match the fit() method parameter."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "When fit_intercept is True"
        },
        "hasAction": {
          "action": ", instance vector x becomes [ x , intercept_scaling ] , i.e. a synthetic feature with constant value equals to intercept_scaling"
        }
      }
    ]
  },
  "sklearn/sklearn.svm._classes/LinearSVC/__init__": {
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.svm._classes/LinearSVC/__init__/random_state",
          "name": "random_state",
          "qname": "sklearn.svm._classes.LinearSVC.__init__.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance or None",
            "default_value": "None",
            "description": "Controls the pseudo random number generation for shuffling the data for\nthe dual coordinate descent (if ``dual=True``). When ``dual=False`` the\nunderlying implementation of :class:`LinearSVC` is not random and\n``random_state`` has no effect on the results.\nPass an int for reproducible output across multiple function calls.\nSee :term:`Glossary <random_state>`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.svm._classes/LinearSVC/__init__/dual",
          "name": "dual",
          "qname": "sklearn.svm._classes.LinearSVC.__init__.dual",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Select the algorithm to either solve the dual or primal\noptimization problem. Prefer dual=False when n_samples > n_features."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "if dual equals True )"
        },
        "hasAction": {
          "action": "Controls the pseudo random number generation for shuffling the data for the dual coordinate descent ("
        }
      }
    ]
  },
  "sklearn/sklearn.svm._classes/LinearSVC/fit": {},
  "sklearn/sklearn.svm._classes/LinearSVC/_more_tags": {},
  "sklearn/sklearn.svm._classes/LinearSVR/__init__": {},
  "sklearn/sklearn.svm._classes/LinearSVR/fit": {},
  "sklearn/sklearn.svm._classes/LinearSVR/_more_tags": {},
  "sklearn/sklearn.svm._classes/SVC/__init__": {
    "gamma": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.svm._classes/SVC/__init__/gamma",
          "name": "gamma",
          "qname": "sklearn.svm._classes.SVC.__init__.gamma",
          "default_value": "'scale'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'scale', 'auto'} or float",
            "default_value": "'scale'",
            "description": "Kernel coefficient for 'rbf', 'poly' and 'sigmoid'.\n\n- if ``gamma='scale'`` (default) is passed then it uses\n  1 / (n_features * X.var()) as value of gamma,\n- if 'auto', uses 1 / n_features\n- if float, must be non-negative.\n\n.. versionchanged:: 0.22\n   The default value of ``gamma`` changed from 'auto' to 'scale'."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "EnumType",
                "values": [
                  "scale",
                  "auto"
                ]
              },
              {
                "kind": "NamedType",
                "name": "float"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.svm._classes/SVC/__init__/gamma",
          "name": "gamma",
          "qname": "sklearn.svm._classes.SVC.__init__.gamma",
          "default_value": "'scale'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'scale', 'auto'} or float",
            "default_value": "'scale'",
            "description": "Kernel coefficient for 'rbf', 'poly' and 'sigmoid'.\n\n- if ``gamma='scale'`` (default) is passed then it uses\n  1 / (n_features * X.var()) as value of gamma,\n- if 'auto', uses 1 / n_features\n- if float, must be non-negative.\n\n.. versionchanged:: 0.22\n   The default value of ``gamma`` changed from 'auto' to 'scale'."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "EnumType",
                "values": [
                  "scale",
                  "auto"
                ]
              },
              {
                "kind": "NamedType",
                "name": "float"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "if gamma equals scale ( default )"
        },
        "hasAction": {
          "action": "- is passed then"
        }
      }
    ],
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.svm._classes/SVC/__init__/random_state",
          "name": "random_state",
          "qname": "sklearn.svm._classes.SVC.__init__.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance or None",
            "default_value": "None",
            "description": "Controls the pseudo random number generation for shuffling the data for\nprobability estimates. Ignored when `probability` is False.\nPass an int for reproducible output across multiple function calls.\nSee :term:`Glossary <random_state>`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.svm._classes/SVC/__init__/probability",
          "name": "probability",
          "qname": "sklearn.svm._classes.SVC.__init__.probability",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "Whether to enable probability estimates. This must be enabled prior\nto calling `fit`, will slow down that method as it internally uses\n5-fold cross-validation, and `predict_proba` may be inconsistent with\n`predict`. Read more in the :ref:`User Guide <scores_probabilities>`."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "when probability is False"
        },
        "hasAction": {
          "action": "Ignored"
        }
      }
    ]
  },
  "sklearn/sklearn.svm._classes/SVC/_more_tags": {},
  "sklearn/sklearn.svm._classes/NuSVC/__init__": {
    "gamma": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.svm._classes/NuSVC/__init__/gamma",
          "name": "gamma",
          "qname": "sklearn.svm._classes.NuSVC.__init__.gamma",
          "default_value": "'scale'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'scale', 'auto'} or float",
            "default_value": "'scale'",
            "description": "Kernel coefficient for 'rbf', 'poly' and 'sigmoid'.\n\n- if ``gamma='scale'`` (default) is passed then it uses\n  1 / (n_features * X.var()) as value of gamma,\n- if 'auto', uses 1 / n_features\n- if float, must be non-negative.\n\n.. versionchanged:: 0.22\n   The default value of ``gamma`` changed from 'auto' to 'scale'."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "EnumType",
                "values": [
                  "scale",
                  "auto"
                ]
              },
              {
                "kind": "NamedType",
                "name": "float"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.svm._classes/NuSVC/__init__/gamma",
          "name": "gamma",
          "qname": "sklearn.svm._classes.NuSVC.__init__.gamma",
          "default_value": "'scale'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'scale', 'auto'} or float",
            "default_value": "'scale'",
            "description": "Kernel coefficient for 'rbf', 'poly' and 'sigmoid'.\n\n- if ``gamma='scale'`` (default) is passed then it uses\n  1 / (n_features * X.var()) as value of gamma,\n- if 'auto', uses 1 / n_features\n- if float, must be non-negative.\n\n.. versionchanged:: 0.22\n   The default value of ``gamma`` changed from 'auto' to 'scale'."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "EnumType",
                "values": [
                  "scale",
                  "auto"
                ]
              },
              {
                "kind": "NamedType",
                "name": "float"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "if gamma equals scale ( default )"
        },
        "hasAction": {
          "action": "- is passed then"
        }
      }
    ],
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.svm._classes/NuSVC/__init__/random_state",
          "name": "random_state",
          "qname": "sklearn.svm._classes.NuSVC.__init__.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance or None",
            "default_value": "None",
            "description": "Controls the pseudo random number generation for shuffling the data for\nprobability estimates. Ignored when `probability` is False.\nPass an int for reproducible output across multiple function calls.\nSee :term:`Glossary <random_state>`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.svm._classes/NuSVC/__init__/probability",
          "name": "probability",
          "qname": "sklearn.svm._classes.NuSVC.__init__.probability",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "Whether to enable probability estimates. This must be enabled prior\nto calling `fit`, will slow down that method as it internally uses\n5-fold cross-validation, and `predict_proba` may be inconsistent with\n`predict`. Read more in the :ref:`User Guide <scores_probabilities>`."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "when probability is False"
        },
        "hasAction": {
          "action": "Ignored"
        }
      }
    ]
  },
  "sklearn/sklearn.svm._classes/NuSVC/_more_tags": {},
  "sklearn/sklearn.svm._classes/SVR/__init__": {
    "gamma": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.svm._classes/SVR/__init__/gamma",
          "name": "gamma",
          "qname": "sklearn.svm._classes.SVR.__init__.gamma",
          "default_value": "'scale'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'scale', 'auto'} or float",
            "default_value": "'scale'",
            "description": "Kernel coefficient for 'rbf', 'poly' and 'sigmoid'.\n\n- if ``gamma='scale'`` (default) is passed then it uses\n  1 / (n_features * X.var()) as value of gamma,\n- if 'auto', uses 1 / n_features\n- if float, must be non-negative.\n\n.. versionchanged:: 0.22\n   The default value of ``gamma`` changed from 'auto' to 'scale'."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "EnumType",
                "values": [
                  "scale",
                  "auto"
                ]
              },
              {
                "kind": "NamedType",
                "name": "float"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.svm._classes/SVR/__init__/gamma",
          "name": "gamma",
          "qname": "sklearn.svm._classes.SVR.__init__.gamma",
          "default_value": "'scale'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'scale', 'auto'} or float",
            "default_value": "'scale'",
            "description": "Kernel coefficient for 'rbf', 'poly' and 'sigmoid'.\n\n- if ``gamma='scale'`` (default) is passed then it uses\n  1 / (n_features * X.var()) as value of gamma,\n- if 'auto', uses 1 / n_features\n- if float, must be non-negative.\n\n.. versionchanged:: 0.22\n   The default value of ``gamma`` changed from 'auto' to 'scale'."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "EnumType",
                "values": [
                  "scale",
                  "auto"
                ]
              },
              {
                "kind": "NamedType",
                "name": "float"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "if gamma equals scale ( default )"
        },
        "hasAction": {
          "action": "- is passed then"
        }
      }
    ]
  },
  "sklearn/sklearn.svm._classes/SVR/class_weight_@getter": {},
  "sklearn/sklearn.svm._classes/SVR/_more_tags": {},
  "sklearn/sklearn.svm._classes/NuSVR/__init__": {
    "gamma": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.svm._classes/NuSVR/__init__/gamma",
          "name": "gamma",
          "qname": "sklearn.svm._classes.NuSVR.__init__.gamma",
          "default_value": "'scale'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'scale', 'auto'} or float",
            "default_value": "'scale'",
            "description": "Kernel coefficient for 'rbf', 'poly' and 'sigmoid'.\n\n- if ``gamma='scale'`` (default) is passed then it uses\n  1 / (n_features * X.var()) as value of gamma,\n- if 'auto', uses 1 / n_features\n- if float, must be non-negative.\n\n.. versionchanged:: 0.22\n   The default value of ``gamma`` changed from 'auto' to 'scale'."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "EnumType",
                "values": [
                  "scale",
                  "auto"
                ]
              },
              {
                "kind": "NamedType",
                "name": "float"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.svm._classes/NuSVR/__init__/gamma",
          "name": "gamma",
          "qname": "sklearn.svm._classes.NuSVR.__init__.gamma",
          "default_value": "'scale'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'scale', 'auto'} or float",
            "default_value": "'scale'",
            "description": "Kernel coefficient for 'rbf', 'poly' and 'sigmoid'.\n\n- if ``gamma='scale'`` (default) is passed then it uses\n  1 / (n_features * X.var()) as value of gamma,\n- if 'auto', uses 1 / n_features\n- if float, must be non-negative.\n\n.. versionchanged:: 0.22\n   The default value of ``gamma`` changed from 'auto' to 'scale'."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "EnumType",
                "values": [
                  "scale",
                  "auto"
                ]
              },
              {
                "kind": "NamedType",
                "name": "float"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "if gamma equals scale ( default )"
        },
        "hasAction": {
          "action": "- is passed then"
        }
      }
    ]
  },
  "sklearn/sklearn.svm._classes/NuSVR/class_weight_@getter": {},
  "sklearn/sklearn.svm._classes/NuSVR/_more_tags": {},
  "sklearn/sklearn.svm._classes/OneClassSVM/__init__": {
    "gamma": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.svm._classes/OneClassSVM/__init__/gamma",
          "name": "gamma",
          "qname": "sklearn.svm._classes.OneClassSVM.__init__.gamma",
          "default_value": "'scale'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'scale', 'auto'} or float",
            "default_value": "'scale'",
            "description": "Kernel coefficient for 'rbf', 'poly' and 'sigmoid'.\n\n- if ``gamma='scale'`` (default) is passed then it uses\n  1 / (n_features * X.var()) as value of gamma,\n- if 'auto', uses 1 / n_features\n- if float, must be non-negative.\n\n.. versionchanged:: 0.22\n   The default value of ``gamma`` changed from 'auto' to 'scale'."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "EnumType",
                "values": [
                  "scale",
                  "auto"
                ]
              },
              {
                "kind": "NamedType",
                "name": "float"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.svm._classes/OneClassSVM/__init__/gamma",
          "name": "gamma",
          "qname": "sklearn.svm._classes.OneClassSVM.__init__.gamma",
          "default_value": "'scale'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'scale', 'auto'} or float",
            "default_value": "'scale'",
            "description": "Kernel coefficient for 'rbf', 'poly' and 'sigmoid'.\n\n- if ``gamma='scale'`` (default) is passed then it uses\n  1 / (n_features * X.var()) as value of gamma,\n- if 'auto', uses 1 / n_features\n- if float, must be non-negative.\n\n.. versionchanged:: 0.22\n   The default value of ``gamma`` changed from 'auto' to 'scale'."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "EnumType",
                "values": [
                  "scale",
                  "auto"
                ]
              },
              {
                "kind": "NamedType",
                "name": "float"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "if gamma equals scale ( default )"
        },
        "hasAction": {
          "action": "- is passed then"
        }
      }
    ]
  },
  "sklearn/sklearn.svm._classes/OneClassSVM/class_weight_@getter": {},
  "sklearn/sklearn.svm._classes/OneClassSVM/fit": {},
  "sklearn/sklearn.svm._classes/OneClassSVM/decision_function": {},
  "sklearn/sklearn.svm._classes/OneClassSVM/score_samples": {},
  "sklearn/sklearn.svm._classes/OneClassSVM/predict": {},
  "sklearn/sklearn.svm._classes/OneClassSVM/_more_tags": {},
  "sklearn/sklearn.tree._classes/BaseDecisionTree/__init__": {},
  "sklearn/sklearn.tree._classes/BaseDecisionTree/get_depth": {},
  "sklearn/sklearn.tree._classes/BaseDecisionTree/get_n_leaves": {},
  "sklearn/sklearn.tree._classes/BaseDecisionTree/fit": {},
  "sklearn/sklearn.tree._classes/BaseDecisionTree/_validate_X_predict": {},
  "sklearn/sklearn.tree._classes/BaseDecisionTree/predict": {},
  "sklearn/sklearn.tree._classes/BaseDecisionTree/apply": {},
  "sklearn/sklearn.tree._classes/BaseDecisionTree/decision_path": {},
  "sklearn/sklearn.tree._classes/BaseDecisionTree/_prune_tree": {},
  "sklearn/sklearn.tree._classes/BaseDecisionTree/cost_complexity_pruning_path": {},
  "sklearn/sklearn.tree._classes/BaseDecisionTree/feature_importances_@getter": {},
  "sklearn/sklearn.tree._classes/DecisionTreeClassifier/__init__": {
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.tree._classes/DecisionTreeClassifier/__init__/random_state",
          "name": "random_state",
          "qname": "sklearn.tree._classes.DecisionTreeClassifier.__init__.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance or None",
            "default_value": "None",
            "description": "Controls the randomness of the estimator. The features are always\nrandomly permuted at each split, even if ``splitter`` is set to\n``\"best\"``. When ``max_features < n_features``, the algorithm will\nselect ``max_features`` at random at each split before finding the best\nsplit among them. But the best found split may vary across different\nruns, even if ``max_features=n_features``. That is the case, if the\nimprovement of the criterion is identical for several splits and one\nsplit has to be selected at random. To obtain a deterministic behaviour\nduring fitting, ``random_state`` has to be fixed to an integer.\nSee :term:`Glossary <random_state>` for details."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.tree._classes/DecisionTreeClassifier/__init__/max_features",
          "name": "max_features",
          "qname": "sklearn.tree._classes.DecisionTreeClassifier.__init__.max_features",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, float or {\"auto\", \"sqrt\", \"log2\"}",
            "default_value": "None",
            "description": "The number of features to consider when looking for the best split:\n\n    - If int, then consider `max_features` features at each split.\n    - If float, then `max_features` is a fraction and\n      `max(1, int(max_features * n_features_in_))` features are considered at\n      each split.\n    - If \"auto\", then `max_features=sqrt(n_features)`.\n    - If \"sqrt\", then `max_features=sqrt(n_features)`.\n    - If \"log2\", then `max_features=log2(n_features)`.\n    - If None, then `max_features=n_features`.\n\n    .. deprecated:: 1.1\n        The `\"auto\"` option was deprecated in 1.1 and will be removed\n        in 1.3.\n\nNote: the search for a split does not stop until at least one\nvalid partition of the node samples is found, even if it requires to\neffectively inspect more than ``max_features`` features."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "EnumType",
                "values": [
                  "log2",
                  "sqrt",
                  "auto"
                ]
              },
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "float"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "even if max_features equals n_features"
        },
        "hasAction": {
          "action": "But the best found split may vary across different runs ,"
        }
      }
    ]
  },
  "sklearn/sklearn.tree._classes/DecisionTreeClassifier/fit": {},
  "sklearn/sklearn.tree._classes/DecisionTreeClassifier/predict_proba": {},
  "sklearn/sklearn.tree._classes/DecisionTreeClassifier/predict_log_proba": {},
  "sklearn/sklearn.tree._classes/DecisionTreeClassifier/_more_tags": {},
  "sklearn/sklearn.tree._classes/DecisionTreeRegressor/__init__": {
    "random_state": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.tree._classes/DecisionTreeRegressor/__init__/random_state",
          "name": "random_state",
          "qname": "sklearn.tree._classes.DecisionTreeRegressor.__init__.random_state",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, RandomState instance or None",
            "default_value": "None",
            "description": "Controls the randomness of the estimator. The features are always\nrandomly permuted at each split, even if ``splitter`` is set to\n``\"best\"``. When ``max_features < n_features``, the algorithm will\nselect ``max_features`` at random at each split before finding the best\nsplit among them. But the best found split may vary across different\nruns, even if ``max_features=n_features``. That is the case, if the\nimprovement of the criterion is identical for several splits and one\nsplit has to be selected at random. To obtain a deterministic behaviour\nduring fitting, ``random_state`` has to be fixed to an integer.\nSee :term:`Glossary <random_state>` for details."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "RandomState instance"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.tree._classes/DecisionTreeRegressor/__init__/max_features",
          "name": "max_features",
          "qname": "sklearn.tree._classes.DecisionTreeRegressor.__init__.max_features",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int, float or {\"auto\", \"sqrt\", \"log2\"}",
            "default_value": "None",
            "description": "The number of features to consider when looking for the best split:\n\n- If int, then consider `max_features` features at each split.\n- If float, then `max_features` is a fraction and\n  `max(1, int(max_features * n_features_in_))` features are considered at each\n  split.\n- If \"auto\", then `max_features=n_features`.\n- If \"sqrt\", then `max_features=sqrt(n_features)`.\n- If \"log2\", then `max_features=log2(n_features)`.\n- If None, then `max_features=n_features`.\n\n.. deprecated:: 1.1\n    The `\"auto\"` option was deprecated in 1.1 and will be removed\n    in 1.3.\n\nNote: the search for a split does not stop until at least one\nvalid partition of the node samples is found, even if it requires to\neffectively inspect more than ``max_features`` features."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "EnumType",
                "values": [
                  "log2",
                  "sqrt",
                  "auto"
                ]
              },
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "float"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "even if max_features equals n_features"
        },
        "hasAction": {
          "action": "But the best found split may vary across different runs ,"
        }
      }
    ]
  },
  "sklearn/sklearn.tree._classes/DecisionTreeRegressor/fit": {},
  "sklearn/sklearn.tree._classes/DecisionTreeRegressor/_compute_partial_dependence_recursion": {},
  "sklearn/sklearn.tree._classes/ExtraTreeClassifier/__init__": {},
  "sklearn/sklearn.tree._classes/ExtraTreeRegressor/__init__": {},
  "sklearn/sklearn.tree._export/_color_brew": {},
  "sklearn/sklearn.tree._export/Sentinel/__repr__": {},
  "sklearn/sklearn.tree._export/plot_tree": {},
  "sklearn/sklearn.tree._export/_BaseTreeExporter/__init__": {},
  "sklearn/sklearn.tree._export/_BaseTreeExporter/get_color": {},
  "sklearn/sklearn.tree._export/_BaseTreeExporter/get_fill_color": {},
  "sklearn/sklearn.tree._export/_BaseTreeExporter/node_to_str": {},
  "sklearn/sklearn.tree._export/_DOTTreeExporter/__init__": {},
  "sklearn/sklearn.tree._export/_DOTTreeExporter/export": {},
  "sklearn/sklearn.tree._export/_DOTTreeExporter/tail": {},
  "sklearn/sklearn.tree._export/_DOTTreeExporter/head": {},
  "sklearn/sklearn.tree._export/_DOTTreeExporter/recurse": {},
  "sklearn/sklearn.tree._export/_MPLTreeExporter/__init__": {},
  "sklearn/sklearn.tree._export/_MPLTreeExporter/_make_tree": {},
  "sklearn/sklearn.tree._export/_MPLTreeExporter/export": {},
  "sklearn/sklearn.tree._export/_MPLTreeExporter/recurse": {},
  "sklearn/sklearn.tree._export/export_graphviz": {},
  "sklearn/sklearn.tree._export/_compute_depth": {},
  "sklearn/sklearn.tree._export/export_text": {},
  "sklearn/sklearn.tree._reingold_tilford/DrawTree/__init__": {},
  "sklearn/sklearn.tree._reingold_tilford/DrawTree/left": {},
  "sklearn/sklearn.tree._reingold_tilford/DrawTree/right": {},
  "sklearn/sklearn.tree._reingold_tilford/DrawTree/lbrother": {},
  "sklearn/sklearn.tree._reingold_tilford/DrawTree/get_lmost_sibling": {},
  "sklearn/sklearn.tree._reingold_tilford/DrawTree/__str__": {},
  "sklearn/sklearn.tree._reingold_tilford/DrawTree/__repr__": {},
  "sklearn/sklearn.tree._reingold_tilford/DrawTree/max_extents": {},
  "sklearn/sklearn.tree._reingold_tilford/buchheim": {},
  "sklearn/sklearn.tree._reingold_tilford/third_walk": {},
  "sklearn/sklearn.tree._reingold_tilford/first_walk": {},
  "sklearn/sklearn.tree._reingold_tilford/apportion": {},
  "sklearn/sklearn.tree._reingold_tilford/move_subtree": {},
  "sklearn/sklearn.tree._reingold_tilford/execute_shifts": {},
  "sklearn/sklearn.tree._reingold_tilford/ancestor": {},
  "sklearn/sklearn.tree._reingold_tilford/second_walk": {},
  "sklearn/sklearn.tree._reingold_tilford/Tree/__init__": {},
  "sklearn/sklearn.utils.class_weight/compute_class_weight": {},
  "sklearn/sklearn.utils.class_weight/compute_sample_weight": {},
  "sklearn/sklearn.utils.deprecation/deprecated/__init__": {},
  "sklearn/sklearn.utils.deprecation/deprecated/__call__": {},
  "sklearn/sklearn.utils.deprecation/deprecated/_decorate_class": {},
  "sklearn/sklearn.utils.deprecation/deprecated/_decorate_fun": {},
  "sklearn/sklearn.utils.deprecation/deprecated/_decorate_property": {},
  "sklearn/sklearn.utils.deprecation/_is_deprecated": {},
  "sklearn/sklearn.utils.discovery/all_estimators": {},
  "sklearn/sklearn.utils.discovery/all_displays": {},
  "sklearn/sklearn.utils.discovery/_is_checked_function": {},
  "sklearn/sklearn.utils.discovery/all_functions": {},
  "sklearn/sklearn.utils.estimator_checks/_yield_checks": {},
  "sklearn/sklearn.utils.estimator_checks/_yield_classifier_checks": {},
  "sklearn/sklearn.utils.estimator_checks/check_supervised_y_no_nan": {},
  "sklearn/sklearn.utils.estimator_checks/_yield_regressor_checks": {},
  "sklearn/sklearn.utils.estimator_checks/_yield_transformer_checks": {},
  "sklearn/sklearn.utils.estimator_checks/_yield_clustering_checks": {},
  "sklearn/sklearn.utils.estimator_checks/_yield_outliers_checks": {},
  "sklearn/sklearn.utils.estimator_checks/_yield_all_checks": {},
  "sklearn/sklearn.utils.estimator_checks/_get_check_estimator_ids": {},
  "sklearn/sklearn.utils.estimator_checks/_construct_instance": {},
  "sklearn/sklearn.utils.estimator_checks/_maybe_mark_xfail": {},
  "sklearn/sklearn.utils.estimator_checks/_maybe_skip": {},
  "sklearn/sklearn.utils.estimator_checks/_should_be_skipped_or_marked": {},
  "sklearn/sklearn.utils.estimator_checks/parametrize_with_checks": {},
  "sklearn/sklearn.utils.estimator_checks/check_estimator": {},
  "sklearn/sklearn.utils.estimator_checks/_regression_dataset": {},
  "sklearn/sklearn.utils.estimator_checks/_set_checking_parameters": {},
  "sklearn/sklearn.utils.estimator_checks/_NotAnArray/__init__": {},
  "sklearn/sklearn.utils.estimator_checks/_NotAnArray/__array__": {},
  "sklearn/sklearn.utils.estimator_checks/_NotAnArray/__array_function__": {},
  "sklearn/sklearn.utils.estimator_checks/_is_pairwise_metric": {},
  "sklearn/sklearn.utils.estimator_checks/_generate_sparse_matrix": {},
  "sklearn/sklearn.utils.estimator_checks/check_estimator_sparse_data": {},
  "sklearn/sklearn.utils.estimator_checks/check_sample_weights_pandas_series": {},
  "sklearn/sklearn.utils.estimator_checks/check_sample_weights_not_an_array": {},
  "sklearn/sklearn.utils.estimator_checks/check_sample_weights_list": {},
  "sklearn/sklearn.utils.estimator_checks/check_sample_weights_shape": {},
  "sklearn/sklearn.utils.estimator_checks/check_sample_weights_invariance": {},
  "sklearn/sklearn.utils.estimator_checks/check_sample_weights_not_overwritten": {},
  "sklearn/sklearn.utils.estimator_checks/check_dtype_object": {},
  "sklearn/sklearn.utils.estimator_checks/check_complex_data": {},
  "sklearn/sklearn.utils.estimator_checks/check_dict_unchanged": {},
  "sklearn/sklearn.utils.estimator_checks/_is_public_parameter": {},
  "sklearn/sklearn.utils.estimator_checks/check_dont_overwrite_parameters": {},
  "sklearn/sklearn.utils.estimator_checks/check_fit2d_predict1d": {},
  "sklearn/sklearn.utils.estimator_checks/_apply_on_subsets": {},
  "sklearn/sklearn.utils.estimator_checks/check_methods_subset_invariance": {},
  "sklearn/sklearn.utils.estimator_checks/check_methods_sample_order_invariance": {},
  "sklearn/sklearn.utils.estimator_checks/check_fit2d_1sample": {},
  "sklearn/sklearn.utils.estimator_checks/check_fit2d_1feature": {},
  "sklearn/sklearn.utils.estimator_checks/check_fit1d": {},
  "sklearn/sklearn.utils.estimator_checks/check_transformer_general": {},
  "sklearn/sklearn.utils.estimator_checks/check_transformer_data_not_an_array": {},
  "sklearn/sklearn.utils.estimator_checks/check_transformers_unfitted": {},
  "sklearn/sklearn.utils.estimator_checks/_check_transformer": {},
  "sklearn/sklearn.utils.estimator_checks/check_pipeline_consistency": {},
  "sklearn/sklearn.utils.estimator_checks/check_fit_score_takes_y": {},
  "sklearn/sklearn.utils.estimator_checks/check_estimators_dtypes": {},
  "sklearn/sklearn.utils.estimator_checks/check_transformer_preserve_dtypes": {},
  "sklearn/sklearn.utils.estimator_checks/check_estimators_empty_data_messages": {},
  "sklearn/sklearn.utils.estimator_checks/check_estimators_nan_inf": {},
  "sklearn/sklearn.utils.estimator_checks/check_nonsquare_error": {},
  "sklearn/sklearn.utils.estimator_checks/check_estimators_pickle": {},
  "sklearn/sklearn.utils.estimator_checks/check_estimators_partial_fit_n_features": {},
  "sklearn/sklearn.utils.estimator_checks/check_classifier_multioutput": {},
  "sklearn/sklearn.utils.estimator_checks/check_regressor_multioutput": {},
  "sklearn/sklearn.utils.estimator_checks/check_clustering": {},
  "sklearn/sklearn.utils.estimator_checks/check_clusterer_compute_labels_predict": {},
  "sklearn/sklearn.utils.estimator_checks/check_classifiers_one_label": {},
  "sklearn/sklearn.utils.estimator_checks/check_classifiers_one_label_sample_weights": {},
  "sklearn/sklearn.utils.estimator_checks/check_classifiers_train": {},
  "sklearn/sklearn.utils.estimator_checks/check_outlier_corruption": {},
  "sklearn/sklearn.utils.estimator_checks/check_outliers_train": {},
  "sklearn/sklearn.utils.estimator_checks/check_outlier_contamination": {},
  "sklearn/sklearn.utils.estimator_checks/check_classifiers_multilabel_representation_invariance": {},
  "sklearn/sklearn.utils.estimator_checks/check_classifiers_multilabel_output_format_predict": {},
  "sklearn/sklearn.utils.estimator_checks/check_classifiers_multilabel_output_format_predict_proba": {},
  "sklearn/sklearn.utils.estimator_checks/check_classifiers_multilabel_output_format_decision_function": {},
  "sklearn/sklearn.utils.estimator_checks/check_get_feature_names_out_error": {},
  "sklearn/sklearn.utils.estimator_checks/check_estimators_fit_returns_self": {},
  "sklearn/sklearn.utils.estimator_checks/check_estimators_unfitted": {},
  "sklearn/sklearn.utils.estimator_checks/check_supervised_y_2d": {},
  "sklearn/sklearn.utils.estimator_checks/check_classifiers_predictions": {},
  "sklearn/sklearn.utils.estimator_checks/_choose_check_classifiers_labels": {},
  "sklearn/sklearn.utils.estimator_checks/check_classifiers_classes": {},
  "sklearn/sklearn.utils.estimator_checks/check_regressors_int": {},
  "sklearn/sklearn.utils.estimator_checks/check_regressors_train": {},
  "sklearn/sklearn.utils.estimator_checks/check_regressors_no_decision_function": {},
  "sklearn/sklearn.utils.estimator_checks/check_class_weight_classifiers": {},
  "sklearn/sklearn.utils.estimator_checks/check_class_weight_balanced_classifiers": {},
  "sklearn/sklearn.utils.estimator_checks/check_class_weight_balanced_linear_classifier": {},
  "sklearn/sklearn.utils.estimator_checks/check_estimators_overwrite_params": {},
  "sklearn/sklearn.utils.estimator_checks/check_no_attributes_set_in_init": {},
  "sklearn/sklearn.utils.estimator_checks/check_sparsify_coefficients": {},
  "sklearn/sklearn.utils.estimator_checks/check_classifier_data_not_an_array": {},
  "sklearn/sklearn.utils.estimator_checks/check_regressor_data_not_an_array": {},
  "sklearn/sklearn.utils.estimator_checks/check_estimators_data_not_an_array": {},
  "sklearn/sklearn.utils.estimator_checks/check_parameters_default_constructible": {},
  "sklearn/sklearn.utils.estimator_checks/_enforce_estimator_tags_y": {},
  "sklearn/sklearn.utils.estimator_checks/_enforce_estimator_tags_X": {},
  "sklearn/sklearn.utils.estimator_checks/check_non_transformer_estimators_n_iter": {},
  "sklearn/sklearn.utils.estimator_checks/check_transformer_n_iter": {},
  "sklearn/sklearn.utils.estimator_checks/check_get_params_invariance": {},
  "sklearn/sklearn.utils.estimator_checks/check_set_params": {},
  "sklearn/sklearn.utils.estimator_checks/check_classifiers_regression_target": {},
  "sklearn/sklearn.utils.estimator_checks/check_decision_proba_consistency": {},
  "sklearn/sklearn.utils.estimator_checks/check_outliers_fit_predict": {},
  "sklearn/sklearn.utils.estimator_checks/check_fit_non_negative": {},
  "sklearn/sklearn.utils.estimator_checks/check_fit_idempotent": {},
  "sklearn/sklearn.utils.estimator_checks/check_fit_check_is_fitted": {},
  "sklearn/sklearn.utils.estimator_checks/check_n_features_in": {},
  "sklearn/sklearn.utils.estimator_checks/check_requires_y_none": {},
  "sklearn/sklearn.utils.estimator_checks/check_n_features_in_after_fitting": {},
  "sklearn/sklearn.utils.estimator_checks/check_estimator_get_tags_default_keys": {},
  "sklearn/sklearn.utils.estimator_checks/check_dataframe_column_names_consistency": {},
  "sklearn/sklearn.utils.estimator_checks/check_transformer_get_feature_names_out": {},
  "sklearn/sklearn.utils.estimator_checks/check_transformer_get_feature_names_out_pandas": {},
  "sklearn/sklearn.utils.estimator_checks/check_param_validation": {},
  "sklearn/sklearn.utils.estimator_checks/check_set_output_transform": {},
  "sklearn/sklearn.utils.estimator_checks/_output_from_fit_transform": {},
  "sklearn/sklearn.utils.estimator_checks/_check_generated_dataframe": {},
  "sklearn/sklearn.utils.estimator_checks/check_set_output_transform_pandas": {},
  "sklearn/sklearn.utils.estimator_checks/check_global_ouptut_transform_pandas": {},
  "sklearn/sklearn.utils.extmath/squared_norm": {},
  "sklearn/sklearn.utils.extmath/row_norms": {},
  "sklearn/sklearn.utils.extmath/fast_logdet": {},
  "sklearn/sklearn.utils.extmath/density": {},
  "sklearn/sklearn.utils.extmath/safe_sparse_dot": {},
  "sklearn/sklearn.utils.extmath/randomized_range_finder": {},
  "sklearn/sklearn.utils.extmath/randomized_svd": {
    "n_iter": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.utils.extmath/randomized_svd/n_iter",
          "name": "n_iter",
          "qname": "sklearn.utils.extmath.randomized_svd.n_iter",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int or 'auto'",
            "default_value": "'auto'",
            "description": "Number of power iterations. It can be used to deal with very noisy\nproblems. When 'auto', it is set to 4, unless `n_components` is small\n(< .1 * min(X.shape)) in which case `n_iter` is set to 7.\nThis improves precision with few components. Note that in general\nusers should rather increase `n_oversamples` before increasing `n_iter`\nas the principle of the randomized method is to avoid usage of these\nmore costly power iterations steps. When `n_components` is equal\nor greater to the effective matrix rank and the spectrum does not\npresent a slow decay, `n_iter=0` or `1` should even work fine in theory\n(see [1]_ page 9).\n\n.. versionchanged:: 0.18"
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "'auto'"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.utils.extmath/randomized_svd/n_components",
          "name": "n_components",
          "qname": "sklearn.utils.extmath.randomized_svd.n_components",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "",
            "description": "Number of singular values and vectors to extract."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "hasCondition": {
          "condition": "unless n_components is small ( < .1 * min(X.shape )"
        },
        "hasAction": {
          "action": "When auto , it is set to 4 , )"
        }
      }
    ],
    "flip_sign": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.utils.extmath/randomized_svd/flip_sign",
          "name": "flip_sign",
          "qname": "sklearn.utils.extmath.randomized_svd.flip_sign",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "The output of a singular value decomposition is only unique up to a\npermutation of the signs of the singular vectors. If `flip_sign` is\nset to `True`, the sign ambiguity is resolved by making the largest\nloadings for each component in the left singular vectors positive."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.utils.extmath/randomized_svd/flip_sign",
          "name": "flip_sign",
          "qname": "sklearn.utils.extmath.randomized_svd.flip_sign",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "The output of a singular value decomposition is only unique up to a\npermutation of the signs of the singular vectors. If `flip_sign` is\nset to `True`, the sign ambiguity is resolved by making the largest\nloadings for each component in the left singular vectors positive."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "If flip_sign is set to True"
        },
        "hasAction": {
          "action": ", the sign ambiguity is resolved by making the largest loadings for each component in the left singular vectors positive"
        }
      }
    ]
  },
  "sklearn/sklearn.utils.extmath/_randomized_eigsh": {
    "n_iter": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.utils.extmath/_randomized_eigsh/n_iter",
          "name": "n_iter",
          "qname": "sklearn.utils.extmath._randomized_eigsh.n_iter",
          "default_value": "'auto'",
          "assigned_by": "NAME_ONLY",
          "is_public": false,
          "docstring": {
            "type": "int or 'auto'",
            "default_value": "'auto'",
            "description": "Number of power iterations. It can be used to deal with very noisy\nproblems. When 'auto', it is set to 4, unless `n_components` is small\n(< .1 * min(X.shape)) in which case `n_iter` is set to 7.\nThis improves precision with few components. Note that in general\nusers should rather increase `n_oversamples` before increasing `n_iter`\nas the principle of the randomized method is to avoid usage of these\nmore costly power iterations steps. When `n_components` is equal\nor greater to the effective matrix rank and the spectrum does not\npresent a slow decay, `n_iter=0` or `1` should even work fine in theory\n(see Halko et al paper, page 9)."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "'auto'"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.utils.extmath/_randomized_eigsh/n_components",
          "name": "n_components",
          "qname": "sklearn.utils.extmath._randomized_eigsh.n_components",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "int",
            "default_value": "",
            "description": "Number of eigenvalues and vectors to extract."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "hasCondition": {
          "condition": "unless n_components is small ( < .1 * min(X.shape )"
        },
        "hasAction": {
          "action": "When auto , it is set to 4 , )"
        }
      }
    ],
    "selection": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.utils.extmath/_randomized_eigsh/selection",
          "name": "selection",
          "qname": "sklearn.utils.extmath._randomized_eigsh.selection",
          "default_value": "'module'",
          "assigned_by": "NAME_ONLY",
          "is_public": false,
          "docstring": {
            "type": "{'value', 'module'}",
            "default_value": "'module'",
            "description": "Strategy used to select the n components. When `selection` is `'value'`\n(not yet implemented, will become the default when implemented), the\ncomponents corresponding to the n largest eigenvalues are returned.\nWhen `selection` is `'module'`, the components corresponding to the n\neigenvalues with largest modules are returned."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "value",
              "module"
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.utils.extmath/_randomized_eigsh/selection",
          "name": "selection",
          "qname": "sklearn.utils.extmath._randomized_eigsh.selection",
          "default_value": "'module'",
          "assigned_by": "NAME_ONLY",
          "is_public": false,
          "docstring": {
            "type": "{'value', 'module'}",
            "default_value": "'module'",
            "description": "Strategy used to select the n components. When `selection` is `'value'`\n(not yet implemented, will become the default when implemented), the\ncomponents corresponding to the n largest eigenvalues are returned.\nWhen `selection` is `'module'`, the components corresponding to the n\neigenvalues with largest modules are returned."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "value",
              "module"
            ]
          }
        },
        "hasCondition": {
          "condition": "When selection is value ( not yet implemented ,"
        },
        "hasAction": {
          "action": "will become the default when implemented )"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.utils.extmath/_randomized_eigsh/selection",
          "name": "selection",
          "qname": "sklearn.utils.extmath._randomized_eigsh.selection",
          "default_value": "'module'",
          "assigned_by": "NAME_ONLY",
          "is_public": false,
          "docstring": {
            "type": "{'value', 'module'}",
            "default_value": "'module'",
            "description": "Strategy used to select the n components. When `selection` is `'value'`\n(not yet implemented, will become the default when implemented), the\ncomponents corresponding to the n largest eigenvalues are returned.\nWhen `selection` is `'module'`, the components corresponding to the n\neigenvalues with largest modules are returned."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "value",
              "module"
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.utils.extmath/_randomized_eigsh/selection",
          "name": "selection",
          "qname": "sklearn.utils.extmath._randomized_eigsh.selection",
          "default_value": "'module'",
          "assigned_by": "NAME_ONLY",
          "is_public": false,
          "docstring": {
            "type": "{'value', 'module'}",
            "default_value": "'module'",
            "description": "Strategy used to select the n components. When `selection` is `'value'`\n(not yet implemented, will become the default when implemented), the\ncomponents corresponding to the n largest eigenvalues are returned.\nWhen `selection` is `'module'`, the components corresponding to the n\neigenvalues with largest modules are returned."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "value",
              "module"
            ]
          }
        },
        "hasCondition": {
          "condition": "When selection is module ,"
        },
        "hasAction": {
          "action": "the components corresponding to the n eigenvalues with largest modules are returned"
        }
      }
    ]
  },
  "sklearn/sklearn.utils.extmath/weighted_mode": {},
  "sklearn/sklearn.utils.extmath/cartesian": {},
  "sklearn/sklearn.utils.extmath/svd_flip": {},
  "sklearn/sklearn.utils.extmath/log_logistic": {},
  "sklearn/sklearn.utils.extmath/softmax": {},
  "sklearn/sklearn.utils.extmath/make_nonnegative": {},
  "sklearn/sklearn.utils.extmath/_safe_accumulator_op": {},
  "sklearn/sklearn.utils.extmath/_incremental_mean_and_var": {
    "last_sample_count": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.utils.extmath/_incremental_mean_and_var/last_sample_count",
          "name": "last_sample_count",
          "qname": "sklearn.utils.extmath._incremental_mean_and_var.last_sample_count",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "array-like of shape (n_features,)",
            "default_value": "",
            "description": "The number of samples encountered until now if sample_weight is None.\nIf sample_weight is not None, this is the sum of sample_weight\nencountered."
          },
          "type": {
            "kind": "NamedType",
            "name": "array-like of shape (n_features,)"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.utils.extmath/_incremental_mean_and_var/sample_weight",
          "name": "sample_weight",
          "qname": "sklearn.utils.extmath._incremental_mean_and_var.sample_weight",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "array-like of shape (n_samples,) or None",
            "default_value": "",
            "description": "Sample weights. If None, compute the unweighted mean/variance."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of shape (n_samples,)"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "if sample_weight is None"
        },
        "hasAction": {
          "action": "encountered until now"
        }
      }
    ]
  },
  "sklearn/sklearn.utils.extmath/_deterministic_vector_sign_flip": {},
  "sklearn/sklearn.utils.extmath/stable_cumsum": {},
  "sklearn/sklearn.utils.fixes/_object_dtype_isnan": {},
  "sklearn/sklearn.utils.fixes/_eigh": {},
  "sklearn/sklearn.utils.fixes/_percentile": {},
  "sklearn/sklearn.utils.fixes/_get_threadpool_controller": {},
  "sklearn/sklearn.utils.fixes/threadpool_limits": {},
  "sklearn/sklearn.utils.fixes/threadpool_info": {},
  "sklearn/sklearn.utils.fixes/delayed": {},
  "sklearn/sklearn.utils.fixes/_mode": {},
  "sklearn/sklearn.utils.fixes/_open_text": {},
  "sklearn/sklearn.utils.fixes/_open_binary": {},
  "sklearn/sklearn.utils.fixes/_read_text": {},
  "sklearn/sklearn.utils.fixes/_path": {},
  "sklearn/sklearn.utils.fixes/_is_resource": {},
  "sklearn/sklearn.utils.graph/single_source_shortest_path_length": {},
  "sklearn/sklearn.utils.graph/_fix_connected_components": {},
  "sklearn/sklearn.utils.metaestimators/_BaseComposition/__init__": {},
  "sklearn/sklearn.utils.metaestimators/_BaseComposition/_get_params": {},
  "sklearn/sklearn.utils.metaestimators/_BaseComposition/_set_params": {},
  "sklearn/sklearn.utils.metaestimators/_BaseComposition/_replace_estimator": {},
  "sklearn/sklearn.utils.metaestimators/_BaseComposition/_validate_names": {},
  "sklearn/sklearn.utils.metaestimators/_IffHasAttrDescriptor/__init__": {},
  "sklearn/sklearn.utils.metaestimators/_IffHasAttrDescriptor/_check": {},
  "sklearn/sklearn.utils.metaestimators/if_delegate_has_method": {},
  "sklearn/sklearn.utils.metaestimators/_safe_split": {},
  "sklearn/sklearn.utils.multiclass/_unique_multiclass": {},
  "sklearn/sklearn.utils.multiclass/_unique_indicator": {},
  "sklearn/sklearn.utils.multiclass/unique_labels": {},
  "sklearn/sklearn.utils.multiclass/_is_integral_float": {},
  "sklearn/sklearn.utils.multiclass/is_multilabel": {},
  "sklearn/sklearn.utils.multiclass/check_classification_targets": {},
  "sklearn/sklearn.utils.multiclass/type_of_target": {},
  "sklearn/sklearn.utils.multiclass/_check_partial_fit_first_call": {},
  "sklearn/sklearn.utils.multiclass/class_distribution": {},
  "sklearn/sklearn.utils.multiclass/_ovr_decision_function": {},
  "sklearn/sklearn.utils.optimize/_line_search_wolfe12": {},
  "sklearn/sklearn.utils.optimize/_cg": {},
  "sklearn/sklearn.utils.optimize/_newton_cg": {},
  "sklearn/sklearn.utils.optimize/_check_optimize_result": {},
  "sklearn/sklearn.utils.parallel/_with_config": {},
  "sklearn/sklearn.utils.parallel/Parallel/__call__": {},
  "sklearn/sklearn.utils.parallel/delayed": {},
  "sklearn/sklearn.utils.parallel/_FuncWrapper/__init__": {},
  "sklearn/sklearn.utils.parallel/_FuncWrapper/with_config": {},
  "sklearn/sklearn.utils.parallel/_FuncWrapper/__call__": {},
  "sklearn/sklearn.utils.random/_random_choice_csc": {},
  "sklearn/sklearn.utils.sparsefuncs/_raise_typeerror": {},
  "sklearn/sklearn.utils.sparsefuncs/_raise_error_wrong_axis": {},
  "sklearn/sklearn.utils.sparsefuncs/inplace_csr_column_scale": {},
  "sklearn/sklearn.utils.sparsefuncs/inplace_csr_row_scale": {},
  "sklearn/sklearn.utils.sparsefuncs/mean_variance_axis": {
    "return_sum_weights": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.utils.sparsefuncs/mean_variance_axis/return_sum_weights",
          "name": "return_sum_weights",
          "qname": "sklearn.utils.sparsefuncs.mean_variance_axis.return_sum_weights",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "If True, returns the sum of weights seen for each feature\nif `axis=0` or each sample if `axis=1`.\n\n.. versionadded:: 0.24"
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.utils.sparsefuncs/mean_variance_axis/axis",
          "name": "axis",
          "qname": "sklearn.utils.sparsefuncs.mean_variance_axis.axis",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "{0, 1}",
            "default_value": "",
            "description": "Axis along which the axis should be computed."
          },
          "type": {
            "kind": "EnumType",
            "values": []
          }
        },
        "hasCondition": {
          "condition": "if axis equals 0 or each sample if axis equals 1"
        },
        "hasAction": {
          "action": "If True , returns the sum of weights seen for each feature . .."
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.utils.sparsefuncs/mean_variance_axis/return_sum_weights",
          "name": "return_sum_weights",
          "qname": "sklearn.utils.sparsefuncs.mean_variance_axis.return_sum_weights",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "If True, returns the sum of weights seen for each feature\nif `axis=0` or each sample if `axis=1`.\n\n.. versionadded:: 0.24"
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.utils.sparsefuncs/mean_variance_axis/axis",
          "name": "axis",
          "qname": "sklearn.utils.sparsefuncs.mean_variance_axis.axis",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "{0, 1}",
            "default_value": "",
            "description": "Axis along which the axis should be computed."
          },
          "type": {
            "kind": "EnumType",
            "values": []
          }
        },
        "hasCondition": {
          "condition": "if axis equals 1"
        },
        "hasAction": {
          "action": "if axis equals 0 or each sample"
        }
      }
    ]
  },
  "sklearn/sklearn.utils.sparsefuncs/incr_mean_variance_axis": {
    "last_mean": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.utils.sparsefuncs/incr_mean_variance_axis/last_mean",
          "name": "last_mean",
          "qname": "sklearn.utils.sparsefuncs.incr_mean_variance_axis.last_mean",
          "default_value": null,
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "ndarray of shape (n_features,) or (n_samples,), dtype=floating",
            "default_value": "",
            "description": "Array of means to update with the new data X.\nShould be of shape (n_features,) if axis=0 or (n_samples,) if axis=1."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "ndarray of shape (n_features,) or (n_samples,)"
              },
              {
                "kind": "NamedType",
                "name": "dtype=floating"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.utils.sparsefuncs/incr_mean_variance_axis/axis",
          "name": "axis",
          "qname": "sklearn.utils.sparsefuncs.incr_mean_variance_axis.axis",
          "default_value": null,
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{0, 1}",
            "default_value": "",
            "description": "Axis along which the axis should be computed."
          },
          "type": {
            "kind": "EnumType",
            "values": []
          }
        },
        "hasCondition": {
          "condition": "if axis equals 1"
        },
        "hasAction": {
          "action": "if axis equals 0 or ( n_samples , )"
        }
      }
    ],
    "last_var": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.utils.sparsefuncs/incr_mean_variance_axis/last_var",
          "name": "last_var",
          "qname": "sklearn.utils.sparsefuncs.incr_mean_variance_axis.last_var",
          "default_value": null,
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "ndarray of shape (n_features,) or (n_samples,), dtype=floating",
            "default_value": "",
            "description": "Array of variances to update with the new data X.\nShould be of shape (n_features,) if axis=0 or (n_samples,) if axis=1."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "ndarray of shape (n_features,) or (n_samples,)"
              },
              {
                "kind": "NamedType",
                "name": "dtype=floating"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.utils.sparsefuncs/incr_mean_variance_axis/axis",
          "name": "axis",
          "qname": "sklearn.utils.sparsefuncs.incr_mean_variance_axis.axis",
          "default_value": null,
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{0, 1}",
            "default_value": "",
            "description": "Axis along which the axis should be computed."
          },
          "type": {
            "kind": "EnumType",
            "values": []
          }
        },
        "hasCondition": {
          "condition": "if axis equals 1"
        },
        "hasAction": {
          "action": "if axis equals 0 or ( n_samples , )"
        }
      }
    ],
    "last_n": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.utils.sparsefuncs/incr_mean_variance_axis/last_n",
          "name": "last_n",
          "qname": "sklearn.utils.sparsefuncs.incr_mean_variance_axis.last_n",
          "default_value": null,
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float or ndarray of shape (n_features,) or (n_samples,),             dtype=floating",
            "default_value": "",
            "description": "Sum of the weights seen so far, excluding the current weights\nIf not float, it should be of shape (n_features,) if\naxis=0 or (n_samples,) if axis=1. If float it corresponds to\nhaving same weights for all samples (or features)."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "float"
              },
              {
                "kind": "NamedType",
                "name": "ndarray of shape (n_features,) or (n_samples,)"
              },
              {
                "kind": "NamedType",
                "name": "dtype=floating"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.utils.sparsefuncs/incr_mean_variance_axis/axis",
          "name": "axis",
          "qname": "sklearn.utils.sparsefuncs.incr_mean_variance_axis.axis",
          "default_value": null,
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{0, 1}",
            "default_value": "",
            "description": "Axis along which the axis should be computed."
          },
          "type": {
            "kind": "EnumType",
            "values": []
          }
        },
        "hasCondition": {
          "condition": "if axis equals 1"
        },
        "hasAction": {
          "action": "if axis equals 0 or ( n_samples , )"
        }
      }
    ]
  },
  "sklearn/sklearn.utils.sparsefuncs/inplace_column_scale": {},
  "sklearn/sklearn.utils.sparsefuncs/inplace_row_scale": {},
  "sklearn/sklearn.utils.sparsefuncs/inplace_swap_row_csc": {},
  "sklearn/sklearn.utils.sparsefuncs/inplace_swap_row_csr": {},
  "sklearn/sklearn.utils.sparsefuncs/inplace_swap_row": {},
  "sklearn/sklearn.utils.sparsefuncs/inplace_swap_column": {},
  "sklearn/sklearn.utils.sparsefuncs/_minor_reduce": {},
  "sklearn/sklearn.utils.sparsefuncs/_min_or_max_axis": {},
  "sklearn/sklearn.utils.sparsefuncs/_sparse_min_or_max": {},
  "sklearn/sklearn.utils.sparsefuncs/_sparse_min_max": {},
  "sklearn/sklearn.utils.sparsefuncs/_sparse_nan_min_max": {},
  "sklearn/sklearn.utils.sparsefuncs/min_max_axis": {},
  "sklearn/sklearn.utils.sparsefuncs/count_nonzero": {},
  "sklearn/sklearn.utils.sparsefuncs/_get_median": {},
  "sklearn/sklearn.utils.sparsefuncs/_get_elem_at_rank": {},
  "sklearn/sklearn.utils.sparsefuncs/csc_median_axis_0": {},
  "sklearn/sklearn.utils.stats/_weighted_percentile": {},
  "sklearn/sklearn.utils.validation/_deprecate_positional_args": {},
  "sklearn/sklearn.utils.validation/_assert_all_finite": {},
  "sklearn/sklearn.utils.validation/assert_all_finite": {
    "allow_nan": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.utils.validation/assert_all_finite/allow_nan",
          "name": "allow_nan",
          "qname": "sklearn.utils.validation.assert_all_finite.allow_nan",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "If True, do not throw error when `X` contains NaN."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.utils.validation/assert_all_finite/X",
          "name": "X",
          "qname": "sklearn.utils.validation.assert_all_finite.X",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "{ndarray, sparse matrix}",
            "default_value": "",
            "description": "The input data."
          },
          "type": {
            "kind": "EnumType",
            "values": []
          }
        },
        "hasCondition": {
          "condition": "when X contains NaN."
        },
        "hasAction": {
          "action": "If True , do not throw error"
        }
      }
    ],
    "input_name": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.utils.validation/assert_all_finite/input_name",
          "name": "input_name",
          "qname": "sklearn.utils.validation.assert_all_finite.input_name",
          "default_value": "''",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "\"\"",
            "description": "The data name used to construct the error message. In particular\nif `input_name` is \"X\" and the data has NaN values and\nallow_nan is False, the error message will link to the imputer\ndocumentation."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.utils.validation/assert_all_finite/input_name",
          "name": "input_name",
          "qname": "sklearn.utils.validation.assert_all_finite.input_name",
          "default_value": "''",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "\"\"",
            "description": "The data name used to construct the error message. In particular\nif `input_name` is \"X\" and the data has NaN values and\nallow_nan is False, the error message will link to the imputer\ndocumentation."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        "hasCondition": {
          "condition": "In particular if input_name is X and the data has NaN values and allow_nan is False"
        },
        "hasAction": {
          "action": ", the error message will link to the imputer documentation"
        }
      }
    ]
  },
  "sklearn/sklearn.utils.validation/as_float_array": {},
  "sklearn/sklearn.utils.validation/_is_arraylike": {},
  "sklearn/sklearn.utils.validation/_is_arraylike_not_scalar": {},
  "sklearn/sklearn.utils.validation/_num_features": {},
  "sklearn/sklearn.utils.validation/_num_samples": {},
  "sklearn/sklearn.utils.validation/check_memory": {},
  "sklearn/sklearn.utils.validation/check_consistent_length": {},
  "sklearn/sklearn.utils.validation/_make_indexable": {},
  "sklearn/sklearn.utils.validation/indexable": {},
  "sklearn/sklearn.utils.validation/_ensure_sparse_format": {
    "copy": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.utils.validation/_ensure_sparse_format/copy",
          "name": "copy",
          "qname": "sklearn.utils.validation._ensure_sparse_format.copy",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "bool",
            "default_value": "",
            "description": "Whether a forced copy will be triggered. If copy=False, a copy might\nbe triggered by a conversion."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.utils.validation/_ensure_sparse_format/copy",
          "name": "copy",
          "qname": "sklearn.utils.validation._ensure_sparse_format.copy",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "bool",
            "default_value": "",
            "description": "Whether a forced copy will be triggered. If copy=False, a copy might\nbe triggered by a conversion."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "If copy equals False"
        },
        "hasAction": {
          "action": ", a copy might be triggered by a conversion"
        }
      }
    ],
    "input_name": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.utils.validation/_ensure_sparse_format/input_name",
          "name": "input_name",
          "qname": "sklearn.utils.validation._ensure_sparse_format.input_name",
          "default_value": "''",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "\"\"",
            "description": "The data name used to construct the error message. In particular\nif `input_name` is \"X\" and the data has NaN values and\nallow_nan is False, the error message will link to the imputer\ndocumentation."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.utils.validation/_ensure_sparse_format/input_name",
          "name": "input_name",
          "qname": "sklearn.utils.validation._ensure_sparse_format.input_name",
          "default_value": "''",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "\"\"",
            "description": "The data name used to construct the error message. In particular\nif `input_name` is \"X\" and the data has NaN values and\nallow_nan is False, the error message will link to the imputer\ndocumentation."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        "hasCondition": {
          "condition": "In particular if input_name is X and the data has NaN values and allow_nan is False"
        },
        "hasAction": {
          "action": ", the error message will link to the imputer documentation"
        }
      }
    ]
  },
  "sklearn/sklearn.utils.validation/_ensure_no_complex_data": {},
  "sklearn/sklearn.utils.validation/_check_estimator_name": {},
  "sklearn/sklearn.utils.validation/_pandas_dtype_needs_early_conversion": {},
  "sklearn/sklearn.utils.validation/check_array": {
    "dtype": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.utils.validation/check_array/dtype",
          "name": "dtype",
          "qname": "sklearn.utils.validation.check_array.dtype",
          "default_value": "'numeric'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "'numeric', type, list of type or None",
            "default_value": "'numeric'",
            "description": "Data type of result. If None, the dtype of the input is preserved.\nIf \"numeric\", dtype is preserved unless array.dtype is object.\nIf dtype is a list of types, conversion on the first type is only\nperformed if the dtype of the input is not in the list."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "'numeric'"
              },
              {
                "kind": "NamedType",
                "name": "type"
              },
              {
                "kind": "NamedType",
                "name": "list of type"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.utils.validation/check_array/dtype",
          "name": "dtype",
          "qname": "sklearn.utils.validation.check_array.dtype",
          "default_value": "'numeric'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "'numeric', type, list of type or None",
            "default_value": "'numeric'",
            "description": "Data type of result. If None, the dtype of the input is preserved.\nIf \"numeric\", dtype is preserved unless array.dtype is object.\nIf dtype is a list of types, conversion on the first type is only\nperformed if the dtype of the input is not in the list."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "'numeric'"
              },
              {
                "kind": "NamedType",
                "name": "type"
              },
              {
                "kind": "NamedType",
                "name": "list of type"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If dtype is a list of types , conversion on the first type"
        },
        "hasAction": {
          "action": "is only performed if the dtype of the input is not in the list"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.utils.validation/check_array/dtype",
          "name": "dtype",
          "qname": "sklearn.utils.validation.check_array.dtype",
          "default_value": "'numeric'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "'numeric', type, list of type or None",
            "default_value": "'numeric'",
            "description": "Data type of result. If None, the dtype of the input is preserved.\nIf \"numeric\", dtype is preserved unless array.dtype is object.\nIf dtype is a list of types, conversion on the first type is only\nperformed if the dtype of the input is not in the list."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "'numeric'"
              },
              {
                "kind": "NamedType",
                "name": "type"
              },
              {
                "kind": "NamedType",
                "name": "list of type"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.utils.validation/check_array/dtype",
          "name": "dtype",
          "qname": "sklearn.utils.validation.check_array.dtype",
          "default_value": "'numeric'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "'numeric', type, list of type or None",
            "default_value": "'numeric'",
            "description": "Data type of result. If None, the dtype of the input is preserved.\nIf \"numeric\", dtype is preserved unless array.dtype is object.\nIf dtype is a list of types, conversion on the first type is only\nperformed if the dtype of the input is not in the list."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "'numeric'"
              },
              {
                "kind": "NamedType",
                "name": "type"
              },
              {
                "kind": "NamedType",
                "name": "list of type"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "if the dtype of the input is not in the list"
        },
        "hasAction": {
          "action": "If dtype is a list of types , conversion on the first type is only performed"
        }
      }
    ],
    "order": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.utils.validation/check_array/order",
          "name": "order",
          "qname": "sklearn.utils.validation.check_array.order",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'F', 'C'} or None",
            "default_value": "None",
            "description": "Whether an array will be forced to be fortran or c-style.\nWhen order is None (default), then if copy=False, nothing is ensured\nabout the memory layout of the output array; otherwise (copy=True)\nthe memory layout of the returned array is kept as close as possible\nto the original array."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "EnumType",
                "values": [
                  "F",
                  "C"
                ]
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.utils.validation/check_array/order",
          "name": "order",
          "qname": "sklearn.utils.validation.check_array.order",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'F', 'C'} or None",
            "default_value": "None",
            "description": "Whether an array will be forced to be fortran or c-style.\nWhen order is None (default), then if copy=False, nothing is ensured\nabout the memory layout of the output array; otherwise (copy=True)\nthe memory layout of the returned array is kept as close as possible\nto the original array."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "EnumType",
                "values": [
                  "F",
                  "C"
                ]
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "When order is None ( default )"
        },
        "hasAction": {
          "action": ", then if copy equals False , nothing is ensured about the memory layout of the output array"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.utils.validation/check_array/order",
          "name": "order",
          "qname": "sklearn.utils.validation.check_array.order",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'F', 'C'} or None",
            "default_value": "None",
            "description": "Whether an array will be forced to be fortran or c-style.\nWhen order is None (default), then if copy=False, nothing is ensured\nabout the memory layout of the output array; otherwise (copy=True)\nthe memory layout of the returned array is kept as close as possible\nto the original array."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "EnumType",
                "values": [
                  "F",
                  "C"
                ]
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.utils.validation/check_array/copy",
          "name": "copy",
          "qname": "sklearn.utils.validation.check_array.copy",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "Whether a forced copy will be triggered. If copy=False, a copy might\nbe triggered by a conversion."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "if copy equals False"
        },
        "hasAction": {
          "action": "When order is None ( default ) , then , nothing is ensured about the memory layout of the output array"
        }
      }
    ],
    "copy": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.utils.validation/check_array/copy",
          "name": "copy",
          "qname": "sklearn.utils.validation.check_array.copy",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "Whether a forced copy will be triggered. If copy=False, a copy might\nbe triggered by a conversion."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.utils.validation/check_array/copy",
          "name": "copy",
          "qname": "sklearn.utils.validation.check_array.copy",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "Whether a forced copy will be triggered. If copy=False, a copy might\nbe triggered by a conversion."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "If copy equals False"
        },
        "hasAction": {
          "action": ", a copy might be triggered by a conversion"
        }
      }
    ],
    "ensure_2d": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.utils.validation/check_array/ensure_2d",
          "name": "ensure_2d",
          "qname": "sklearn.utils.validation.check_array.ensure_2d",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Whether to raise a value error if array is not 2D."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.utils.validation/check_array/array",
          "name": "array",
          "qname": "sklearn.utils.validation.check_array.array",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "object",
            "default_value": "",
            "description": "Input object to check / convert."
          },
          "type": {
            "kind": "NamedType",
            "name": "object"
          }
        },
        "hasCondition": {
          "condition": "if array is not 2D."
        },
        "hasAction": {
          "action": "Whether to raise a value error"
        }
      }
    ],
    "input_name": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.utils.validation/check_array/input_name",
          "name": "input_name",
          "qname": "sklearn.utils.validation.check_array.input_name",
          "default_value": "''",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "\"\"",
            "description": "The data name used to construct the error message. In particular\nif `input_name` is \"X\" and the data has NaN values and\nallow_nan is False, the error message will link to the imputer\ndocumentation.\n\n.. versionadded:: 1.1.0"
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.utils.validation/check_array/input_name",
          "name": "input_name",
          "qname": "sklearn.utils.validation.check_array.input_name",
          "default_value": "''",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "\"\"",
            "description": "The data name used to construct the error message. In particular\nif `input_name` is \"X\" and the data has NaN values and\nallow_nan is False, the error message will link to the imputer\ndocumentation.\n\n.. versionadded:: 1.1.0"
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        "hasCondition": {
          "condition": "In particular if input_name is X and the data has NaN values and allow_nan is False"
        },
        "hasAction": {
          "action": ", the error message will link to the imputer documentation"
        }
      }
    ]
  },
  "sklearn/sklearn.utils.validation/_check_large_sparse": {},
  "sklearn/sklearn.utils.validation/check_X_y": {
    "dtype": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.utils.validation/check_X_y/dtype",
          "name": "dtype",
          "qname": "sklearn.utils.validation.check_X_y.dtype",
          "default_value": "'numeric'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "'numeric', type, list of type or None",
            "default_value": "'numeric'",
            "description": "Data type of result. If None, the dtype of the input is preserved.\nIf \"numeric\", dtype is preserved unless array.dtype is object.\nIf dtype is a list of types, conversion on the first type is only\nperformed if the dtype of the input is not in the list."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "'numeric'"
              },
              {
                "kind": "NamedType",
                "name": "type"
              },
              {
                "kind": "NamedType",
                "name": "list of type"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.utils.validation/check_X_y/dtype",
          "name": "dtype",
          "qname": "sklearn.utils.validation.check_X_y.dtype",
          "default_value": "'numeric'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "'numeric', type, list of type or None",
            "default_value": "'numeric'",
            "description": "Data type of result. If None, the dtype of the input is preserved.\nIf \"numeric\", dtype is preserved unless array.dtype is object.\nIf dtype is a list of types, conversion on the first type is only\nperformed if the dtype of the input is not in the list."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "'numeric'"
              },
              {
                "kind": "NamedType",
                "name": "type"
              },
              {
                "kind": "NamedType",
                "name": "list of type"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If dtype is a list of types , conversion on the first type"
        },
        "hasAction": {
          "action": "is only performed if the dtype of the input is not in the list"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.utils.validation/check_X_y/dtype",
          "name": "dtype",
          "qname": "sklearn.utils.validation.check_X_y.dtype",
          "default_value": "'numeric'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "'numeric', type, list of type or None",
            "default_value": "'numeric'",
            "description": "Data type of result. If None, the dtype of the input is preserved.\nIf \"numeric\", dtype is preserved unless array.dtype is object.\nIf dtype is a list of types, conversion on the first type is only\nperformed if the dtype of the input is not in the list."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "'numeric'"
              },
              {
                "kind": "NamedType",
                "name": "type"
              },
              {
                "kind": "NamedType",
                "name": "list of type"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.utils.validation/check_X_y/dtype",
          "name": "dtype",
          "qname": "sklearn.utils.validation.check_X_y.dtype",
          "default_value": "'numeric'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "'numeric', type, list of type or None",
            "default_value": "'numeric'",
            "description": "Data type of result. If None, the dtype of the input is preserved.\nIf \"numeric\", dtype is preserved unless array.dtype is object.\nIf dtype is a list of types, conversion on the first type is only\nperformed if the dtype of the input is not in the list."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "'numeric'"
              },
              {
                "kind": "NamedType",
                "name": "type"
              },
              {
                "kind": "NamedType",
                "name": "list of type"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "if the dtype of the input is not in the list"
        },
        "hasAction": {
          "action": "If dtype is a list of types , conversion on the first type is only performed"
        }
      }
    ],
    "copy": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.utils.validation/check_X_y/copy",
          "name": "copy",
          "qname": "sklearn.utils.validation.check_X_y.copy",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "Whether a forced copy will be triggered. If copy=False, a copy might\nbe triggered by a conversion."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.utils.validation/check_X_y/copy",
          "name": "copy",
          "qname": "sklearn.utils.validation.check_X_y.copy",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "Whether a forced copy will be triggered. If copy=False, a copy might\nbe triggered by a conversion."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "If copy equals False"
        },
        "hasAction": {
          "action": ", a copy might be triggered by a conversion"
        }
      }
    ],
    "ensure_2d": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.utils.validation/check_X_y/ensure_2d",
          "name": "ensure_2d",
          "qname": "sklearn.utils.validation.check_X_y.ensure_2d",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Whether to raise a value error if X is not 2D."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.utils.validation/check_X_y/X",
          "name": "X",
          "qname": "sklearn.utils.validation.check_X_y.X",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "{ndarray, list, sparse matrix}",
            "default_value": "",
            "description": "Input data."
          },
          "type": {
            "kind": "EnumType",
            "values": []
          }
        },
        "hasCondition": {
          "condition": "if X is not 2D."
        },
        "hasAction": {
          "action": "Whether to raise a value error"
        }
      }
    ],
    "multi_output": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.utils.validation/check_X_y/multi_output",
          "name": "multi_output",
          "qname": "sklearn.utils.validation.check_X_y.multi_output",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "Whether to allow 2D y (array or sparse matrix). If false, y will be\nvalidated as a vector. y cannot have np.nan or np.inf values if\nmulti_output=True."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.utils.validation/check_X_y/multi_output",
          "name": "multi_output",
          "qname": "sklearn.utils.validation.check_X_y.multi_output",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "Whether to allow 2D y (array or sparse matrix). If false, y will be\nvalidated as a vector. y cannot have np.nan or np.inf values if\nmulti_output=True."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "hasCondition": {
          "condition": "if multi_output equals True"
        },
        "hasAction": {
          "action": "y can not have np.nan or np.inf values"
        }
      }
    ],
    "ensure_min_features": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.utils.validation/check_X_y/ensure_min_features",
          "name": "ensure_min_features",
          "qname": "sklearn.utils.validation.check_X_y.ensure_min_features",
          "default_value": "1",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "1",
            "description": "Make sure that the 2D array has some minimum number of features\n(columns). The default value of 1 rejects empty datasets.\nThis check is only enforced when X has effectively 2 dimensions or\nis originally 1D and ``ensure_2d`` is True. Setting to 0 disables\nthis check."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.utils.validation/check_X_y/X",
          "name": "X",
          "qname": "sklearn.utils.validation.check_X_y.X",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "{ndarray, list, sparse matrix}",
            "default_value": "",
            "description": "Input data."
          },
          "type": {
            "kind": "EnumType",
            "values": []
          }
        },
        "hasCondition": {
          "condition": "when X has effectively 2 dimensions or is originally 1D and ensure_2d is True"
        },
        "hasAction": {
          "action": "This check is only enforced"
        }
      }
    ],
    "y_numeric": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.utils.validation/check_X_y/y_numeric",
          "name": "y_numeric",
          "qname": "sklearn.utils.validation.check_X_y.y_numeric",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "Whether to ensure that y has a numeric type. If dtype of y is object,\nit is converted to float64. Should only be used for regression\nalgorithms."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.utils.validation/check_X_y/dtype",
          "name": "dtype",
          "qname": "sklearn.utils.validation.check_X_y.dtype",
          "default_value": "'numeric'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "'numeric', type, list of type or None",
            "default_value": "'numeric'",
            "description": "Data type of result. If None, the dtype of the input is preserved.\nIf \"numeric\", dtype is preserved unless array.dtype is object.\nIf dtype is a list of types, conversion on the first type is only\nperformed if the dtype of the input is not in the list."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "'numeric'"
              },
              {
                "kind": "NamedType",
                "name": "type"
              },
              {
                "kind": "NamedType",
                "name": "list of type"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If dtype of y is object"
        },
        "hasAction": {
          "action": ", it is converted to float64"
        }
      }
    ]
  },
  "sklearn/sklearn.utils.validation/_check_y": {},
  "sklearn/sklearn.utils.validation/column_or_1d": {},
  "sklearn/sklearn.utils.validation/check_random_state": {
    "seed": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.utils.validation/check_random_state/seed",
          "name": "seed",
          "qname": "sklearn.utils.validation.check_random_state.seed",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "None, int or instance of RandomState",
            "default_value": "",
            "description": "If seed is None, return the RandomState singleton used by np.random.\nIf seed is an int, return a new RandomState instance seeded with seed.\nIf seed is already a RandomState instance, return it.\nOtherwise raise ValueError."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "None"
              },
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "instance of RandomState"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.utils.validation/check_random_state/seed",
          "name": "seed",
          "qname": "sklearn.utils.validation.check_random_state.seed",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "None, int or instance of RandomState",
            "default_value": "",
            "description": "If seed is None, return the RandomState singleton used by np.random.\nIf seed is an int, return a new RandomState instance seeded with seed.\nIf seed is already a RandomState instance, return it.\nOtherwise raise ValueError."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "None"
              },
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "instance of RandomState"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If seed is None"
        },
        "hasAction": {
          "action": ", return the RandomState singleton used by np.random"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.utils.validation/check_random_state/seed",
          "name": "seed",
          "qname": "sklearn.utils.validation.check_random_state.seed",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "None, int or instance of RandomState",
            "default_value": "",
            "description": "If seed is None, return the RandomState singleton used by np.random.\nIf seed is an int, return a new RandomState instance seeded with seed.\nIf seed is already a RandomState instance, return it.\nOtherwise raise ValueError."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "None"
              },
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "instance of RandomState"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.utils.validation/check_random_state/seed",
          "name": "seed",
          "qname": "sklearn.utils.validation.check_random_state.seed",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "None, int or instance of RandomState",
            "default_value": "",
            "description": "If seed is None, return the RandomState singleton used by np.random.\nIf seed is an int, return a new RandomState instance seeded with seed.\nIf seed is already a RandomState instance, return it.\nOtherwise raise ValueError."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "None"
              },
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "instance of RandomState"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If seed is an int"
        },
        "hasAction": {
          "action": ", return a new RandomState instance seeded with seed"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.utils.validation/check_random_state/seed",
          "name": "seed",
          "qname": "sklearn.utils.validation.check_random_state.seed",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "None, int or instance of RandomState",
            "default_value": "",
            "description": "If seed is None, return the RandomState singleton used by np.random.\nIf seed is an int, return a new RandomState instance seeded with seed.\nIf seed is already a RandomState instance, return it.\nOtherwise raise ValueError."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "None"
              },
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "instance of RandomState"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.utils.validation/check_random_state/seed",
          "name": "seed",
          "qname": "sklearn.utils.validation.check_random_state.seed",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "None, int or instance of RandomState",
            "default_value": "",
            "description": "If seed is None, return the RandomState singleton used by np.random.\nIf seed is an int, return a new RandomState instance seeded with seed.\nIf seed is already a RandomState instance, return it.\nOtherwise raise ValueError."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "None"
              },
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "instance of RandomState"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If seed is already a RandomState instance"
        },
        "hasAction": {
          "action": ", return it"
        }
      }
    ]
  },
  "sklearn/sklearn.utils.validation/has_fit_parameter": {},
  "sklearn/sklearn.utils.validation/check_symmetric": {
    "raise_exception": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.utils.validation/check_symmetric/raise_exception",
          "name": "raise_exception",
          "qname": "sklearn.utils.validation.check_symmetric.raise_exception",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "If True then raise an exception if array is not symmetric."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.utils.validation/check_symmetric/array",
          "name": "array",
          "qname": "sklearn.utils.validation.check_symmetric.array",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "{ndarray, sparse matrix}",
            "default_value": "",
            "description": "Input object to check / convert. Must be two-dimensional and square,\notherwise a ValueError will be raised."
          },
          "type": {
            "kind": "EnumType",
            "values": []
          }
        },
        "hasCondition": {
          "condition": "if array is not symmetric"
        },
        "hasAction": {
          "action": "If True then raise an exception"
        }
      }
    ]
  },
  "sklearn/sklearn.utils.validation/check_is_fitted": {},
  "sklearn/sklearn.utils.validation/check_non_negative": {},
  "sklearn/sklearn.utils.validation/check_scalar": {},
  "sklearn/sklearn.utils.validation/_check_psd_eigenvalues": {},
  "sklearn/sklearn.utils.validation/_check_sample_weight": {
    "dtype": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.utils.validation/_check_sample_weight/dtype",
          "name": "dtype",
          "qname": "sklearn.utils.validation._check_sample_weight.dtype",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "dtype",
            "default_value": "None",
            "description": "dtype of the validated `sample_weight`.\nIf None, and the input `sample_weight` is an array, the dtype of the\ninput is preserved; otherwise an array with the default numpy dtype\nis be allocated.  If `dtype` is not one of `float32`, `float64`,\n`None`, the output will be of dtype `float64`."
          },
          "type": {
            "kind": "NamedType",
            "name": "dtype"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.utils.validation/_check_sample_weight/sample_weight",
          "name": "sample_weight",
          "qname": "sklearn.utils.validation._check_sample_weight.sample_weight",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "{ndarray, Number or None}, shape (n_samples,)",
            "default_value": "",
            "description": "Input sample weights."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "EnumType",
                "values": []
              },
              {
                "kind": "NamedType",
                "name": "shape (n_samples,)"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If None , and the input sample_weight is an array , the dtype of the input is preserved"
        },
        "hasAction": {
          "action": "; otherwise an array with the default numpy dtype is be allocated"
        }
      }
    ]
  },
  "sklearn/sklearn.utils.validation/_allclose_dense_sparse": {},
  "sklearn/sklearn.utils.validation/_check_fit_params": {},
  "sklearn/sklearn.utils.validation/_get_feature_names": {},
  "sklearn/sklearn.utils.validation/_check_feature_names_in": {
    "input_features": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.utils.validation/_check_feature_names_in/input_features",
          "name": "input_features",
          "qname": "sklearn.utils.validation._check_feature_names_in.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features.\n\n- If `input_features` is `None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then the following input feature names are generated:\n  `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.utils.validation/_check_feature_names_in/input_features",
          "name": "input_features",
          "qname": "sklearn.utils.validation._check_feature_names_in.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features.\n\n- If `input_features` is `None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then the following input feature names are generated:\n  `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If input_features is None , then feature_names_in _"
        },
        "hasAction": {
          "action": "is used as feature names in"
        }
      },
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.utils.validation/_check_feature_names_in/input_features",
          "name": "input_features",
          "qname": "sklearn.utils.validation._check_feature_names_in.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features.\n\n- If `input_features` is `None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then the following input feature names are generated:\n  `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.utils.validation/_check_feature_names_in/input_features",
          "name": "input_features",
          "qname": "sklearn.utils.validation._check_feature_names_in.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features.\n\n- If `input_features` is `None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then the following input feature names are generated:\n  `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If input_features is"
        },
        "hasAction": {
          "action": "an array - like , then input_features must match feature_names_in _"
        }
      }
    ],
    "generate_names": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.utils.validation/_check_feature_names_in/generate_names",
          "name": "generate_names",
          "qname": "sklearn.utils.validation._check_feature_names_in.generate_names",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": false,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Whether to generate names when `input_features` is `None` and\n`estimator.feature_names_in_` is not defined. This is useful for transformers\nthat validates `input_features` but do not require them in\n:term:`get_feature_names_out` e.g. `PCA`."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.utils.validation/_check_feature_names_in/input_features",
          "name": "input_features",
          "qname": "sklearn.utils.validation._check_feature_names_in.input_features",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "array-like of str or None",
            "default_value": "None",
            "description": "Input features.\n\n- If `input_features` is `None`, then `feature_names_in_` is\n  used as feature names in. If `feature_names_in_` is not defined,\n  then the following input feature names are generated:\n  `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n- If `input_features` is an array-like, then `input_features` must\n  match `feature_names_in_` if `feature_names_in_` is defined."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array-like of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "when input_features is None and estimator.feature_names_in _"
        },
        "hasAction": {
          "action": "Whether to generate names"
        }
      }
    ]
  },
  "sklearn/sklearn.utils.validation/_generate_get_feature_names_out": {},
  "sklearn/sklearn.utils.validation/_check_monotonic_cst": {},
  "sklearn/sklearn.utils._arpack/_init_arpack_v0": {},
  "sklearn/sklearn.utils._array_api/_ArrayAPIWrapper/__init__": {},
  "sklearn/sklearn.utils._array_api/_ArrayAPIWrapper/__getattr__": {},
  "sklearn/sklearn.utils._array_api/_ArrayAPIWrapper/take": {},
  "sklearn/sklearn.utils._array_api/_NumPyApiWrapper/__getattr__": {},
  "sklearn/sklearn.utils._array_api/_NumPyApiWrapper/astype": {},
  "sklearn/sklearn.utils._array_api/_NumPyApiWrapper/asarray": {},
  "sklearn/sklearn.utils._array_api/_NumPyApiWrapper/unique_inverse": {},
  "sklearn/sklearn.utils._array_api/_NumPyApiWrapper/unique_counts": {},
  "sklearn/sklearn.utils._array_api/_NumPyApiWrapper/unique_values": {},
  "sklearn/sklearn.utils._array_api/_NumPyApiWrapper/concat": {},
  "sklearn/sklearn.utils._array_api/get_namespace": {},
  "sklearn/sklearn.utils._array_api/_expit": {},
  "sklearn/sklearn.utils._array_api/_asarray_with_order": {},
  "sklearn/sklearn.utils._array_api/_convert_to_numpy": {},
  "sklearn/sklearn.utils._array_api/_estimator_with_converted_arrays": {},
  "sklearn/sklearn.utils._available_if/_AvailableIfDescriptor/__init__": {},
  "sklearn/sklearn.utils._available_if/_AvailableIfDescriptor/__get__": {},
  "sklearn/sklearn.utils._available_if/available_if": {},
  "sklearn/sklearn.utils._bunch/Bunch/__init__": {},
  "sklearn/sklearn.utils._bunch/Bunch/__setattr__": {},
  "sklearn/sklearn.utils._bunch/Bunch/__dir__": {},
  "sklearn/sklearn.utils._bunch/Bunch/__getattr__": {},
  "sklearn/sklearn.utils._bunch/Bunch/__setstate__": {},
  "sklearn/sklearn.utils._encode/_unique": {},
  "sklearn/sklearn.utils._encode/_unique_np": {},
  "sklearn/sklearn.utils._encode/MissingValues/to_list": {},
  "sklearn/sklearn.utils._encode/_extract_missing": {},
  "sklearn/sklearn.utils._encode/_nandict/__init__": {},
  "sklearn/sklearn.utils._encode/_nandict/__missing__": {},
  "sklearn/sklearn.utils._encode/_map_to_integer": {},
  "sklearn/sklearn.utils._encode/_unique_python": {},
  "sklearn/sklearn.utils._encode/_encode": {},
  "sklearn/sklearn.utils._encode/_check_unknown": {},
  "sklearn/sklearn.utils._encode/_NaNCounter/__init__": {},
  "sklearn/sklearn.utils._encode/_NaNCounter/_generate_items": {},
  "sklearn/sklearn.utils._encode/_NaNCounter/__missing__": {},
  "sklearn/sklearn.utils._encode/_get_counts": {},
  "sklearn/sklearn.utils._estimator_html_repr/_IDCounter/__init__": {},
  "sklearn/sklearn.utils._estimator_html_repr/_IDCounter/get_id": {},
  "sklearn/sklearn.utils._estimator_html_repr/_VisualBlock/__init__": {
    "names": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.utils._estimator_html_repr/_VisualBlock/__init__/names",
          "name": "names",
          "qname": "sklearn.utils._estimator_html_repr._VisualBlock.__init__.names",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": false,
          "docstring": {
            "type": "list of str",
            "default_value": "None",
            "description": "If kind != 'single', then `names` corresponds to estimators.\nIf kind == 'single', then `names` is a single string corresponding to\nthe single estimator."
          },
          "type": {
            "kind": "NamedType",
            "name": "list of str"
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.utils._estimator_html_repr/_VisualBlock/__init__/kind",
          "name": "kind",
          "qname": "sklearn.utils._estimator_html_repr._VisualBlock.__init__.kind",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "{'serial', 'parallel', 'single'}",
            "default_value": "",
            "description": "kind of HTML block"
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "parallel",
              "serial",
              "single"
            ]
          }
        },
        "hasCondition": {
          "condition": "If kind does not equal single"
        },
        "hasAction": {
          "action": ", then names corresponds to estimators"
        }
      }
    ],
    "name_details": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.utils._estimator_html_repr/_VisualBlock/__init__/name_details",
          "name": "name_details",
          "qname": "sklearn.utils._estimator_html_repr._VisualBlock.__init__.name_details",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": false,
          "docstring": {
            "type": "list of str, str, or None",
            "default_value": "None",
            "description": "If kind != 'single', then `name_details` corresponds to `names`.\nIf kind == 'single', then `name_details` is a single string\ncorresponding to the single estimator."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "list of str"
              },
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.utils._estimator_html_repr/_VisualBlock/__init__/kind",
          "name": "kind",
          "qname": "sklearn.utils._estimator_html_repr._VisualBlock.__init__.kind",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "{'serial', 'parallel', 'single'}",
            "default_value": "",
            "description": "kind of HTML block"
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "parallel",
              "serial",
              "single"
            ]
          }
        },
        "hasCondition": {
          "condition": "If kind does not equal single"
        },
        "hasAction": {
          "action": ", then name_details corresponds to names"
        }
      }
    ]
  },
  "sklearn/sklearn.utils._estimator_html_repr/_VisualBlock/_sk_visual_block_": {},
  "sklearn/sklearn.utils._estimator_html_repr/_write_label_html": {},
  "sklearn/sklearn.utils._estimator_html_repr/_get_visual_block": {},
  "sklearn/sklearn.utils._estimator_html_repr/_write_estimator_html": {},
  "sklearn/sklearn.utils._estimator_html_repr/estimator_html_repr": {},
  "sklearn/sklearn.utils._mask/_get_dense_mask": {},
  "sklearn/sklearn.utils._mask/_get_mask": {},
  "sklearn/sklearn.utils._mocking/ArraySlicingWrapper/__init__": {},
  "sklearn/sklearn.utils._mocking/ArraySlicingWrapper/__getitem__": {},
  "sklearn/sklearn.utils._mocking/MockDataFrame/__init__": {},
  "sklearn/sklearn.utils._mocking/MockDataFrame/__len__": {},
  "sklearn/sklearn.utils._mocking/MockDataFrame/__array__": {},
  "sklearn/sklearn.utils._mocking/MockDataFrame/__eq__": {},
  "sklearn/sklearn.utils._mocking/MockDataFrame/__ne__": {},
  "sklearn/sklearn.utils._mocking/MockDataFrame/take": {},
  "sklearn/sklearn.utils._mocking/CheckingClassifier/__init__": {},
  "sklearn/sklearn.utils._mocking/CheckingClassifier/_check_X_y": {},
  "sklearn/sklearn.utils._mocking/CheckingClassifier/fit": {},
  "sklearn/sklearn.utils._mocking/CheckingClassifier/predict": {},
  "sklearn/sklearn.utils._mocking/CheckingClassifier/predict_proba": {},
  "sklearn/sklearn.utils._mocking/CheckingClassifier/decision_function": {},
  "sklearn/sklearn.utils._mocking/CheckingClassifier/score": {},
  "sklearn/sklearn.utils._mocking/CheckingClassifier/_more_tags": {},
  "sklearn/sklearn.utils._mocking/NoSampleWeightWrapper/__init__": {},
  "sklearn/sklearn.utils._mocking/NoSampleWeightWrapper/fit": {},
  "sklearn/sklearn.utils._mocking/NoSampleWeightWrapper/predict": {},
  "sklearn/sklearn.utils._mocking/NoSampleWeightWrapper/predict_proba": {},
  "sklearn/sklearn.utils._mocking/NoSampleWeightWrapper/_more_tags": {},
  "sklearn/sklearn.utils._param_validation/validate_parameter_constraints": {},
  "sklearn/sklearn.utils._param_validation/make_constraint": {},
  "sklearn/sklearn.utils._param_validation/validate_params": {},
  "sklearn/sklearn.utils._param_validation/_type_name": {},
  "sklearn/sklearn.utils._param_validation/_Constraint/__init__": {},
  "sklearn/sklearn.utils._param_validation/_Constraint/is_satisfied_by": {},
  "sklearn/sklearn.utils._param_validation/_Constraint/__str__": {},
  "sklearn/sklearn.utils._param_validation/_InstancesOf/__init__": {},
  "sklearn/sklearn.utils._param_validation/_InstancesOf/is_satisfied_by": {},
  "sklearn/sklearn.utils._param_validation/_InstancesOf/__str__": {},
  "sklearn/sklearn.utils._param_validation/_NoneConstraint/is_satisfied_by": {},
  "sklearn/sklearn.utils._param_validation/_NoneConstraint/__str__": {},
  "sklearn/sklearn.utils._param_validation/_NanConstraint/is_satisfied_by": {},
  "sklearn/sklearn.utils._param_validation/_NanConstraint/__str__": {},
  "sklearn/sklearn.utils._param_validation/_PandasNAConstraint/is_satisfied_by": {},
  "sklearn/sklearn.utils._param_validation/_PandasNAConstraint/__str__": {},
  "sklearn/sklearn.utils._param_validation/Options/__init__": {},
  "sklearn/sklearn.utils._param_validation/Options/is_satisfied_by": {},
  "sklearn/sklearn.utils._param_validation/Options/_mark_if_deprecated": {},
  "sklearn/sklearn.utils._param_validation/Options/__str__": {},
  "sklearn/sklearn.utils._param_validation/StrOptions/__init__": {},
  "sklearn/sklearn.utils._param_validation/Interval/__init__": {},
  "sklearn/sklearn.utils._param_validation/Interval/_check_params": {},
  "sklearn/sklearn.utils._param_validation/Interval/__contains__": {},
  "sklearn/sklearn.utils._param_validation/Interval/is_satisfied_by": {},
  "sklearn/sklearn.utils._param_validation/Interval/__str__": {},
  "sklearn/sklearn.utils._param_validation/_ArrayLikes/is_satisfied_by": {},
  "sklearn/sklearn.utils._param_validation/_ArrayLikes/__str__": {},
  "sklearn/sklearn.utils._param_validation/_SparseMatrices/is_satisfied_by": {},
  "sklearn/sklearn.utils._param_validation/_SparseMatrices/__str__": {},
  "sklearn/sklearn.utils._param_validation/_Callables/is_satisfied_by": {},
  "sklearn/sklearn.utils._param_validation/_Callables/__str__": {},
  "sklearn/sklearn.utils._param_validation/_RandomStates/__init__": {},
  "sklearn/sklearn.utils._param_validation/_RandomStates/is_satisfied_by": {},
  "sklearn/sklearn.utils._param_validation/_RandomStates/__str__": {},
  "sklearn/sklearn.utils._param_validation/_Booleans/__init__": {},
  "sklearn/sklearn.utils._param_validation/_Booleans/is_satisfied_by": {},
  "sklearn/sklearn.utils._param_validation/_Booleans/__str__": {},
  "sklearn/sklearn.utils._param_validation/_VerboseHelper/__init__": {},
  "sklearn/sklearn.utils._param_validation/_VerboseHelper/is_satisfied_by": {},
  "sklearn/sklearn.utils._param_validation/_VerboseHelper/__str__": {},
  "sklearn/sklearn.utils._param_validation/_MissingValues/__init__": {},
  "sklearn/sklearn.utils._param_validation/_MissingValues/is_satisfied_by": {},
  "sklearn/sklearn.utils._param_validation/_MissingValues/__str__": {},
  "sklearn/sklearn.utils._param_validation/HasMethods/__init__": {},
  "sklearn/sklearn.utils._param_validation/HasMethods/is_satisfied_by": {},
  "sklearn/sklearn.utils._param_validation/HasMethods/__str__": {},
  "sklearn/sklearn.utils._param_validation/_IterablesNotString/is_satisfied_by": {},
  "sklearn/sklearn.utils._param_validation/_IterablesNotString/__str__": {},
  "sklearn/sklearn.utils._param_validation/_CVObjects/__init__": {},
  "sklearn/sklearn.utils._param_validation/_CVObjects/is_satisfied_by": {},
  "sklearn/sklearn.utils._param_validation/_CVObjects/__str__": {},
  "sklearn/sklearn.utils._param_validation/Hidden/__init__": {},
  "sklearn/sklearn.utils._param_validation/generate_invalid_param_val": {},
  "sklearn/sklearn.utils._param_validation/_generate_invalid_param_val_interval": {},
  "sklearn/sklearn.utils._param_validation/generate_valid_param": {},
  "sklearn/sklearn.utils._pprint/KeyValTuple/__repr__": {},
  "sklearn/sklearn.utils._pprint/_changed_params": {},
  "sklearn/sklearn.utils._pprint/_EstimatorPrettyPrinter/__init__": {},
  "sklearn/sklearn.utils._pprint/_EstimatorPrettyPrinter/format": {},
  "sklearn/sklearn.utils._pprint/_EstimatorPrettyPrinter/_pprint_estimator": {},
  "sklearn/sklearn.utils._pprint/_EstimatorPrettyPrinter/_format_dict_items": {},
  "sklearn/sklearn.utils._pprint/_EstimatorPrettyPrinter/_format_params": {},
  "sklearn/sklearn.utils._pprint/_EstimatorPrettyPrinter/_format_params_or_dict_items": {},
  "sklearn/sklearn.utils._pprint/_EstimatorPrettyPrinter/_format_items": {},
  "sklearn/sklearn.utils._pprint/_EstimatorPrettyPrinter/_pprint_key_val_tuple": {},
  "sklearn/sklearn.utils._pprint/_safe_repr": {},
  "sklearn/sklearn.utils._set_output/_wrap_in_pandas_container": {
    "columns": [
      {
        "hasDependentParameter": {
          "id": "sklearn/sklearn.utils._set_output/_wrap_in_pandas_container/columns",
          "name": "columns",
          "qname": "sklearn.utils._set_output._wrap_in_pandas_container.columns",
          "default_value": null,
          "assigned_by": "NAME_ONLY",
          "is_public": false,
          "docstring": {
            "type": "callable, ndarray, or None",
            "default_value": "",
            "description": "The column names or a callable that returns the column names. The\ncallable is useful if the column names require some computation.\nIf `columns` is a callable that raises an error, `columns` will have\nthe same semantics as `None`. If `None` and `data_to_wrap` is already a\ndataframe, then the column names are not changed. If `None` and\n`data_to_wrap` is **not** a dataframe, then columns are\n`range(n_features)`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "callable"
              },
              {
                "kind": "NamedType",
                "name": "ndarray"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "isDependingOn": {
          "id": "sklearn/sklearn.utils._set_output/_wrap_in_pandas_container/columns",
          "name": "columns",
          "qname": "sklearn.utils._set_output._wrap_in_pandas_container.columns",
          "default_value": null,
          "assigned_by": "NAME_ONLY",
          "is_public": false,
          "docstring": {
            "type": "callable, ndarray, or None",
            "default_value": "",
            "description": "The column names or a callable that returns the column names. The\ncallable is useful if the column names require some computation.\nIf `columns` is a callable that raises an error, `columns` will have\nthe same semantics as `None`. If `None` and `data_to_wrap` is already a\ndataframe, then the column names are not changed. If `None` and\n`data_to_wrap` is **not** a dataframe, then columns are\n`range(n_features)`."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "callable"
              },
              {
                "kind": "NamedType",
                "name": "ndarray"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        "hasCondition": {
          "condition": "If columns is a callable that raises an error"
        },
        "hasAction": {
          "action": ", columns will have the same semantics as None"
        }
      }
    ]
  },
  "sklearn/sklearn.utils._set_output/_get_output_config": {},
  "sklearn/sklearn.utils._set_output/_wrap_data_with_container": {},
  "sklearn/sklearn.utils._set_output/_wrap_method_output": {},
  "sklearn/sklearn.utils._set_output/_auto_wrap_is_configured": {},
  "sklearn/sklearn.utils._set_output/_SetOutputMixin/__init_subclass__": {},
  "sklearn/sklearn.utils._set_output/_SetOutputMixin/set_output": {},
  "sklearn/sklearn.utils._set_output/_safe_set_output": {},
  "sklearn/sklearn.utils._show_versions/_get_sys_info": {},
  "sklearn/sklearn.utils._show_versions/_get_deps_info": {},
  "sklearn/sklearn.utils._show_versions/show_versions": {},
  "sklearn/sklearn.utils._tags/_safe_tags": {},
  "sklearn/sklearn.utils._testing/assert_no_warnings": {},
  "sklearn/sklearn.utils._testing/ignore_warnings": {},
  "sklearn/sklearn.utils._testing/_IgnoreWarnings/__init__": {},
  "sklearn/sklearn.utils._testing/_IgnoreWarnings/__call__": {},
  "sklearn/sklearn.utils._testing/_IgnoreWarnings/__repr__": {},
  "sklearn/sklearn.utils._testing/_IgnoreWarnings/__enter__": {},
  "sklearn/sklearn.utils._testing/_IgnoreWarnings/__exit__": {},
  "sklearn/sklearn.utils._testing/assert_raise_message": {},
  "sklearn/sklearn.utils._testing/assert_allclose": {},
  "sklearn/sklearn.utils._testing/assert_allclose_dense_sparse": {},
  "sklearn/sklearn.utils._testing/set_random_state": {},
  "sklearn/sklearn.utils._testing/check_skip_network": {},
  "sklearn/sklearn.utils._testing/_delete_folder": {},
  "sklearn/sklearn.utils._testing/TempMemmap/__init__": {},
  "sklearn/sklearn.utils._testing/TempMemmap/__enter__": {},
  "sklearn/sklearn.utils._testing/TempMemmap/__exit__": {},
  "sklearn/sklearn.utils._testing/_create_memmap_backed_array": {},
  "sklearn/sklearn.utils._testing/_create_aligned_memmap_backed_arrays": {},
  "sklearn/sklearn.utils._testing/create_memmap_backed_data": {},
  "sklearn/sklearn.utils._testing/_get_args": {},
  "sklearn/sklearn.utils._testing/_get_func_name": {},
  "sklearn/sklearn.utils._testing/check_docstring_parameters": {},
  "sklearn/sklearn.utils._testing/assert_run_python_script": {},
  "sklearn/sklearn.utils._testing/_convert_container": {},
  "sklearn/sklearn.utils._testing/raises": {},
  "sklearn/sklearn.utils._testing/_Raises/__init__": {},
  "sklearn/sklearn.utils._testing/_Raises/__exit__": {},
  "sklearn/sklearn.utils._testing/MinimalClassifier/__init__": {},
  "sklearn/sklearn.utils._testing/MinimalClassifier/get_params": {},
  "sklearn/sklearn.utils._testing/MinimalClassifier/set_params": {},
  "sklearn/sklearn.utils._testing/MinimalClassifier/fit": {},
  "sklearn/sklearn.utils._testing/MinimalClassifier/predict_proba": {},
  "sklearn/sklearn.utils._testing/MinimalClassifier/predict": {},
  "sklearn/sklearn.utils._testing/MinimalClassifier/score": {},
  "sklearn/sklearn.utils._testing/MinimalRegressor/__init__": {},
  "sklearn/sklearn.utils._testing/MinimalRegressor/get_params": {},
  "sklearn/sklearn.utils._testing/MinimalRegressor/set_params": {},
  "sklearn/sklearn.utils._testing/MinimalRegressor/fit": {},
  "sklearn/sklearn.utils._testing/MinimalRegressor/predict": {},
  "sklearn/sklearn.utils._testing/MinimalRegressor/score": {},
  "sklearn/sklearn.utils._testing/MinimalTransformer/__init__": {},
  "sklearn/sklearn.utils._testing/MinimalTransformer/get_params": {},
  "sklearn/sklearn.utils._testing/MinimalTransformer/set_params": {},
  "sklearn/sklearn.utils._testing/MinimalTransformer/fit": {},
  "sklearn/sklearn.utils._testing/MinimalTransformer/transform": {},
  "sklearn/sklearn.utils._testing/MinimalTransformer/fit_transform": {}
}